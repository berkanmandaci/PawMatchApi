This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
api/obj/PawMatch.Infrastructure.EntityFrameworkCore.targets
ApiDoc.md
DevLog.md
docker-compose.yml
Dockerfile
ef_core_migration_guide.md
iyileştirme.md
matchandmessagesfeaturedoc.md
matchandmessagesfeaturetodo.md
messagesystem.md
PawMatch.Api/.gitignore
PawMatch.Api/appsettings.json
PawMatch.Api/Controllers/BaseController.cs
PawMatch.Api/Controllers/MatchesController.cs
PawMatch.Api/Controllers/MessagesController.cs
PawMatch.Api/Controllers/PhotosController.cs
PawMatch.Api/Controllers/UsersController.cs
PawMatch.Api/Controllers/WeatherForecastController.cs
PawMatch.Api/Hubs/ChatHub.cs
PawMatch.Api/PawMatch.Api.csproj
PawMatch.Api/PawMatch.Api.http
PawMatch.Api/Program.cs
PawMatch.Api/Properties/launchSettings.json
PawMatch.Api/Services/SignalRNotificationService.cs
PawMatch.Api/WeatherForecast.cs
PawMatch.Application/.gitignore
PawMatch.Application/Class1.cs
PawMatch.Application/DTOs/DiscoverUserPetDto.cs
PawMatch.Application/DTOs/MatchActionDto.cs
PawMatch.Application/DTOs/MatchDto.cs
PawMatch.Application/DTOs/MessageDto.cs
PawMatch.Application/DTOs/PetDto.cs
PawMatch.Application/DTOs/PhotoDto.cs
PawMatch.Application/DTOs/PhotoUploadDto.cs
PawMatch.Application/DTOs/UpdateProfileDto.cs
PawMatch.Application/DTOs/UserAuthResponseDto.cs
PawMatch.Application/DTOs/UserBaseDto.cs
PawMatch.Application/DTOs/UserLoginDto.cs
PawMatch.Application/DTOs/UserPublicDto.cs
PawMatch.Application/DTOs/UserRegisterDto.cs
PawMatch.Application/Interfaces/IDiscoverService.cs
PawMatch.Application/Interfaces/IMatchService.cs
PawMatch.Application/Interfaces/IMessageService.cs
PawMatch.Application/Interfaces/IPhotoService.cs
PawMatch.Application/Interfaces/IRealtimeNotificationService.cs
PawMatch.Application/Interfaces/IUserService.cs
PawMatch.Application/PawMatch.Application.csproj
PawMatch.Application/Services/DiscoverService.cs
PawMatch.Application/Services/MatchService.cs
PawMatch.Application/Services/MessageService.cs
PawMatch.Application/Services/PhotoService.cs
PawMatch.Application/Services/UserService.cs
PawMatch.Domain/.gitignore
PawMatch.Domain/Class1.cs
PawMatch.Domain/Match.cs
PawMatch.Domain/Message.cs
PawMatch.Domain/PawMatch.Domain.csproj
PawMatch.Domain/Pet.cs
PawMatch.Domain/Photo.cs
PawMatch.Domain/User.cs
PawMatch.Domain/UserSwipe.cs
PawMatch.Infrastructure/.gitignore
PawMatch.Infrastructure/AppDbContext.cs
PawMatch.Infrastructure/Class1.cs
PawMatch.Infrastructure/Interfaces/IJwtProvider.cs
PawMatch.Infrastructure/Interfaces/IMatchRepository.cs
PawMatch.Infrastructure/Interfaces/IMessageRepository.cs
PawMatch.Infrastructure/Interfaces/IStorageProvider.cs
PawMatch.Infrastructure/Interfaces/IUserRepository.cs
PawMatch.Infrastructure/Interfaces/IUserSwipeRepository.cs
PawMatch.Infrastructure/Migrations/20250617224635_InitialCreate.cs
PawMatch.Infrastructure/Migrations/20250617224635_InitialCreate.Designer.cs
PawMatch.Infrastructure/PawMatch.Infrastructure.csproj
PawMatch.Infrastructure/Providers/GoogleDriveStorageProvider.cs
PawMatch.Infrastructure/Providers/JwtProvider.cs
PawMatch.Infrastructure/Repositories/MatchRepository.cs
PawMatch.Infrastructure/Repositories/MessageRepository.cs
PawMatch.Infrastructure/Repositories/UserRepository.cs
PawMatch.Infrastructure/Repositories/UserSwipeRepository.cs
PawMatch.sln
PawMatch.sln.DotSettings.user
PawMatch.Tests/.gitignore
PawMatch.Tests/CustomWebApplicationFactory.cs
PawMatch.Tests/DiscoverServiceTests.cs
PawMatch.Tests/MatchesControllerTests.cs
PawMatch.Tests/PawMatch.Tests.csproj
PawMatch.Tests/PhotosControllerTests.cs
PawMatch.Tests/SignalRHubTests.cs
PawMatch.Tests/UsersControllerTests.cs
PawMatch.Tests/UserSwipes.csv
wait-for-it.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="iyileştirme.md">
1. Eksik ve Yetersiz İş Mantığı Implementasyonları (TODO'lar ve Yer Tutucular):
MatchService.cs - LikeOrPassAsync metodu: Bu metot şu anda sadece statik bir MatchResultDto döndürüyor ve içinde açıkça bir TODO: Gerçek eşleşme mantığı eklenecek notu bulunuyor. Bu, eşleşme mekanizmasının temel iş mantığının henüz tamamlanmadığı anlamına geliyor.
DiscoverService.cs - GetDiscoveredUserIdsAsync metodu: Bu metot, keşif algoritması için bir yer tutucu niteliğinde. Şu anda sadece mevcut kullanıcı dışındaki ilk 5 kullanıcı ID'sini döndürüyor. İçindeki yorumlar da (Bu şimdilik sahte bir keşif algoritmasıdır.) gerçek bir keşif mantığının (konum, tercihler vb. temel alarak) henüz uygulanmadığını gösteriyor. MatchesController'daki keşif algoritmasının burada uygulanması gerektiği belirtilmiş.
PhotosController.cs - UploadPetPhoto'daki Pet Sahiplik Kontrolü: Bu endpoint'te evcil hayvanın gerçekten fotoğrafı yükleyen kullanıcıya ait olup olmadığına dair bir kontrol eksikliği var. Kodda // Dummy sahiplik kontrolü (gerçek uygulamada DB'den kontrol edilmeli) şeklinde bir yorum ve yorum satırı olarak bırakılmış bir _petService.UserOwnsPet çağrısı bulunuyor. Bu, önemli bir güvenlik açığıdır ve bu kontrolün acilen gerçek bir doğrulama ile değiştirilmesi gerekmektedir.
2. Güvenlik ve Yapılandırma Eksiklikleri/İyileştirme Alanları:
JwtProvider.cs - Sabit Kodlanmış JWT Gizli Anahtarı: JWT token'larının oluşturulduğu JwtProvider.cs dosyasında, gizli anahtar ("super-secret-key-which-is-at-least-32-chars!") doğrudan kod içine yazılmıştır. Bu, bir güvenlik zafiyetidir. Bu anahtarın appsettings.json gibi bir yapılandırma dosyasından veya ortam değişkenlerinden okunacak şekilde güncellenmesi gerekmektedir. Program.cs'te de aynı anahtar kullanılıyor, bu da merkezi bir yapılandırmanın önemini vurguluyor.
GoogleDriveStorageProvider.cs - Kimlik Bilgileri Yolu Yönetimi: Google Drive kimlik bilgileri için varsayılan yol "api/credentials/credentials.json" olarak sabit kodlanmış. Ortam değişkeninden okunması tercih edilse de, bu dosyanın hassas veri içerebileceği ve .gitignore dosyası ile kesinlikle sürüm kontrol sisteminden dışlanması gerektiği unutulmamalıdır. Genellikle, hassas kimlik bilgisi dosyalarının bir volume üzerinden mount edilmesi en iyi yaklaşımdır, ki docker-compose.yml bunu zaten yapıyor. Ancak geliştirme ortamında sabit kodlanmış yolun kullanılması durumunda dikkatli olunmalıdır.
docker-compose.yml - ASPNETCORE_ENVIRONMENT=Production Ortam Değişkeni: docker-compose.yml dosyasında app servisi için ASPNETCORE_ENVIRONMENT=Production olarak ayarlanmış. Ancak Program.cs'te veritabanı migrasyon ve seed işlemleri app.Environment.IsDevelopment() && !app.Environment.IsEnvironment("Testing") koşuluna bağlı. Eğer bu docker-compose.yml geliştirme için kullanılıyorsa, ortam değişkeni Development olarak ayarlanmalı veya migrasyon ve seed işlemleri konteynerin başlangıcında ayrı bir script (örneğin wait-for-it.sh'in ardından) ile yönetilmelidir. Aksi takdirde, geliştirme ortamında veritabanı otomatik olarak oluşturulup seedlenmeyecektir.
PhotosController.cs - GetPhoto için Content-Type Belirleme: GetPhoto endpoint'inde dönen fotoğraf akışının Content-Type'ı image/jpeg olarak sabit kodlanmıştır. PhotoDto'da ContentType alanı olmasına rağmen, bu değer veritabanından çekilip yanıta yansıtılmıyor. Bu küçük bir kusurdur ve dinamik olarak belirlenmesi daha doğru olacaktır.
3. Test Altyapısında Potansiyel Geliştirmeler (Genel İyileştirme):
Hata Senaryosu Testlerinin Kapsamı: UsersControllerTests.cs ve PhotosControllerTests.cs genellikle başarılı senaryoları kapsıyor. Geçersiz girdiler (validation hataları), yetkilendirme hataları (geçersiz token), bulunamayan kaynaklar (404 Not Found) ve sunucu tarafı hataları (500 Internal Server Error) gibi olumsuz senaryolar için daha fazla test eklemek, API'nin sağlamlığını artıracaktır.
</file>

<file path=".gitignore">
.idea/
.env
</file>

<file path="api/obj/PawMatch.Infrastructure.EntityFrameworkCore.targets">
<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="GetEFProjectMetadata">
    <MSBuild Condition=" '$(TargetFramework)' == '' "
             Projects="$(MSBuildProjectFile)"
             Targets="GetEFProjectMetadata"
             Properties="TargetFramework=$(TargetFrameworks.Split(';')[0]);EFProjectMetadataFile=$(EFProjectMetadataFile)" />
    <ItemGroup Condition=" '$(TargetFramework)' != '' ">
      <EFProjectMetadata Include="AssemblyName: $(AssemblyName)" />
      <EFProjectMetadata Include="Language: $(Language)" />
      <EFProjectMetadata Include="OutputPath: $(OutputPath)" />
      <EFProjectMetadata Include="Platform: $(Platform)" />
      <EFProjectMetadata Include="PlatformTarget: $(PlatformTarget)" />
      <EFProjectMetadata Include="ProjectAssetsFile: $(ProjectAssetsFile)" />
      <EFProjectMetadata Include="ProjectDir: $(ProjectDir)" />
      <EFProjectMetadata Include="RootNamespace: $(RootNamespace)" />
      <EFProjectMetadata Include="RuntimeFrameworkVersion: $(RuntimeFrameworkVersion)" />
      <EFProjectMetadata Include="TargetFileName: $(TargetFileName)" />
      <EFProjectMetadata Include="TargetFrameworkMoniker: $(TargetFrameworkMoniker)" />
      <EFProjectMetadata Include="Nullable: $(Nullable)" />
      <EFProjectMetadata Include="TargetFramework: $(TargetFramework)" />
      <EFProjectMetadata Include="TargetPlatformIdentifier: $(TargetPlatformIdentifier)" />
    </ItemGroup>
    <WriteLinesToFile Condition=" '$(TargetFramework)' != '' "
                      File="$(EFProjectMetadataFile)"
                      Lines="@(EFProjectMetadata)" />
  </Target>
</Project>
</file>

<file path="ApiDoc.md">
# PawMatch Backend API Dokümantasyonu

Bu doküman, PawMatch uygulamasının backend API'lerini ve uyulması gereken temel kuralları özetler.

## 1. Genel Kurallar

*   **Mimari**: Katmanlı mimari (.NET 8+ MVC - Controller-Based API) kullanılmıştır. İş mantığı servis katmanında (`PawMatch.Application.Services`), veri erişimi repository deseniyle (`PawMatch.Infrastructure.Repositories`) yönetilir.
*   **SOLID Prensipleri**: Kod genel olarak SOLID prensiplerine uygun tasarlanmıştır, özellikle bağımlılıkların arayüzler üzerinden enjekte edilmesi (`IUserService`, `IStorageProvider` vb.) dikkat çeker.
*   **RESTful Prensipler**: API endpoint'leri RESTful prensiplere uygun olarak HTTP metotları (GET, POST, PATCH, DELETE) kullanır.
*   **API Versiyonlama**: Tüm API endpoint'leri `/api/v1/` ön eki ile versiyonlanmıştır.
*   **Yanıt Formatı**: Başarılı API yanıtları `{ "data": {}, "status": "success", "error": null }` formatındadır. Hata yanıtları genellikle `{ "status": "error", "error": "mesaj" }` formatını kullanır.
*   **Kimlik Doğrulama**: Çoğu endpoint JWT (JSON Web Token) ile korunmaktadır. Kullanıcı kimliği doğrulama için `[Authorize]` niteliği kullanılır.
*   **Güvenlik**:
    *   Şifreler BCrypt ile hash'lenir.
    *   Google Drive'da depolanan fotoğraflar özeldir (private) ve doğrudan herkese açık bağlantılar paylaşılmaz.
    *   Fotoğraf yüklemeleri için dosya tipi (JPEG/PNG) ve boyutu (maksimum 5 MB) doğrulaması yapılır.
    *   Fotoğraf görüntüleme için gelişmiş yetkilendirme kuralları uygulanır (sadece fotoğrafın sahibi, evcil hayvanın sahibi veya keşif listesindeki kullanıcılar erişebilir).
*   **Veritabanı**: PostgreSQL, Entity Framework Core (Code First) ile kullanılır. Testler için in-memory veritabanı kullanılır.
*   **Konteynerleştirme**: Uygulama Docker kullanılarak konteynerleştirilmiştir. `docker-compose.yml` ile uygulama ve PostgreSQL veritabanı servisleri birlikte yönetilir.

## 2. API Endpoint'leri

### 2.1. Kimlik Doğrulama ve Kullanıcı Yönetimi (`/api/v1/users`)

*   **Kullanıcı Kaydı**
    *   `POST /api/v1/users/register`
    *   Açıklama: Yeni bir kullanıcı hesabı oluşturur ve başarılı olursa JWT token döndürür.
    *   Girdi DTO: `UserRegisterDto` (name, email, password)
    *   Çıktı DTO: `UserAuthResponseDto` (user: UserDto, token)

*   **Kullanıcı Girişi**
    *   `POST /api/v1/users/login`
    *   Açıklama: Mevcut bir kullanıcının kimlik bilgileriyle giriş yapar ve JWT token döndürür.
    *   Girdi DTO: `UserLoginDto` (email, password)
    *   Çıktı DTO: `UserAuthResponseDto` (user: UserDto, token)

*   **Kullanıcı Profilini Güncelleme**
    *   `PATCH /api/v1/users/profile`
    *   Açıklama: Kimliği doğrulanmış kullanıcının profil bilgilerini (adı, biyografisi, evcil hayvanı olup olmadığı) günceller.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   Girdi DTO: `UpdateProfileDto` (name, bio, hasPet)
    *   Çıktı DTO: `UserAuthResponseDto` (user: UserDto, token)

*   **Kullanıcı Hesabını Silme**
    *   `DELETE /api/v1/users/me`
    *   Açıklama: Kimliği doğrulanmış kullanıcının hesabını ve ilişkili tüm verilerini (evcil hayvanlar, fotoğraflar) siler.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   Girdi: Yok
    *   Çıktı: Başarılı yanıt (`status: "success"`)

*   **Kullanıcı Profil Bilgilerini Getirme**
    *   `GET /api/v1/users/me`
    *   Açıklama: Kimliği doğrulanmış kullanıcının profil bilgilerini döndürür.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   Girdi: Yok
    *   Çıktı DTO: `UserDto` (id, name, email, bio, hasPet, hasProfile, PhotoIds)

### 2.2. Eşleşme ve Keşif Mekanizması (`/api/v1/matches`)

*   **Kullanıcı/Pet Kartlarını Keşfetme**
    *   `GET /api/v1/matches/discover`
    *   Açıklama: Keşif için uygun kullanıcı ve evcil hayvan kartlarını listeler. Şu anda giriş yapan kullanıcı dışındaki tüm kullanıcıları basitçe listeler.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   Sorgu Parametreleri: `maxDistanceKm` (int, opsiyonel), `offset` (int, opsiyonel), `limit` (int, opsiyonel)
    *   Çıktı DTO: `List<DiscoverUserPetDto>` (user: DiscoverUserDto, pet: DiscoverPetDto)

*   **Beğenme/Geçme İşlemi**
    *   `POST /api/v1/matches`
    *   Açıklama: Bir kullanıcıya yönelik beğenme (like) veya geçme (pass) işlemini gerçekleştirir. Eşleşme mantığı henüz tamamlanmamıştır (TODO).
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   Girdi DTO: `MatchActionDto` (user1Id, user2Id, liked)
    *   Çıktı DTO: `MatchResultDto` (matchId, confirmed)

### 2.3. Fotoğraf Yönetimi (`/api/v1/photos`)

*   **Kullanıcı Profil Fotoğrafı Yükleme**
    *   `POST /api/v1/photos/user`
    *   Açıklama: Kimliği doğrulanmış kullanıcıya bir fotoğraf yükler.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   Girdi: Multipart form-data (`IFormFile` - JPEG/PNG, maks. 5 MB)
    *   Çıktı DTO: `PhotoDto` (id, fileName, contentType, googleDriveFileId, uploadDate, userId, petId)

*   **Pet Fotoğrafı Yükleme**
    *   `POST /api/v1/users/pets/{petId}/photos`
    *   Açıklama: Belirtilen evcil hayvana bir fotoğraf yükler.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   URL Parametreleri: `petId` (int)
    *   Girdi: Multipart form-data (`IFormFile` - JPEG/PNG, maks. 5 MB)
    *   Çıktı DTO: `PhotoDto` (id, fileName, contentType, googleDriveFileId, uploadDate, userId, petId)

*   **Fotoğraf Görüntüleme**
    *   `GET /api/v1/photos/{id}`
    *   Açıklama: Belirtilen Google Drive Dosya Kimliğine (`id`) sahip fotoğrafın akışını döndürür. Yetkilendirme kuralları uygulanır.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   URL Parametreleri: `id` (string - Google Drive File ID)
    *   Çıktı: Fotoğraf akışı (`FileStreamResult`)

*   **Fotoğraf Silme**
    *   `DELETE /api/v1/photos/{id}`
    *   Açıklama: Belirtilen Google Drive Dosya Kimliğine (`id`) sahip fotoğrafı hem Google Drive'dan hem de veritabanından siler.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   URL Parametreleri: `id` (string - Google Drive File ID)
    *   Çıktı: Başarılı yanıt (`status: "success"`)

## 3. Repository Katmanı Güncellemesi

- Eşleşme işlemleri için IMatchRepository arayüzü ve MatchRepository implementasyonu eklendi.
- MatchService, eşleşme işlemlerinde doğrudan DbContext yerine MatchRepository kullanıyor.
- Program.cs'de IMatchRepository için DI kaydı yapıldı.
- Mesajlaşma ve eşleşme endpointleri için repository altyapısı tamamlandı.
</file>

<file path="DevLog.md">
# 2024-06-15 Geliştirme Günlüğü

- JWT authentication gerçek anahtar ile uygulandı, demo için 32+ karakterlik key kullanıldı
- Swagger/OpenAPI açıklamaları login, register, profil ve matches endpointlerine eklendi
- Dummy user, pet ve photo verileri için seed işlemi eklendi (development ortamında otomatik)
- /api/v1/matches/discover ve /api/v1/matches (like/pass) endpointleri eklendi, JWT ile korumalı
- Discover endpointi artık veritabanındaki tüm kullanıcıları (giriş yapan hariç), pet ve fotoğraflarıyla döndürüyor
- Dockerfile ve docker-compose ile wait-for-it.sh entegrasyonu yapıldı, migration/seed işlemleri sorunsuz başlatılıyor
- JWT üretimi ve doğrulaması için gerekli NuGet paketleri eklendi
- Hatalı token, kısa anahtar, vs. gibi build ve runtime hataları giderildi
- Kodda eksik kalan mock/boş metotlar gerçek veritabanı sorguları ile güncellendi

# 2024-06-14 Geliştirme Günlüğü

- Proje iskeleti oluşturuldu (Api, Application, Domain, Infrastructure, Tests katmanları)
- Dockerfile ve docker-compose.yml hazırlandı, PostgreSQL entegrasyonu sağlandı
- Gerekli NuGet paketleri ve projeler arası referanslar eklendi
- User, Pet, Photo entity'leri ve DbContext yazıldı
- Kullanıcı kayıt ve login için DTO, servis, repository, controller ve JWT altyapısı kuruldu
- EF Core migration ve database update işlemleri için rehberlik edildi
- Build ve migration hataları giderildi (referans, namespace, connection string, tablo eksikliği)
- Proje başarıyla ayağa kaldırıldı ve temel API endpointleri çalışır hale getirildi

# 2024-06-15 Geliştirme Günlüğü (Devamı)

- JWT'den userId çekme işlemleri için merkezi `BaseController` oluşturuldu.
- `UsersController`, `PhotosController`, `MatchesController` ve `WeatherForecastController` artık `BaseController`'dan miras alıyor ve `GetUserIdFromClaims()` fonksiyonunu kullanıyor.
- `GetUserIdFromClaims()` fonksiyonundaki hatalı claim adı (`"nameid"` yerine `ClaimTypes.NameIdentifier`) düzeltildi, böylece kullanıcı kimlik doğrulama sorunları giderildi.
- Fotoğraf yükleme endpointleri ve akışları tamamen test edildi ve başarılı şekilde çalışıyor (örn. `POST /api/v1/photos/user`).
- `api/photofeature.md` ve `app/photofeature.md` dosyaları güncel backend ve frontend implementasyonlarına uygun şekilde revize edildi, hatalı endpoint isimleri ve akışlar düzeltildi.
- `docs/PawMatch Backend Guidelines.markdown` dokümanı güncel backend mimarisi ve endpoint detaylarına göre revize edildi, eski ve hatalı bilgiler temizlendi.
- `IDiscoverService` ve `DiscoverService` eklendi, DiscoverService şimdilik basit bir keşif listesi sağlıyor.
- Fotoğraf görüntüleme endpointindeki erişim kontrolü güncellendi: kullanıcı kendi fotoğrafını, kendi evcil hayvanının fotoğrafını veya keşfedilenler listesindeki bir kullanıcının fotoğrafını görebiliyor.

# 2024-06-16 Geliştirme Günlüğü

- Kullanıcı kayıt, giriş ve profil güncelleme API uç noktaları için entegrasyon testleri eklendi.
- Test ortamında `AppDbContext` ve `Program` sınıfı ile ilgili erişim ve uyumluluk sorunları giderildi.
- Kullanıcının kendi hesabını silebilmesi için `DELETE /api/v1/users/me` uç noktası ve `UserService` içinde `DeleteUserAsync` metodu uygulandı.
- Hesap silindiğinde kullanıcıya ve evcil hayvanlara ait fotoğrafların da silinmesi için `IPhotoService`'e ilgili metotlar eklendi ve `UserService` içinde çağrıldı.
- Google Drive entegrasyonu testleri için `IStorageProvider` arayüzü mock'lanarak test ortamı bağımlılıkları giderildi.
- Fotoğraf yükleme testlerinde `StreamContent` için `ContentType` başlığı doğru şekilde ayarlandı.
- Fotoğraf testlerinde devam eden `FileName` boş ve `404 Not Found` hataları üzerinde çalışılmaya devam edildi.

# 2024-06-18 Geliştirme Günlüğü

- Eşleşme Fonksiyonu (`LikeOrPassAsync`) ve Temel Döngüsü Uygulandı:
  - `UserSwipe` modeli oluşturuldu.
  - `AppDbContext`'e `DbSet<UserSwipe>` eklendi ve ilişkiler yapılandırıldı.
  - `IUserSwipeRepository` ve `UserSwipeRepository` uygulandı.
  - `IUserSwipeRepository` bağımlılık enjeksiyonu için kaydedildi.
  - `MatchService.LikeOrPassAsync` metodu, girdi doğrulama, `UserSwipe` kaydı oluşturma, karşılıklı beğenileri kontrol ederek eşleşme onayı ve "pas geçme" eylemleri için uygulandı.
  - `appsettings.json` dosyasına `SwipeExclusionDurationDays` ayarı eklendi.

- Keşfetme Servisi Geliştirmeleri:
  - `IDiscoverService` arayüzü `GetDiscoveredUserIdsAsync` metodu için `maxDistanceKm` ve `preferredPetType` parametreleri içerecek şekilde güncellendi.
  - `DiscoverService.GetDiscoveredUserIdsAsync` metodu, yapılandırılabilir bir süre içinde zaten kaydırılmış kullanıcıları filtreleyecek şekilde güncellendi.

- Testler ve Hata Düzeltmeleri:
  - `MatchesController` ve `DiscoverService` için entegrasyon testleri oluşturuldu.
  - Test sınıflarında `IClassFixture` kullanımı düzeltildi (`CustomWebApplicationFactory<Program>` olarak).
  - Testler için `CustomWebApplicationFactory` içinde `ASPNETCORE_ENVIRONMENT` ortam değişkeni "Production" olarak ayarlandı.
  - `DiscoverServiceTests.cs` dosyasındaki `IDiscoverService` bulunamadı hatası giderildi.
  - `DiscoverServiceTests.cs` test izolasyonunu iyileştirmek için doğrudan in-memory veritabanına `UserSwipe` varlıkları eklendi.
  - `DiscoverService.GetDiscoveredUserIdsAsync` metodundan `.Take(5)` çağrısı kaldırıldı, böylece servis tüm keşfedilebilir kullanıcıları döndürdü.
  - Tüm testler başarıyla geçti.

- Frontend Ekibi İçin Dokümantasyon:
  - `app/backendTalimat.md` dosyası oluşturularak `POST /api/v1/matches` ve `GET /api/v1/matches/discover` API endpointleri detaylı bir şekilde belgelendi.

- Yapılacaklar Listesi Güncellemesi:
  - `api/matchandmessagesfeaturetodo.md` dosyasındaki ilgili görevler tamamlandı olarak işaretlendi.

# 2024-06-19 Geliştirme Günlüğü

- Gerçek Zamanlı İletişim (SignalR) Altyapısı (Backend) Uygulandı:
  - `PawMatch.Api` projesine `Microsoft.AspNetCore.SignalR` NuGet paketi eklendi.
  - `api/PawMatch.Api/Program.cs` dosyasında SignalR servisleri kaydedildi ve Hub endpoint'i (`/chatHub`) yapılandırıldı.
  - `api/PawMatch.Api/Hubs/ChatHub.cs` adında yeni bir SignalR Hub sınıfı oluşturuldu. Bu Hub, `OnConnectedAsync()` ve `OnDisconnectedAsync()` metotlarını içeriyor ve kullanıcı ID'lerini bağlantı ID'leriyle ilişkilendiriyor.

- Eşleşme Bildirimleri Entegrasyonu:
  - `MatchService.cs` içine `IHubContext<ChatHub>` bağımlılığı enjekte edildi.
  - `MatchService.cs` içindeki `LikeOrPassAsync` metodu, karşılıklı bir eşleşme olduğunda eşleşen her iki kullanıcıya da `ChatHub` üzerinden anlık bildirim (`ReceiveMatchNotification`) gönderecek şekilde güncellendi.

- Mesajlaşma Entegrasyonu:
  - `PawMatch.Domain/Message.cs` modeli oluşturuldu (Id, SenderId, RecipientId, Content, Timestamp, IsRead).
  - `api/PawMatch.Infrastructure/AppDbContext.cs` içine `DbSet<Message>` eklendi.
  - `api/PawMatch.Infrastructure/Interfaces/IMessageRepository.cs` arayüzü ve `api/PawMatch.Infrastructure/Repositories/MessageRepository.cs` uygulaması oluşturuldu.
  - `IMessageRepository` ve `IMessageService` bağımlılık enjeksiyonu için `api/PawMatch.Api/Program.cs`'e kaydedildi.
  - `api/PawMatch.Application/Interfaces/IMessageService.cs` arayüzü ve `api/PawMatch.Application/Services/MessageService.cs` uygulaması oluşturuldu. `MessageService` içine `IHubContext<ChatHub>` ve `IMessageRepository` enjekte edildi.
  - `MessageService.cs` içindeki `SendMessageAsync` metodu, mesaj veritabanına kaydedildikten sonra alıcıya SignalR üzerinden anlık mesaj (`ReceiveMessage`) gönderecek şekilde uygulandı.

- Kimlik Doğrulama ve Yetkilendirme (SignalR):
  - `api/PawMatch.Api/Hubs/ChatHub.cs` sınıfına `[Authorize]` niteliği eklendi, böylece Hub JWT tabanlı kimlik doğrulama ile güvence altına alındı.
  - Hub metotları içinde `Context.User.Identity.Name` veya `Context.UserIdentifier` ile kullanıcı ID'sine erişim sağlandı.

- Yapılacaklar Listesi Güncellemesi:
  - `docs/RealtimeConnectiontodo.md` dosyasındaki ilgili görevler tamamlandı olarak işaretlendi.

- Mimari İyileştirmeler ve Bağımlılık Giderme (Katmanlı Mimari):
  - `PawMatch.Application.Interfaces` içinde `IRealtimeNotificationService` adında yeni bir arayüz tanımlandı. Bu arayüz, gerçek zamanlı bildirim gönderme ihtiyacını soyutluyor.
  - `PawMatch.Api/Services` dizininde `SignalRNotificationService` adında bir sınıf oluşturuldu. Bu sınıf `IRealtimeNotificationService` arayüzünü implement ediyor ve `IHubContext<ChatHub>`'ı kullanarak SignalR'a özel çağrıları yönetiyor. Bu sayede SignalR bağımlılığı API katmanında kaldı.
  - `MatchService.cs` ve `MessageService.cs` servislerinin constructor'ları `IHubContext<ChatHub>` yerine yeni `IRealtimeNotificationService` arayüzünü enjekte edecek şekilde değiştirildi. İlgili metodlarda da bu yeni arayüz kullanılarak bildirim gönderme işlemleri gerçekleştirildi.
  - `Program.cs`'te `IRealtimeNotificationService`'in `SignalRNotificationService` implementasyonuyla birlikte bağımlılık enjeksiyonu için kaydedildi.
  - Uygulama servislerinden gereksiz `Microsoft.AspNetCore.SignalR` `using` ifadeleri kaldırıldı.

- Mesajlaşma Servisi (MessageService) Hata Yönetimi ve Testler:
  - Artık geçersiz alıcıya veya gönderen kullanıcıya mesaj gönderilmek istendiğinde `MessageService.SendMessageAsync` metodu exception (ArgumentException) fırlatıyor.
  - Bu davranış için birim ve entegrasyon testleri yazıldı; geçersiz alıcı veya gönderen durumunda hata fırlatıldığı doğrulandı.
  - Tüm testler context7 SignalR best practice'lerine uygun şekilde başarıyla geçti.
  - Frontend dokümantasyonuna (app/backendTalimat.md) bu hata yönetimiyle ilgili notlar ve kullanıcıya uygun uyarı gösterilmesi gerektiği eklendi.

# 2024-06-20 Geliştirme Günlüğü

- IMatchRepository arayüzü ve MatchRepository implementasyonu eklendi. MatchService artık doğrudan DbContext yerine repository kullanıyor.
- Program.cs'de IMatchRepository için DI kaydı yapıldı.
- Mesajlaşma ve eşleşme endpointleri için repository altyapısı tamamlandı.
</file>

<file path="Dockerfile">
# Build aşaması
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY . .
RUN dotnet restore
RUN dotnet publish PawMatch.Api/PawMatch.Api.csproj -c Release -o /app/publish

# Runtime aşaması
FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY --from=build /app/publish .
COPY wait-for-it.sh /wait-for-it.sh
RUN chmod +x /wait-for-it.sh
# ENTRYPOINT satırını kaldırıyorum, komut docker-compose'dan alınacak.
</file>

<file path="ef_core_migration_guide.md">
## 📦 Entity Framework Core Migration Kullanım Kılavuzu

Bu döküman, **EF Core Code First** yaklaşımıyla veri tabanı migration'larının nasıl oluşturulup uygulandığını adım adım açıklar.

> 💡 **Not:** Aşağıdaki komutlar çalıştırılırken terminalde `C:\Projects\Business\PawMatch\api` klasöründe (ana projenin bulunduğu dizin) olunması gerekir.

---

### 🧱 Migration Oluşturmak

```bash
 dotnet ef migrations add <MIGRATION_ADI> --project PawMatch.Infrastructure --startup-project PawMatch.Api
```

#### Parametreler:

- `<MIGRATION_ADI>`: Migration'a verilecek isim.
  - Örnek: `InitialCreate`, `AddedPetEntity`, `UpdateUserEmail`

#### Sabit Parametreler:

- `--project PawMatch.Infrastructure`: `DbContext` ve entity'lerin bulunduğu proje katmanı.
- `--startup-project PawMatch.Api`: `Program.cs` ve `appsettings.json` gibi dosyaların bulunduğu başlangıç projesi.

#### Örnek:

```bash
dotnet ef migrations add InitialCreate --project PawMatch.Infrastructure --startup-project PawMatch.Api
```

> ⚠️ Bu komutu çalıştırmadan önce projelerin derlenebilir durumda olduğundan emin olun.

---

### 🏗️ Veritabanını Güncellemek

```bash
dotnet ef database update --project PawMatch.Infrastructure --startup-project PawMatch.Api
```

#### Sabit Parametreler:

- `--project PawMatch.Infrastructure`
- `--startup-project PawMatch.Api`

#### Açıklama:

Bu komut, mevcut en son migration'ı kullanarak veritabanını günceller.

#### Örnek:

```bash
dotnet ef database update --project PawMatch.Infrastructure --startup-project PawMatch.Api
```

> Bu işlem sonucunda veritabanında gerekli tablolar oluşturulur veya güncellenir.

---

### 🔁 Yeni Migration Eklemek

Yeni bir model eklendikten veya mevcut modellerde değişiklik yapıldıktan sonra tekrar migration oluşturmak gerekir:

```bash
dotnet ef migrations add <YENI_MIGRATION_ADI> --project PawMatch.Infrastructure --startup-project PawMatch.Api
```

#### Örnek:

```bash
dotnet ef migrations add AddedPetEntity --project PawMatch.Infrastructure --startup-project PawMatch.Api
```

> Migration adı, yapılan değişikliği tanımlayacak şekilde verilmelidir. Örnekler: `RenamedUserField`, `RemovedOldTable`, `AddProfilePictureToUser`

---

### ✅ Notlar

- EF Core CLI aracının kurulu olduğundan emin olun:

```bash
dotnet tool install --global dotnet-ef
```

- Projenizde `Microsoft.EntityFrameworkCore.Design` paketi kurulu olmalıdır:

```bash
dotnet add package Microsoft.EntityFrameworkCore.Design
```

- Tüm komutlar, proje kök dizininden (solution ".sln" dosyasının bulunduğu yer, bu durumda `C:\Projects\Business\PawMatch\api`) çalıştırılmalıdır.
</file>

<file path="matchandmessagesfeaturedoc.md">
# PawMatch Eşleşme ve Mesajlaşma Özelliği Planlama Dokümantasyonu

Bu doküman, PawMatch uygulamasında eşleşme mekanizmasının geliştirilmesi ve uçtan uca mesajlaşma altyapısının planlanması için ayrıntılı bilgileri içerir. Bu aşamada sadece planlama yapılmakta, kod yazımı henüz başlamamıştır.

## 1. Özellik: `MatchService.cs` - `LikeOrPassAsync` Geliştirmesi

Bu özellik, kullanıcıların birbirlerini beğenmesi veya geçmesi durumunda gerçekleşecek eşleşme mantığını tanımlayacaktır.

**Mevcut Durum:**
`MatchActionDto` (User1Id, User2Id, Liked) girdisi alıyor ve `MatchResultDto` (MatchId, Confirmed) döndürüyor. Mevcut implementasyon bir yer tutucudur (`TODO`).

**Planlama:**

1.  **Girdi Doğrulama**: `MatchActionDto` içindeki `User1Id`'nin, isteği yapan kimliği doğrulanmış kullanıcının ID'si olduğundan emin olunmalıdır. Yetkisiz bir ID gelirse hata fırlatılmalıdır.
2.  **Kullanıcı Kaydını Tutma (Swipe Geçmişi)**:
    *   Kullanıcıların birbiri üzerindeki beğenme/geçme eylemlerini kaydetmek için yeni bir veri modeli/tablosu (`UserSwipe`) gereklidir. Bu, hem geçmişi tutacak hem de tekrar karşılaşma engellemesini sağlayacaktır.
    *   Eğer `MatchActionDto.Liked` `true` ise (beğenme eylemi), bu eylem `UserSwipe` tablosuna kaydedilir.
    *   Eğer `MatchActionDto.Liked` `false` ise (geçme eylemi), bu da `UserSwipe` tablosuna kaydedilir.
3.  **Eşleşme Kontrolü**:
    *   Mevcut kullanıcı (User1), hedef kullanıcıyı (User2) beğendiyse (`Liked = true`):
        *   Veritabanında User2'nin de User1'i daha önce beğenip beğenmediği (`UserSwipe` tablosunda `SwiperId = User2Id` ve `SwipedUserId = User1Id` ve `IsLiked = true` olan bir kayıt var mı) kontrol edilir.
        *   Eğer karşılıklı bir beğeni varsa, yani bir "eşleşme" gerçekleştiyse:
            *   `Match` tablosunda bu iki kullanıcı arasında yeni bir eşleşme kaydı oluşturulur veya mevcut eşleşme (`Confirmed = false` ise) `Confirmed = true` olarak güncellenir.
            *   Yanıt olarak `MatchResultDto` içinde `Confirmed = true` ve ilgili `MatchId` döndürülür.
        *   Eğer karşılıklı beğeni yoksa, sadece beğenme eylemi kaydedilir ve `MatchResultDto` içinde `Confirmed = false` döndürülür.
    *   Eğer mevcut kullanıcı (User1) hedef kullanıcıyı (User2) geçtiyse (`Liked = false`):
        *   Sadece geçme eylemi kaydedilir. Bir eşleşme gerçekleşmez.
        *   Eğer bu iki kullanıcı arasında daha önce onaylanmış bir eşleşme varsa, bu eşleşmenin durumu `Confirmed = false` olarak güncellenmeli veya silinmelidir (genellikle durum güncellemek geçmişi korumak adına tercih edilir).
        *   Yanıt olarak `MatchResultDto` içinde `Confirmed = false` döndürülür.
4.  **Veritabanı İşlemleri**: `UserSwipe` kayıtları ve `Match` tablosu güncellemeleri transaction içerisinde yapılmalıdır.
5.  **Yanıt**: İşlem sonucuna göre `MatchResultDto` döndürülür.

## 2. Özellik: Kullanıcının Beğendiği veya Geçtiği Kullanıcıların Veritabanında Tutulması ve Tekrar Karşılaşma Engellemesi

Bu özellik, keşif algoritmasının iyileştirilmesi ve kullanıcılara daha önce etkileşimde bulundukları profillerin tekrar gösterilmemesini sağlayacaktır.

**Planlama (Altyapı):**

1.  **Yeni Veri Modeli (`UserSwipe`)**:
    *   **Konum**: `PawMatch.Domain/UserSwipe.cs`
    *   **Özellikler**:
        *   `Id` (int): Birincil anahtar.
        *   `SwiperId` (int): Swipe eylemini yapan kullanıcının ID'si (Foreign Key: `User`).
        *   `SwipedUserId` (int): Swipe eylemine maruz kalan kullanıcının ID'si (Foreign Key: `User`).
        *   `IsLiked` (bool): `true` ise beğenme, `false` ise geçme.
        *   `SwipeDate` (DateTimeOffset / DateTime UTC): Swipe eyleminin gerçekleştiği zaman damgası.
    *   **İlişkiler**: `User` modeli ile iki adet bire-çok ilişki (Swiper ve SwipedUser).
2.  **`AppDbContext` Güncellemesi**: `AppDbContext.cs` dosyasına `DbSet<UserSwipe> UserSwipes { get; set; }` eklenecektir.
3.  **Veritabanı Migrasyonu**: `UserSwipe` tablosunu veritabanına eklemek için yeni bir Entity Framework Core migrasyonu oluşturulacaktır.
4.  **`IUserSwipeRepository` (Opsiyonel ama Önerilir)**: `UserSwipe` işlemleri için (`AddAsync`, `GetBySwiperAndSwipedUserAsync`, `GetRecentSwipesAsync` vb.) bir `IUserSwipeRepository` arayüzü ve `UserRepository.cs` gibi somut bir implementasyon (`UserSwipeRepository.cs`) oluşturulması, veri erişim mantığını daha düzenli hale getirir.
5.  **`DiscoverService` Geliştirmesi**:
    *   `DiscoverService.DiscoverUsersAsync` (tekil keşif metodu) güncellenecektir.
    *   Bu metod, `currentUserId`'nin belirli bir süre (`configurableDuration` gibi bir ayardan okunabilir) içinde zaten beğenmiş veya geçmiş olduğu kullanıcıları (`UserSwipe` tablosundan) sorgulayarak hariç tutmalıdır.
    *   **Süre Ayarı**: Bu "değişken süre" (`configurableDuration`), `appsettings.json` gibi bir yapılandırma dosyasında tutulmalıdır (örn. `SwipeExclusionDurationDays: 30`).
    *   **Konum Tabanlı Filtreleme**: `PawMatch Backend Guidelines.markdown`'da belirtilen PostGIS tabanlı konum filtreleme (`maxDistanceKm` parametresi) `DiscoverService` içinde uygulanmalıdır.
    *   **Pet Türü Filtreleme**: Yönergelerde belirtilen pet türü filtrelemesi de keşif algoritmasına dahil edilmelidir.

## 3. Özellik: Uçtan Uca Mesaj Şifreleme (Altyapı Planlaması)

Bu, mesajlaşma özelliğinin gelecekteki güvenliğini sağlamaya yönelik önemli bir adımdır. Backend, şifrelenmemiş mesaj içeriğine asla erişemez.

**Planlama (Altyapı):**

1.  **Anahtar Yönetimi**:
    *   **Herkese Açık/Özel Anahtar Çiftleri (Public/Private Key Pairs)**: Her kullanıcı için bir asimetrik anahtar çifti (örneğin RSA veya Eliptik Eğri Kriptografisi) gereklidir.
    *   **Özel Anahtar Depolama**: Kullanıcının özel anahtarları **ASLA sunucuda saklanmayacaktır**. Bunlar istemci tarafında (mobil uygulama) oluşturulmalı ve kullanıcının cihazında güvenli bir şekilde (örneğin mobil cihazın güvenli bölgesi, anahtar zinciri veya güçlü bir parola türetme mekanizmasıyla) saklanmalıdır.
    *   **Herkese Açık Anahtar Depolama**: Kullanıcının herkese açık anahtarları sunucuda saklanacaktır (örneğin `User` tablosunda yeni bir sütun veya ayrı bir `UserPublicKey` tablosunda). Bu anahtarlar, diğer kullanıcıların mesajları şifrelemesi için kullanılacaktır.
2.  **Şifreleme Süreci (Kavramsal)**:
    *   **İstemci Tarafında Şifreleme**: Mesaj içeriği, sunucuya gönderilmeden önce gönderen istemci tarafında şifrelenmelidir.
    *   **Symmetric Oturum Anahtarı (Session Key)**: Her bir mesajlaşma oturumu (veya her mesaj için), daha küçük ve hızlı bir simetrik anahtar (örneğin AES-256) oluşturulacaktır. Mesajın kendisi bu simetrik anahtar ile şifrelenecektir.
    *   **Asimetrik Anahtar Değişimi**: Bu simetrik oturum anahtarı, alıcının **herkese açık anahtarı** kullanılarak şifrelenecektir. Böylece, mesajla birlikte gönderilen şifrelenmiş oturum anahtarı, yalnızca alıcının **özel anahtarı** ile çözülebilir.
    *   **Mesaj Yapısı**: Mesajlar, şifrelenmiş içerik, şifrelenmiş oturum anahtarı ve mesajın çözülmesinde kullanılacak ek şifreleme parametrelerini (IV, nonce vb.) içerecektir.
3.  **Sunucunun Rolü**:
    *   Sunucu, şifrelenmemiş mesaj içeriğine **hiçbir zaman** erişemeyecektir.
    *   Şifrelenmiş mesajları ve ilgili anahtar paketlerini veritabanında saklayacaktır.
    *   Kullanıcıların herkese açık anahtarlarını yönetmekten ve eşleşen kullanıcılara dağıtmaktan sorumlu olacaktır.
    *   Mesajların meta verilerini (kimden, kime, zaman damgası, eşleşme ID'si) yönetecektir.
4.  **Veritabanı Değişiklikleri**:
    *   `User` Modeli: Herkese açık anahtar için `PublicKey` (string veya byte dizisi) gibi bir alan eklenebilir.
    *   `Message` Modeli: `Content` alanı artık şifrelenmiş veriyi (Base64 kodlanmış string veya byte dizisi) saklayacaktır.
    *   Mesajın şifrelenmiş simetrik oturum anahtarını ve diğer şifreleme meta verilerini tutmak için yeni bir tablo (`MessageKeyBundle` gibi) gerekebilir. Bu tablo, belirli bir mesaj veya sohbetle ilişkilendirilecektir.
5.  **API Değişiklikleri (Kavramsal)**:
    *   Kullanıcıların herkese açık anahtarlarını yüklemesi ve alması için yeni endpoint'ler gerekebilir.
    *   Mevcut `POST /api/v1/messages` endpoint'i, artık şifrelenmiş mesaj içeriğini ve şifrelenmiş oturum anahtarını kabul edecek şekilde güncellenmelidir.
    *   Mevcut `GET /api/v1/messages/{matchId}` endpoint'i, şifrelenmiş mesajları ve istemci tarafında çözümleme için gerekli anahtar paketlerini döndürmelidir.
6.  **İstemci Tarafı Gereksinimleri**: Flutter mobil uygulaması tarafında, anahtar çifti oluşturma, mesaj şifreleme/şifre çözme ve güvenli anahtar yönetimi için güçlü kriptografik kütüphanelerin entegrasyonu gerekecektir.

## 4. Eksik ve İleriye Yönelik İyileştirmeler

1.  **Eşleşme ve Swipe Mekanizması İçin Daha Detaylı Durum Yönetimi**:
    *   `LikeOrPassAsync` içinde, bir kullanıcı bir diğerini beğendiğinde ve henüz karşılıklı beğeni yoksa, bu beğeni durumunun veritabanında "beklemede" (`pending`) bir eşleşme olarak işaretlenmesi ve karşıdaki kullanıcı beğendiğinde bu eşleşmenin "onaylanması" (`confirmed`) mekanizması daha açıkça belirtilebilir. Mevcut plan `Match` tablosunda `Confirmed` alanı üzerinden bunu yönetiyor, ancak akışın netleştirilmesi faydalı olabilir.
    *   Bir kullanıcı birini "geçtiğinde" (`pass`), bu bilginin sadece keşif listesinde tekrar görünmemesi için değil, aynı zamanda ileride kullanıcı fikrini değiştirirse bu eylemi geri alma gibi senaryolar için de düşünülmesi. (Bu belki daha sonraki bir aşama ama altyapıda esneklik sağlar).

2.  **Mesajlaşma (Uçtan Uca Şifreleme) - İleriye Dönük Güvenlik Odaklı Eksikler**:
    *   **Mükemmel İleri Gizlilik (Perfect Forward Secrecy - PFS)**: Mevcut plan simetrik oturum anahtarları ve asimetrik anahtar değişimi içeriyor, bu da bir PFS formuna işaret ediyor. Ancak bu terimin açıkça belirtilmesi, iletişimin uzun vadeli güvenliğini vurgular. Bu, tek bir uzun ömürlü anahtarın tehlikeye atılmasının geçmiş konuşmaları tehlikeye atmamasını sağlar. Genellikle, her yeni oturum veya mesaj için efemeral anahtarların kullanılmasıyla sağlanır.
    *   **Kimlik Doğrulama/Anahtar Doğrulama (Key Verification)**: Herkese açık anahtarların değişimi planlanmış olsa da, kullanıcıların bu herkese açık anahtarların gerçekten bekledikleri kişiye ait olduğunu nasıl doğrulayacakları (yani "anahtar doğrulama") konusu önemlidir. Bu, genellikle istemci tarafı bir zorluktur (örn. QR kodları, anahtar parmak izleri), ancak backend'in güvenilir anahtar dağıtımında bir rolü vardır. Bu planlama aşamasında doğrudan backend implementasyonu olmasa da, mimari düşünceler içinde belirtilmesi gereken bir güvenlik özelliğidir.
    *   **İletişim Güvenliği Protokolleri**: Plan, anahtar yönetimi ve şifreleme sürecinin kavramsal bir tanımını veriyor. İleride Signal Protocol gibi kurulmuş ve denetlenmiş bir uçtan uca şifreleme protokolünün detaylarının araştırılması ve implementasyonunun düşünülmesi gerekebilir.

3.  **Performans ve Ölçeklenebilirlik İçin Ek Düşünceler (Genel)**:
    *   **Ön Bellekleme (Caching)**: Özellikle `DiscoverService` gibi sık çağrılan ve yoğun hesaplama gerektirebilecek servisler için ön bellekleme stratejileri (örneğin Redis ile) düşünülebilir. Beğenme/geçme geçmişi büyüdükçe, bu sorguların performansı etkileyebilir.
    *   **Gerçek Zamanlı İletişim (SignalR)**: Anlık mesajlaşma ve bildirim deneyimi için **SignalR** kullanılacaktır. Bu, mesajların veritabanına kaydedildikten sonra eşleşen kullanıcının bağlı istemcilerine anlık olarak iletilmesini sağlayacaktır.

4.  **Hata Yönetimi ve Gözlemlenebilirlik (Genel İyileştirme)**:
    *   **Detaylı Hata Kodları/Mesajları**: API yanıtlarında kullanılan `status: "error"` ve `error: "mesaj"` formatı geneldir. Daha spesifik, istemci tarafının anlayabileceği ve işleyebileceği hata kodları ve daha açıklayıcı hata mesajları sağlamak, hata ayıklama ve entegrasyonu kolaylaştırır.
    *   **Kapsamlı Loglama**: Yeni özellikler implemente edilirken, özellikle eşleşme akışı ve şifreleme işlemleri için detaylı loglama (hata, uyarı, bilgi seviyeleri) eklenmesi, sorun giderme ve izleme için kritik öneme sahiptir.

### 5.5.1. Gerçek Zamanlı İletişim (SignalR)
- **Amaç**: Anlık mesajlaşma ve eşleşme bildirimleri için gerçek zamanlı iletişim sağlamak.
- **Teknoloji**: ASP.NET Core SignalR, `IRealtimeNotificationService` aracılığıyla soyutlanmış.
- **Hub Yapılandırması**: 
  - `Program.cs`'te SignalR servisleri eklenmeli (`builder.Services.AddSignalR()`).
  - Bir SignalR Hub (`ChatHub.cs` gibi) oluşturulmalı. Bu Hub, istemcilerin çağırabileceği ve sunucunun istemcilere gönderebileceği metotları içerecek (örn. `SendMessage`, `ReceiveMessage`, `NotifyMatchFound`).
  - Hub, belirli bir URL üzerinde yapılandırılmalı (örn. `app.MapHub<ChatHub>("/chatHub");`).
- **Servis Katmanı Entegrasyonu (`IRealtimeNotificationService`)**:
  - `PawMatch.Application.Interfaces` içinde `IRealtimeNotificationService` adında bir arayüz tanımlanır. Bu arayüz, gerçek zamanlı bildirim gönderme ihtiyacını soyutlar.
  - `api/PawMatch.Api/Services/SignalRNotificationService.cs` adında bir sınıf oluşturularak `IRealtimeNotificationService` arayüzü implemente edilir. Bu sınıf, `IHubContext<ChatHub>`'ı kullanarak gerçek SignalR çağrılarını yapar.
  - `MatchService.cs` ve `MessageService.cs` gibi uygulama katmanındaki servisler, doğrudan `IHubContext<ChatHub>` yerine `IRealtimeNotificationService` bağımlılığını enjekte eder ve kullanır. Bu, uygulama katmanının SignalR'a olan doğrudan bağımlılığını kaldırarak daha temiz bir mimari sağlar.
- **Mesajlaşma Akışı**: 
  - Kullanıcı bir mesaj gönderdiğinde (`POST /api/v1/messages`), `MessageService` mesajı veritabanına kaydeder.
  - Kayıt başarılı olduktan sonra, `MessageService`, `IRealtimeNotificationService`'ı kullanarak mesajı eşleşen kullanıcının bağlı SignalR istemcilerine anlık olarak iletir.
- **Eşleşme Bildirimi Akışı**: 
  - `MatchService` içinde yeni bir eşleşme onaylandığında, `IRealtimeNotificationService`'ı kullanarak ilgili kullanıcılara anlık bildirim (`NotifyMatchFound` gibi bir metod ile) gönderilir.
- **Kimlik Doğrulama**: SignalR bağlantıları, mevcut JWT kimlik doğrulama mekanizması ile güvence altına alınacaktır. İstemciler, SignalR bağlantısı kurulurken JWT token'larını sağlayacaklardır.
- **Ölçeklenebilirlik**: Yüksek trafik durumlarında birden fazla sunucuya ölçeklenmek için SignalR backplane'leri (örn. Redis, Azure SignalR Service) kullanılabilir.

## 5.5.1. Gerçek Zamanlı İletişim (SignalR) - Testler ve Entegrasyon Notu
- SignalR backend testlerinde, SignalR Hub bağlantısı kurarken JWT authentication zorunludur. Testlerde önce bir kullanıcı register/login edilip JWT token alınmalı, ardından SignalR HubConnection oluşturulurken `options.AccessTokenProvider = () => Task.FromResult(token);` ile bu token kullanılmalıdır.
- Bu yöntem, hem .NET hem de context7 SignalR dokümantasyonundaki best practice'lere uygundur.
- SignalR testleri bu şekilde güncellendi ve tüm testler başarıyla geçti.

## 4. Kullanıcı Response Refaktörü ve DTO Ayrımı

- Tüm kullanıcı response'ları UserPublicDto (public) ve UserPrivateDto (private) ile dönmektedir.
- Hassas bilgiler (email, passwordHash) sadece UserPrivateDto'da bulunur ve sadece login/register/profile response'larında yer alır.
- Keşif, eşleşme ve genel kullanıcı listelerinde sadece UserPublicDto ile public alanlar yer alır.
- Hiçbir endpoint doğrudan domain User veya eski UserDto ile veri döndürmez.
- Mapping işlemleri merkezi UserPublicDtoMapper ve UserPrivateDtoMapper ile yapılır.

### Response Örnekleri

#### 1. Public (Keşif/Eşleşme)
```json
{
  "user": {
    "id": 2,
    "name": "Ali",
    "bio": "Kuşsever",
    "hasPet": false,
    "hasProfile": true,
    "photoIds": ["fileid3"],
    "age": null,
    "gender": null
  }
}
```
#### 2. Private (Login/Register/Profile)
```json
{
  "userPrivate": {
    "id": 1,
    "name": "Berkan",
    "email": "berkan@example.com",
    "bio": "Kedisever",
    "hasPet": true,
    "hasProfile": true,
    "photoIds": ["fileid1", "fileid2"],
    "age": null,
    "gender": null,
    "passwordHash": "..."
  }
}
```

## Repository Pattern ve Katmanlı Mimari Güncellemesi
- Eşleşme işlemleri için IMatchRepository arayüzü ve MatchRepository implementasyonu eklendi.
- MatchService, eşleşme işlemlerinde doğrudan DbContext yerine MatchRepository kullanıyor.
- Program.cs'de IMatchRepository için DI kaydı yapıldı.
- Mesajlaşma ve eşleşme endpointleri için repository altyapısı tamamlandı.
</file>

<file path="matchandmessagesfeaturetodo.md">
# PawMatch Eşleşme ve Mesajlaşma Özelliği - Yapılacaklar Listesi

Bu belge, PawMatch uygulamasında eşleşme ve mesajlaşma özelliklerinin implementasyon adımlarını, belirlenen iş akışına göre sıralı bir şekilde listeler. Her ana görevin ardından, ilgili test yazma ve çalıştırma adımları belirtilmiştir.

## 1. Match Fonksiyonu Core Loop Çalışacak (`LikeOrPassAsync` Implementasyonu)

### Görevler:

*   **Veri Modeli ve Veritabanı:**
    *   [x] `PawMatch.Domain/UserSwipe.cs` modelini oluştur. (Id, SwiperId, SwipedUserId, IsLiked, SwipeDate)
    *   [x] `AppDbContext.cs` içine `DbSet<UserSwipe> UserSwipes { get; set; }` ekle.
    *   [x] Yeni `UserSwipe` tablosu için Entity Framework Core migrasyonu oluştur.
    *   [x] `IUserSwipeRepository.cs` arayüzünü oluştur. (AddAsync, GetBySwiperAndSwipedUserAsync gibi metodlar)
    *   [x] `UserSwipeRepository.cs` implementasyonunu oluştur.
    *   [x] `Program.cs`'te `IUserSwipeRepository`'yi Dependency Injection'a ekle.

*   **`MatchService.cs` Geliştirmesi:**
    *   [x] `MatchService` içine `IUserSwipeRepository` bağımlılığını enjekte et.
    *   [x] `LikeOrPassAsync` metodunu güncelle:
        *   [x] Girdi doğrulamasını yap (istek yapan kullanıcının ID'si ile `User1Id`'nin eşleştiğini kontrol et).
        *   [x] `UserSwipe` kaydını oluştur ve kaydet (`SwiperId`, `SwipedUserId`, `IsLiked`, `SwipeDate`).
        *   [x] `IsLiked = true` ise, karşılıklı beğeni olup olmadığını kontrol et (`UserSwipe` tablosunda).
        *   [x] Eğer karşılıklı beğeni varsa:
            *   [x] `Match` tablosunda yeni bir eşleşme oluştur veya mevcut `Confirmed = false` eşleşmeyi `Confirmed = true` olarak güncelle.
            *   [x] `MatchResultDto` içinde `Confirmed = true` ve `MatchId` döndür.
        *   [x] Eğer karşılıklı beğeni yoksa, `MatchResultDto` içinde `Confirmed = false` döndür.
        *   [x] `IsLiked = false` ise, sadece `UserSwipe` kaydını oluştur.
        *   [x] Eğer daha önce onaylanmış bir eşleşme varsa, bu eşleşmenin durumu `Confirmed = false` olarak güncellenmeli veya silinmelidir (genellikle durum güncellemek geçmişi korumak adına tercih edilir).
        *   [x] `MatchResultDto` içinde `Confirmed = false` döndür.
    *   [x] Veritabanı işlemlerini transaction içerisinde yap.

*   **`DiscoverService.cs` Geliştirmesi (Tekrar Karşılaşma Engellemesi):**
    *   [x] `DiscoverService` içine `IUserSwipeRepository` bağımlılığını enjekte et.
    *   [x] `DiscoverUsersAsync` metodunu güncelle:
        *   [x] `currentUserId`'nin belirli bir süre içinde (örn. 30 gün) zaten beğenmiş veya geçmiş olduğu kullanıcıları `UserSwipe` tablosundan sorgulayarak hariç tut. Bu süre `appsettings.json`'dan okunacak.
        *   [ ] Konum tabanlı filtrelemeyi (`maxDistanceKm`) ve pet türü filtrelemesini gerçek algoritma ile uygula.

*   **Yapılandırma:**
    *   [x] `appsettings.json` içine `SwipeExclusionDurationDays` ayarını ekle (örn. `30`).

*   **Repository Katmanı:**
    *   [x] IMatchRepository arayüzünü oluştur.
    *   [x] MatchRepository implementasyonunu oluştur.
    *   [x] Program.cs'de IMatchRepository için DI kaydı yap.
    *   [x] MatchService, eşleşme işlemlerinde MatchRepository kullanacak şekilde güncellendi.

### Testler (Match Fonksiyonu):

*   [x] `PawMatch.Tests/MatchesControllerTests.cs` içinde `LikeOrPass` endpoint'i için test senaryoları yaz:
    *   [x] Başarılı beğenme ve karşılıklı eşleşme testi (hem beğeni hem de onaylanmış eşleşme).
    *   [x] Başarılı beğenme ancak eşleşme olmaması testi.
    *   [x] Başarılı geçme testi.
    *   [x] Geçersiz kullanıcı ID'leri ile deneme (yetkilendirme kontrolü).
*   [x] `PawMatch.Tests/DiscoverServiceTests.cs` (veya mevcut ilgili test dosyasına) keşif algoritmasının swiped kullanıcıları hariç tuttuğunu doğrulayan testler ekle.
*   [x] Yazılan testleri çalıştır ve doğrula.

## 2. Gerçek Zamanlı Mesajlaşma

### Görevler:

*   [X] Gerçek zamanlı mesajlaşma için teknoloji seçimi yap (SignalR seçildi).
*   [X] Backend tarafında SignalR Hub kur (SignalR Hub ve endpoint'i oluşturuldu, bağımlılık enjeksiyonu için `IRealtimeNotificationService` arayüzü ve `SignalRNotificationService` implementasyonu kullanıldı).
*   [X] `Message` modeli ve veritabanı yapısını gerçek zamanlı iletişim için optimize et (Message modeli, DbSet, IMessageRepository ve MessageRepository oluşturuldu).
*   [X] Mesajlaşma endpoint'lerini gerçek zamanlı iletişimi kullanacak şekilde güncelle (örn. `POST /api/v1/messages` için mesajı sadece veritabanına kaydetmek yerine, aynı zamanda `IRealtimeNotificationService` aracılığıyla eşleşen kullanıcının bağlı istemcisine anlık olarak gönder).

### Testler (Gerçek Zamanlı Mesajlaşma) - Güncelleme:
* [x] Gerçek zamanlı mesajlaşma için entegrasyon testleri yaz (örneğin, iki kullanıcının bağlanıp mesaj gönderip alabilmesi).
* [x] Yazılan testleri çalıştır ve doğrula.
* SignalR backend testlerinde, SignalR Hub bağlantısı kurarken JWT authentication zorunludur. Testlerde önce bir kullanıcı register/login edilip JWT token alınmalı, ardından SignalR HubConnection oluşturulurken `options.AccessTokenProvider = () => Task.FromResult(token);` ile bu token kullanılmalıdır.
* Bu yöntem, hem .NET hem de context7 SignalR dokümantasyonundaki best practice'lere uygundur.
* SignalR testleri bu şekilde güncellendi ve tüm testler başarıyla geçti.

## 3. Uçtan Uca Şifreleme

### Görevler:

*   **Veri Modeli Güncellemesi:**
    *   [ ] `PawMatch.Domain/User.cs` modeline `PublicKey` alanı ekle (string veya byte[]).
    *   [ ] `PawMatch.Domain/Message.cs` modelindeki `Content` alanını şifrelenmiş veri için ayarla (string/byte[]).
    *   [ ] `PawMatch.Domain/MessageKeyBundle.cs` gibi, mesajın şifrelenmiş simetrik oturum anahtarını ve diğer şifreleme meta verilerini tutacak yeni bir model oluştur (Opsiyonel: eğer her mesaj için ayrı bir oturum anahtarı yönetilecekse).
    *   [ ] `AppDbContext.cs` içine ilgili `DbSet`'leri ekle.
    *   [ ] Veritabanı migrasyonlarını oluştur.

*   **Backend Servisleri ve Endpoint'ler (Kavramsal ve Altyapı):**
    *   [ ] Kullanıcının herkese açık anahtarını yüklemesi için `UsersController`'a `POST /api/v1/users/publicKey` gibi bir endpoint ekle.
    *   [ ] Belirli bir kullanıcının herkese açık anahtarını alması için `UsersController`'a `GET /api/v1/users/{userId}/publicKey` gibi bir endpoint ekle.
    *   [ ] `MessageService`'i, gelen şifrelenmiş mesaj içeriğini ve şifrelenmiş oturum anahtarını işleyecek şekilde güncelle. İçeriği çözmeye çalışmayacak, sadece kaydedecek.
    *   [ ] `MessageService`'i, şifrelenmiş mesajları ve ilgili anahtar paketlerini istemciye döndürecek şekilde güncelle.
    *   [ ] Herkese açık anahtarları güvenli bir şekilde yönetmek ve dağıtmak için arka plan mekanizmalarını düşün.

### Testler (Uçtan Uca Şifreleme):

*   [ ] Şifrelenmiş mesajların doğru şekilde saklandığını ve alındığını doğrulayan entegrasyon testleri yaz (içeriği çözmeden, sadece verinin bütünlüğünü kontrol ederek).
*   [ ] Herkese açık anahtar yükleme ve indirme endpoint'leri için testler yaz.
*   [ ] Yazılan testleri çalıştır ve doğrula.

## 4. Pass Diyerek Geçtiklerimizi Bir Süre Sonra Tekrardan Kullanıcı Karşısına Çıkarma

### Görevler:

*   [x] `DiscoverService.cs` Geliştirmesi:
    *   [x] `DiscoverService` içindeki `DiscoverUsersAsync` (tekil keşif metodu) güncellenecektir.
    *   [x] Bu metot, `UserSwipe` tablosundaki `SwipeDate` alanını kullanarak, belirli bir "geçiş süresinden" (`SwipeReappearDurationDays` gibi `appsettings.json`'dan okunacak) daha eski olan `IsLiked = false` (geçme) kayıtlarını hariç tutmamalıdır. Böylece, kullanıcılar belirli bir süre sonra tekrar keşif listesinde görünebilir.
    *   [x] **Yapılandırma**: `appsettings.json` içine `SwipeReappearDurationDays` ayarını ekle (örn. `90` gün).

### Testler (Geçilenleri Tekrar Gösterme):

*   [x] `PawMatch.Tests/DiscoverServiceTests.cs` (veya ilgili test dosyasına) geçilen kullanıcıların belirli bir süre sonra tekrar keşif listesinde göründüğünü doğrulayan testler ekle.
*   [x] Yazılan testleri çalıştır ve doğrula.

## 5. Kullanıcı Response Refaktörü ve DTO Ayrımı

- Tüm kullanıcı response'ları UserPublicDto (public) ve UserPrivateDto (private) ile dönmektedir.
- Hassas bilgiler (email, passwordHash) sadece UserPrivateDto'da bulunur ve sadece login/register/profile response'larında yer alır.
- Keşif, eşleşme ve genel kullanıcı listelerinde sadece UserPublicDto ile public alanlar yer alır.
- Hiçbir endpoint doğrudan domain User veya eski UserDto ile veri döndürmez.
- Mapping işlemleri merkezi UserPublicDtoMapper ve UserPrivateDtoMapper ile yapılır.

### Response Örnekleri

#### 1. Public (Keşif/Eşleşme)
```json
{
  "user": {
    "id": 2,
    "name": "Ali",
    "bio": "Kuşsever",
    "hasPet": false,
    "hasProfile": true,
    "photoIds": ["fileid3"],
    "age": null,
    "gender": null
  }
}
```
#### 2. Private (Login/Register/Profile)
```json
{
  "userPrivate": {
    "id": 1,
    "name": "Berkan",
    "email": "berkan@example.com",
    "bio": "Kedisever",
    "hasPet": true,
    "hasProfile": true,
    "photoIds": ["fileid1", "fileid2"],
    "age": null,
    "gender": null,
    "passwordHash": "..."
  }
}
```
</file>

<file path="messagesystem.md">
# PawMatch Chat Sistemi: API ve SignalR Akışı

Aşağıda, PawMatch projesinde chat/messaging sisteminin hem REST API hem de SignalR ile nasıl birlikte çalıştığı şematik olarak gösterilmiştir.

---

```mermaid
sequenceDiagram
    participant FE as "Frontend (Flutter/Web)"
    participant API as "Backend API (REST)"
    participant HUB as "SignalR ChatHub"
    participant DB as "Database"

    Note over FE: Kullanıcı uygulamada chat ekranında

    FE->>API: GET /api/v1/messages/{matchId}\n(Mesaj geçmişini al)
    API->>DB: Mesajları getir (matchId)
    DB-->>API: Mesaj listesi (MessageDto[])
    API-->>FE: JSON mesaj listesi

    FE->>HUB: SignalR ile bağlan (connect)
    FE->>HUB: SendMessage(matchId, content)
    HUB->>DB: Yeni mesajı kaydet
    DB-->>HUB: Kayıt başarılı (Message)
    HUB-->>FE: ReceiveMessage (yeni mesajı anlık ilet)
    HUB-->>API: (Opsiyonel) Bildirim/Log/İstatistik
    Note over FE: FE, ReceiveMessage ile anlık mesajı gösterir

    Note over FE: Tipler ve DTO'lar\nHem API hem SignalR\nda MessageDto, MatchDto\ngibi ortak yapılar kullanılır
```

---

## Açıklama
- Kullanıcı chat ekranında ilk açılışta API'dan mesaj geçmişini çeker.
- SignalR ile bağlanır, yeni mesaj gönderir.
- SignalR üzerinden gelen mesajlar anlık olarak ekranda gösterilir.
- Hem API hem SignalR tarafında aynı DTO'lar (ör. MessageDto) kullanılır, tip tutarlılığı sağlanır.

---

**Not:**
- Bu yapı, modern chat uygulamalarında yaygın olarak kullanılır.
- API geçmiş ve offline mesajlar için, SignalR ise anlık iletişim için kullanılır.
- Tip karışıklığı olmaması için backend'de tüm id alanları int/int? olarak tanımlanmıştır.
</file>

<file path="PawMatch.Api/.gitignore">
# Build
bin/
obj/

# User Secrets or local settings (optional)
appsettings.Development.json
appsettings.Local.json
appsettings.*.local.json

# Swagger generated files (if any)
swagger.json
swagger-ui/

# Uploaded files (if handled locally)
wwwroot/uploads/
uploads/
</file>

<file path="PawMatch.Api/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5433;Database=pawmatch;Username=postgres;Password=mandaci12"
  },
  "AppSettings": {
    "SwipeExclusionDurationDays": 30,
    "SwipeReappearDurationDays": 90
  }
}
</file>

<file path="PawMatch.Api/Controllers/BaseController.cs">
using Microsoft.AspNetCore.Mvc;
using System.Linq;
using System.Security.Claims;
namespace PawMatch.Api.Controllers
{
    public abstract class BaseController : ControllerBase
    {
        /// <summary>
        /// JWT'den userId'yi çeken yardımcı fonksiyon (tüm controllerlarda kullanılabilir)
        /// </summary>
        protected int? GetUserIdFromClaims()
        {
            var userIdClaim = User.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
            if (!string.IsNullOrEmpty(userIdClaim) && int.TryParse(userIdClaim, out var userId))
                return userId;
            return null;
        }
    }
}
</file>

<file path="PawMatch.Api/Controllers/MatchesController.cs">
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using System.Collections.Generic;
using System.Security.Claims;
using System.Threading.Tasks;
namespace PawMatch.Api.Controllers
{
    [ApiController]
    [Route("api/v1/matches")]
    [Authorize]
    public class MatchesController : BaseController
    {
        private readonly IMatchService _matchService;
        private readonly IDiscoverService _discoverService;
        public MatchesController(IMatchService matchService, IDiscoverService discoverService)
        {
            _matchService = matchService;
            _discoverService = discoverService;
        }
        /// <summary>
        /// Kullanıcı/pet kartlarını listeler (discover).
        /// </summary>
        /// <param name="maxDistanceKm">Maksimum mesafe (opsiyonel)</param>
        /// <param name="offset">Sayfalama başlangıcı (opsiyonel)</param>
        /// <param name="limit">Sayfa boyutu (opsiyonel)</param>
        /// <param name="preferredPetType">Tercih edilen evcil hayvan türü (opsiyonel)</param>
        /// <returns>Kullanıcı ve pet kartları</returns>
        [HttpGet("discover")]
        public async Task<IActionResult> Discover([FromQuery] int? maxDistanceKm, [FromQuery] int? offset, [FromQuery] int? limit, [FromQuery] string? preferredPetType)
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "Kullanıcı kimliği doğrulanamadı." });
            var result = await _discoverService.DiscoverUsersAsync(userId.Value, maxDistanceKm, preferredPetType, offset, limit);
            return Ok(new { status = "success", data = result, error = (string)null });
        }
        /// <summary>
        /// Beğenme/geçme işlemi yapar.
        /// </summary>
        /// <param name="dto">Beğenme/geçme bilgisi</param>
        /// <returns>Eşleşme sonucu</returns>
        [HttpPost]
        public async Task<IActionResult> LikeOrPass([FromBody] MatchActionDto dto)
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "Kullanıcı kimliği doğrulanamadı." });
            try
            {
                var result = await _matchService.LikeOrPassAsync(userId.Value, dto);
                return Ok(new { status = "success", data = result, error = (string)null });
            }
            catch (UnauthorizedAccessException ex)
            {
                return Unauthorized(new { status = "error", error = ex.Message });
            }
        }
        [HttpGet]
        public async Task<IActionResult> GetMatches()
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "Kullanıcı kimliği doğrulanamadı." });
            var matches = await _matchService.GetMatchesForUserAsync(userId.Value);
            return Ok(new { data = new { matches }, status = "success" });
        }
    }
}
</file>

<file path="PawMatch.Api/Controllers/MessagesController.cs">
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using PawMatch.Domain;
namespace PawMatch.Api.Controllers
{
    [ApiController]
    [Route("api/v1/messages")]
    [Authorize]
    public class MessagesController : BaseController
    {
        private readonly IMessageService _messageService;
        private readonly IUserService _userService;
        private readonly IMatchService _matchService;
        public MessagesController(IMessageService messageService, IUserService userService, IMatchService matchService)
        {
            _messageService = messageService;
            _userService = userService;
            _matchService = matchService;
        }
        /// <summary>
        /// Belirli bir eşleşmeye ait mesajları listeler.
        /// </summary>
        /// <param name="matchId">Eşleşme ID</param>
        /// <param name="offset">Sayfalama başlangıcı (opsiyonel)</param>
        /// <param name="limit">Sayfa boyutu (opsiyonel, default 20)</param>
        /// <returns>Mesaj listesi</returns>
        [HttpGet("{matchId}")]
        public async Task<IActionResult> GetMessages(int matchId, [FromQuery] int offset = 0, [FromQuery] int limit = 20)
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "Kullanıcı kimliği doğrulanamadı." });
            // Kullanıcı bu eşleşmenin parçası mı kontrol et
            var match = await _matchService.GetMatchByIdAsync(matchId);
            if (match == null || (match.User1Id != userId && match.User2Id != userId))
                return Forbid();
            // Karşı tarafın userId'sini bul
            int otherUserId = (match.User1Id == userId) ? match.User2Id : match.User1Id;
            // Mesajları getir
            var messages = await _messageService.GetChatHistoryAsync(userId.Value, otherUserId);
            var senderIds = messages.Select(m => m.SenderId).Distinct().ToList();
            var senders = await _userService.GetUsersByIdsAsync(senderIds);
            var senderMap = senders.ToDictionary(
                u => u.Id,
                u => UserPublicDtoMapper.ToPublicDto(
                    u,
                    u.GetPhotoIds(),
                    u.GetPetIds()
                )
            );
            var messageDtos = messages.Skip(offset).Take(limit).Select(m => MessageDtoMapper.ToDto(m, senderMap[m.SenderId])).ToList();
            return Ok(new { data = messageDtos, status = "success" });
        }
        /// <summary>
        /// Mesaj gönderir.
        /// </summary>
        /// <param name="request">Mesaj gönderme isteği</param>
        /// <returns>Oluşturulan mesaj</returns>
        public class SendMessageRequest
        {
            public int MatchId { get; set; }
            public string Content { get; set; }
        }
        [HttpPost]
        public async Task<IActionResult> SendMessage([FromBody] SendMessageRequest request)
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "Kullanıcı kimliği doğrulanamadı." });
            // Kullanıcı bu eşleşmenin parçası mı kontrol et
            var match = await _matchService.GetMatchByIdAsync(request.MatchId);
            if (match == null || (match.User1Id != userId && match.User2Id != userId))
                return Forbid();
            int recipientId = (match.User1Id == userId) ? match.User2Id : match.User1Id;
            var message = await _messageService.SendMessageAsync(userId.Value, recipientId, request.Content);
            var sender = await _userService.GetUserByIdAsync(userId.Value);
            var senderDto = UserPublicDtoMapper.ToPublicDto(sender, sender.GetPhotoIds(),sender.GetPetIds());
            var messageDto = MessageDtoMapper.ToDto(message, senderDto);
            return Ok(new { data = messageDto, status = "success" });
        }
    }
}
</file>

<file path="PawMatch.Api/Controllers/PhotosController.cs">
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using System;
using System.IO;
using System.Threading.Tasks;
using System.Linq;
namespace PawMatch.Api.Controllers
{
    [ApiController]
    [Route("api/v1/photos")]
    [Authorize]
    public class PhotosController : BaseController
    {
        private readonly IPhotoService _photoService;
        public PhotosController(IPhotoService photoService)
        {
            _photoService = photoService;
        }
        public class UserPhotoUploadRequest
        {
            public IFormFile File { get; set; }
        }
        public class PetPhotoUploadRequest
        {
            public IFormFile File { get; set; }
        }
        [HttpGet("{id}")]
        public async Task<IActionResult> GetPhoto(int id)
        {
            try
            {
                var userId = GetUserIdFromClaims();
                if (userId == null)
                    return Unauthorized(new { status = "error", error = "Kullanıcı kimliği doğrulanamadı." });
                var photoStream = await _photoService.GetPhotoStreamAsync(id, userId.Value);
                // Content-Type ve Content-Disposition ayarla
                // (Tipi DB'den de çekebilirsin, burada örnek olarak image/jpeg)
                return File(photoStream, "image/jpeg", enableRangeProcessing: false);
            }
            catch (Exception ex)
            {
                return NotFound(new { status = "error", error = ex.Message });
            }
        }
        [HttpDelete("{id}")]
        public async Task<IActionResult> DeletePhoto(int id)
        {
            try
            {
                await _photoService.DeletePhotoAsync(id);
                return Ok(new { status = "success" });
            }
            catch (Exception ex)
            {
                return NotFound(new { status = "error", error = ex.Message });
            }
        }
        // Kullanıcıya fotoğraf yükleme
        [HttpPost("user")]
        public async Task<IActionResult> UploadUserPhoto([FromForm] UserPhotoUploadRequest request)
        {
            var file = request.File;
            if (file == null || (file.ContentType != "image/jpeg" && file.ContentType != "image/png"))
                return BadRequest(new { status = "error", error = "Sadece JPEG veya PNG dosya yüklenebilir." });
            if (file.Length > 5 * 1024 * 1024)
                return BadRequest(new { status = "error", error = "Dosya boyutu 5 MB'dan büyük olamaz." });
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "Kullanıcı kimliği doğrulanamadı." });
            using var stream = file.OpenReadStream();
            var result = await _photoService.UploadPhotoAsync(
                new PhotoUploadDto { UserId = userId.Value },
                stream,
                file.FileName,
                file.ContentType
            );
            return Ok(new ApiResponse<PhotoDto> { Data = result, Status = "success" });
        }
        // Pet'e fotoğraf yükleme
        [HttpPost("users/pets/{petId}/photos")]
        [Authorize]
        public async Task<IActionResult> UploadPetPhoto(int petId, [FromForm] PetPhotoUploadRequest request)
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "Kullanıcı kimliği doğrulanamadı." });
            // Dummy sahiplik kontrolü (gerçek uygulamada DB'den kontrol edilmeli)
            // if (!await _petService.UserOwnsPet(userId.Value, petId)) return Forbid();
            var file = request.File;
            if (file == null || (file.ContentType != "image/jpeg" && file.ContentType != "image/png"))
                return BadRequest(new { status = "error", error = "Sadece JPEG veya PNG dosya yüklenebilir." });
            if (file.Length > 5 * 1024 * 1024)
                return BadRequest(new { status = "error", error = "Dosya boyutu 5 MB'dan büyük olamaz." });
            using var stream = file.OpenReadStream();
            var result = await _photoService.UploadPhotoAsync(
                new PhotoUploadDto { PetId = petId },
                stream,
                file.FileName,
                file.ContentType
            );
            return Ok(new ApiResponse<PhotoDto> { Data = result, Status = "success" });
        }
    }
}
</file>

<file path="PawMatch.Api/Controllers/UsersController.cs">
using Microsoft.AspNetCore.Mvc;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using System;
using System.Threading.Tasks;
using System.Linq;
using Microsoft.AspNetCore.Authorization;
using System.Security.Claims;
using PawMatch.Domain;
namespace PawMatch.Api.Controllers
{
    [ApiController]
    [Route("api/v1/users")]
    public class UsersController : BaseController
    {
        private readonly IUserService _userService;
        public UsersController(IUserService userService)
        {
            _userService = userService;
        }
        /// <summary>
        /// Kullanıcı girişi yapar.
        /// </summary>
        /// <remarks>
        /// Başarılı yanıt örneği:
        /// 
        ///     POST /api/v1/users/login
        ///     {
        ///         "email": "kullanici@example.com",
        ///         "password": "şifre"
        ///     }
        /// 
        /// Yanıt:
        ///     {
        ///         "status": "success",
        ///         "data": {
        ///             "user": {
        ///                 "id": 1,
        ///                 "name": "Ali Veli",
        ///                 "email": "kullanici@example.com",
        ///                 "hasProfile": true
        ///             },
        ///             "token": "jwt-token-string"
        ///         },
        ///         "error": null
        ///     }
        /// </remarks>
        /// <param name="dto">Kullanıcı giriş bilgileri</param>
        /// <returns>Kullanıcı ve JWT token</returns>
        [HttpPost("login")]
        public async Task<IActionResult> Login([FromBody] UserLoginDto dto)
        {
            try
            {
                var result = await _userService.LoginAsync(dto);
                return Ok(new { data = result, status = "success", error = (string)null });
            }
            catch (UnauthorizedAccessException ex)
            {
                return Unauthorized(new { data = (object)null, status = "error", error = ex.Message });
            }
        }
        /// <summary>
        /// Kullanıcı profilini günceller.
        /// </summary>
        /// <remarks>
        ///     PATCH /api/v1/users/profile
        ///     {
        ///         "name": "Ali Veli",
        ///         "bio": "Kısa biyografi",
        ///         "hasPet": true
        ///     }
        /// 
        /// Yanıt:
        ///     {
        ///         "status": "success",
        ///         "data": {
        ///             "user": {
        ///                 "id": 1,
        ///                 "name": "Ali Veli",
        ///                 "email": "kullanici@example.com",
        ///                 "hasProfile": true
        ///             },
        ///             "token": "jwt-token-string"
        ///         },
        ///         "error": null
        ///     }
        /// </remarks>
        /// <param name="dto">Profil güncelleme bilgileri</param>
        /// <returns>Güncellenmiş kullanıcı ve JWT token</returns>
        [HttpPatch("profile")]
        [Authorize]
        public async Task<IActionResult> UpdateProfile([FromBody] UpdateProfileDto dto)
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "Kullanıcı kimliği doğrulanamadı." });
            var result = await _userService.UpdateProfileAsync(userId.Value, dto);
            return Ok(new { data = result, status = "success", error = (string)null });
        }
        /// <summary>
        /// Yeni kullanıcı kaydı oluşturur.
        /// </summary>
        /// <remarks>
        ///     POST /api/v1/users/register
        ///     {
        ///         "name": "Ali Veli",
        ///         "email": "kullanici@example.com",
        ///         "password": "sifre123"
        ///     }
        /// 
        /// Yanıt:
        ///     {
        ///         "status": "success",
        ///         "data": {
        ///             "user": {
        ///                 "id": 1,
        ///                 "name": "Ali Veli",
        ///                 "email": "kullanici@example.com",
        ///                 "hasProfile": false
        ///             },
        ///             "token": "jwt-token-string"
        ///         },
        ///         "error": null
        ///     }
        /// </remarks>
        /// <param name="dto">Kullanıcı kayıt bilgileri</param>
        /// <returns>Kayıtlı kullanıcı ve JWT token</returns>
        [HttpPost("register")]
        public async Task<IActionResult> Register([FromBody] UserRegisterDto dto)
        {
            var result = await _userService.RegisterAsync(dto);
            return Ok(new { data = result, status = "success", error = (string)null });
        }
        /// <summary>
        /// Kullanıcının kendi hesabını siler.
        /// </summary>
        /// <remarks>
        /// Sadece kimliği doğrulanmış kullanıcılar kendi hesaplarını silebilir.
        /// Yanıt:
        ///     {
        ///         "status": "success",
        ///         "data": null,
        ///         "error": null
        ///     }
        /// </remarks>
        /// <returns>Başarı veya hata mesajı</returns>
        [HttpDelete("me")]
        [Authorize]
        public async Task<IActionResult> DeleteMyAccount()
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "Kullanıcı kimliği doğrulanamadı." });
            try
            {
                await _userService.DeleteUserAsync(userId.Value);
                return Ok(new { status = "success", data = (object)null, error = (string)null });
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(new { status = "error", error = ex.Message });
            }
            catch (Exception ex)
            {
                // Log the exception (e.g., using a logger)
                return StatusCode(500, new { status = "error", error = "Hesap silinirken bir hata oluştu." });
            }
        }
        [HttpGet("me")]
        [Authorize]
        public async Task<IActionResult> GetMyProfile()
        {
            var userIdClaim = User.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier);
            if (userIdClaim == null || !int.TryParse(userIdClaim.Value, out var userId))
            {
                return Unauthorized(new ApiResponse<object> { Status = "Error", Error = "Invalid user ID in token." });
            }
            var user = await _userService.GetUserByIdAsync(userId);
            var userDto = UserPrivateDtoMapper.ToPrivateDto(user, user.GetPhotoIds(), user.GetPetIds());
            return Ok(new ApiResponse<UserPrivateDto> { Data = userDto, Status = "Success" });
        }
    }
}
</file>

<file path="PawMatch.Api/Controllers/WeatherForecastController.cs">
using Microsoft.AspNetCore.Mvc;
namespace PawMatch.Api.Controllers;
[ApiController]
[Route("[controller]")]
public class WeatherForecastController : BaseController
{
    private static readonly string[] Summaries = new[]
    {
        "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
    };
    private readonly ILogger<WeatherForecastController> _logger;
    public WeatherForecastController(ILogger<WeatherForecastController> logger)
    {
        _logger = logger;
    }
    [HttpGet(Name = "GetWeatherForecast")]
    public IEnumerable<WeatherForecast> Get()
    {
        return Enumerable.Range(1, 5).Select(index => new WeatherForecast
        {
            Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = Summaries[Random.Shared.Next(Summaries.Length)]
        })
        .ToArray();
    }
}
</file>

<file path="PawMatch.Api/Hubs/ChatHub.cs">
using Microsoft.AspNetCore.SignalR;
using System.Collections.Concurrent;
using System.Security.Claims;
using Microsoft.AspNetCore.Authorization;
using PawMatch.Application.Interfaces;
using PawMatch.Application.DTOs;
using PawMatch.Domain;
namespace PawMatch.Api.Hubs
{
    [Authorize]
    public class ChatHub : Hub
    {
        // Kullanıcı ID'lerini bağlantı ID'leriyle ilişkilendirmek için bir mekanizma
        private static readonly ConcurrentDictionary<string, string> _connectedUsers = new ConcurrentDictionary<string, string>();
        private readonly IMessageService _messageService;
        private readonly IUserService _userService;
        public ChatHub(IMessageService messageService, IUserService userService)
        {
            _messageService = messageService;
            _userService = userService;
        }
        public override async Task OnConnectedAsync()
        {
            var userId = Context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userId != null)
            {
                _connectedUsers.TryAdd(userId, Context.ConnectionId);
                await Groups.AddToGroupAsync(Context.ConnectionId, userId);
            }
            await base.OnConnectedAsync();
        }
        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            var userId = Context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userId != null)
            {
                _connectedUsers.TryRemove(userId, out _);
                await Groups.RemoveFromGroupAsync(Context.ConnectionId, userId);
            }
            await base.OnDisconnectedAsync(exception);
        }
        // SignalR ile doğrudan mesaj gönderme fonksiyonu
        public async Task SendMessageToUser(int recipientUserId, string content)
        {
            var senderIdStr = Context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (!int.TryParse(senderIdStr, out int senderId))
                throw new HubException("Kullanıcı kimliği doğrulanamadı.");
            if (senderId == recipientUserId)
                throw new HubException("Kendinize mesaj gönderemezsiniz.");
            // Kullanıcılar var mı kontrolü
            var sender = await _userService.GetUserByIdAsync(senderId);
            var recipient = await _userService.GetUserByIdAsync(recipientUserId);
            if (sender == null || recipient == null)
                throw new HubException("Kullanıcı(lar) bulunamadı.");
            // Mesajı kaydet
            var message = await _messageService.SendMessageAsync(senderId, recipientUserId, content);
            // DTO mapping
            var senderDto = UserPublicDtoMapper.ToPublicDto(sender, sender.GetPhotoIds(), sender.GetPetIds());
            var messageDto = MessageDtoMapper.ToDto(message, senderDto);
            // Hem gönderen hem alıcıya ilet
            await Clients.User(senderId.ToString()).SendAsync("ReceiveMessage", messageDto);
            await Clients.User(recipientUserId.ToString()).SendAsync("ReceiveMessage", messageDto);
        }
        // İleride mesaj gönderme ve alma metodları buraya eklenebilir.
        // Örneğin: public async Task SendMessageToUser(string recipientUserId, string message) { ... }
    }
}
</file>

<file path="PawMatch.Api/PawMatch.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.*" />
        <PackageReference Include="Microsoft.AspNetCore.SignalR" Version="1.2.0" />
        <PackageReference Include="Swashbuckle.AspNetCore" Version="6.*" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\PawMatch.Application\PawMatch.Application.csproj" />
      <ProjectReference Include="..\PawMatch.Domain\PawMatch.Domain.csproj" />
      <ProjectReference Include="..\PawMatch.Infrastructure\PawMatch.Infrastructure.csproj" />
    </ItemGroup>

</Project>
</file>

<file path="PawMatch.Api/PawMatch.Api.http">
@PawMatch.Api_HostAddress = http://localhost:5193

GET {{PawMatch.Api_HostAddress}}/weatherforecast/
Accept: application/json

###
</file>

<file path="PawMatch.Api/Properties/launchSettings.json">
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:44725",
      "sslPort": 44399
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "http://localhost:5193",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:7073;http://localhost:5193",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "Testing": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:6000;http://localhost:6001",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Testing"
      }
    }
  }
}
</file>

<file path="PawMatch.Api/Services/SignalRNotificationService.cs">
using System.Threading.Tasks;
using Microsoft.AspNetCore.SignalR;
using PawMatch.Application.Interfaces;
using PawMatch.Application.DTOs;
using PawMatch.Domain;
using PawMatch.Api.Hubs;
namespace PawMatch.Api.Services
{
    public class SignalRNotificationService : IRealtimeNotificationService
    {
        private readonly IHubContext<ChatHub> _hubContext;
        public SignalRNotificationService(IHubContext<ChatHub> hubContext)
        {
            _hubContext = hubContext;
        }
        public async Task SendMatchNotificationAsync(int user1Id, int user2Id, MatchResultDto matchResult)
        {
            await _hubContext.Clients.User(user1Id.ToString()).SendAsync("ReceiveMatchNotification", matchResult);
            await _hubContext.Clients.User(user2Id.ToString()).SendAsync("ReceiveMatchNotification", matchResult);
        }
        public async Task SendMessageAsync(int recipientId, Message message)
        {
            await _hubContext.Clients.User(recipientId.ToString()).SendAsync("ReceiveMessage", message);
        }
    }
}
</file>

<file path="PawMatch.Api/WeatherForecast.cs">
namespace PawMatch.Api;
public class WeatherForecast
{
    public DateOnly Date { get; set; }
    public int TemperatureC { get; set; }
    public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
    public string? Summary { get; set; }
}
</file>

<file path="PawMatch.Application/.gitignore">
# Build
bin/
obj/

# Any cached metadata or analysis results
*.cache
</file>

<file path="PawMatch.Application/Class1.cs">
namespace PawMatch.Application;
public class Class1
{
}
</file>

<file path="PawMatch.Application/DTOs/DiscoverUserPetDto.cs">
namespace PawMatch.Application.DTOs
{
    public class DiscoverUserPetDto
    {
        public UserPublicDto User { get; set; }
        public DiscoverPetDto Pet { get; set; } // null olabilir
    }
    public class DiscoverPetDto
    {
        public string Name { get; set; }
        public string Type { get; set; }
        public int Age { get; set; }
        public List<DiscoverPhotoDto> Photos { get; set; }
    }
    public class DiscoverPhotoDto
    {
        public string? GoogleDriveFileId { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/MatchActionDto.cs">
namespace PawMatch.Application.DTOs
{
    public class MatchActionDto
    {
        public int User1Id { get; set; }
        public int User2Id { get; set; }
        public bool Liked { get; set; }
    }
    public class MatchResultDto
    {
        public int MatchId { get; set; }
        public bool Confirmed { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/MatchDto.cs">
namespace PawMatch.Application.DTOs
{
    public class MatchDto
    {
        public int MatchId { get; set; }
        public bool Confirmed { get; set; }
        public UserPublicDto User { get; set; } // Karşı taraf
    }
}
</file>

<file path="PawMatch.Application/DTOs/MessageDto.cs">
using System;
using PawMatch.Domain;
namespace PawMatch.Application.DTOs
{
    public class MessageDto
    {
        public int Id { get; set; }
        public int SenderId { get; set; }
        public UserPublicDto Sender { get; set; }
        public string Content { get; set; }
        public DateTime Timestamp { get; set; }
        public bool IsRead { get; set; }
    }
    public static class MessageDtoMapper
    {
        public static MessageDto ToDto(Message message, UserPublicDto sender)
        {
            return new MessageDto
            {
                Id = message.Id,
                SenderId = message.SenderId,
                Sender = sender,
                Content = message.Content,
                Timestamp = message.Timestamp,
                IsRead = message.IsRead
            };
        }
    }
}
</file>

<file path="PawMatch.Application/DTOs/PetDto.cs">
namespace PawMatch.Application.DTOs
{
    public class PetDto
    {
        public int Id { get; set; }
        public int UserId { get; set; } // Owner's ID
        public string Name { get; set; }
        public string Breed { get; set; }
        public int Age { get; set; }
        public string Description { get; set; }
        public List<string> PhotoIds { get; set; } // Google Drive File IDs
    }
}
</file>

<file path="PawMatch.Application/DTOs/PhotoDto.cs">
using System;
namespace PawMatch.Application.DTOs
{
    public class PhotoDto
    {
        public int Id { get; set; }
        public string FileName { get; set; }
        public string ContentType { get; set; }
        public string GoogleDriveFileId { get; set; }
        public DateTime UploadDate { get; set; }
        public int? UserId { get; set; }
        public int? PetId { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/PhotoUploadDto.cs">
namespace PawMatch.Application.DTOs
{
    public class PhotoUploadDto
    {
        public int? UserId { get; set; }
        public int? PetId { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/UpdateProfileDto.cs">
using System.ComponentModel.DataAnnotations;
namespace PawMatch.Application.DTOs
{
    public class UpdateProfileDto
    {
        [Required]
        public string Name { get; set; }
        [StringLength(500)]
        public string Bio { get; set; }
        public bool HasPet { get; set; }
        // Örnek: public int? Age { get; set; }
        // Örnek: public string? Gender { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/UserAuthResponseDto.cs">
namespace PawMatch.Application.DTOs
{
    public class ApiResponse<T>
    {
        public T Data { get; set; }
        public string Status { get; set; }
        public object? Error { get; set; } // Can be null or an error object
    }
    public class UserAuthResponseDto
    {
        public UserPrivateDto UserPrivate { get; set; }
        public string Token { get; set; }
    }
    public class UserPrivateDto : UserBaseDto
    {
        public string Email { get; set; }
        public string PasswordHash { get; set; } // Sadece burada!
        public List<int> PetIds { get; set; }
    }
    public static class UserPrivateDtoMapper
    {
        public static UserPrivateDto ToPrivateDto(PawMatch.Domain.User user, List<int> photoIds, List<int> petIds)
        {
            return new UserPrivateDto
            {
                Id = user.Id,
                Name = user.Name,
                Email = user.Email,
                Bio = user.Bio,
                HasPet = user.HasPet,
                HasProfile = user.HasProfile,
                PhotoIds = photoIds,
                PetIds = petIds,
                // Age, Gender eklenirse buraya eklenir
                PasswordHash = user.PasswordHash
            };
        }
    }
}
</file>

<file path="PawMatch.Application/DTOs/UserBaseDto.cs">
using System.Collections.Generic;
namespace PawMatch.Application.DTOs
{
    public class UserBaseDto
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string? Bio { get; set; }
        public bool HasPet { get; set; }
        public bool HasProfile { get; set; }
        public List<int> PhotoIds { get; set; }
        public int? Age { get; set; }
        public string? Gender { get; set; }
        public List<int> PetIds { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/UserLoginDto.cs">
using System.ComponentModel.DataAnnotations;
namespace PawMatch.Application.DTOs
{
    public class UserLoginDto
    {
        [Required, EmailAddress]
        public string Email { get; set; }
        [Required]
        public string Password { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/UserPublicDto.cs">
using System.Collections.Generic;
using PawMatch.Domain;
namespace PawMatch.Application.DTOs
{
    public class UserPublicDto : UserBaseDto
    {
        // Sadece public alanlar, ekstra yok
    }
    public static class UserPublicDtoMapper
    {
        public static UserPublicDto ToPublicDto(User user, List<int> photoIds, List<int> petIds)
        {
            return new UserPublicDto
            {
                Id = user.Id,
                Name = user.Name,
                Bio = user.Bio,
                HasPet = user.HasPet,
                HasProfile = user.HasProfile,
                PhotoIds = photoIds,
                PetIds = petIds,
                Age = null, // user.Age,
                Gender = null // user.Gender
            };
        }
    }
}
</file>

<file path="PawMatch.Application/DTOs/UserRegisterDto.cs">
using System.ComponentModel.DataAnnotations;
namespace PawMatch.Application.DTOs
{
    public class UserRegisterDto
    {
        [Required]
        public string Name { get; set; }
        [Required, EmailAddress]
        public string Email { get; set; }
        [Required, MinLength(6)]
        public string Password { get; set; }
        // Örnek: public int? Age { get; set; }
        // Örnek: public string? Gender { get; set; }
    }
}
</file>

<file path="PawMatch.Application/Interfaces/IDiscoverService.cs">
using System.Collections.Generic;
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
namespace PawMatch.Application.Interfaces
{
    public interface IDiscoverService
    {
        Task<List<DiscoverUserPetDto>> DiscoverUsersAsync(int currentUserId, double? maxDistanceKm = null, string? preferredPetType = null, int? offset = null, int? limit = null);
    }
}
</file>

<file path="PawMatch.Application/Interfaces/IMatchService.cs">
using System.Collections.Generic;
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using PawMatch.Domain;
namespace PawMatch.Application.Interfaces
{
    public interface IMatchService
    {
        Task<MatchResultDto> LikeOrPassAsync(int currentUserId, MatchActionDto dto);
        Task<List<MatchDto>> GetMatchesForUserAsync(int userId);
        Task<Match> GetMatchByIdAsync(int matchId);
    }
}
</file>

<file path="PawMatch.Application/Interfaces/IMessageService.cs">
using System.Collections.Generic;
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using PawMatch.Domain;
namespace PawMatch.Application.Interfaces
{
    public interface IMessageService
    {
        Task<Message> SendMessageAsync(int senderId, int recipientId, string content);
        Task<IEnumerable<Message>> GetChatHistoryAsync(int user1Id, int user2Id);
        Task<bool> MarkMessageAsReadAsync(int messageId);
    }
}
</file>

<file path="PawMatch.Application/Interfaces/IPhotoService.cs">
using System.IO;
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
namespace PawMatch.Application.Interfaces
{
    public interface IPhotoService
    {
        Task<PhotoDto> UploadPhotoAsync(PhotoUploadDto dto, Stream fileStream, string fileName = null, string contentType = null);
        Task<Stream> GetPhotoStreamAsync(int photoId, int userId);
        Task DeletePhotoAsync(int photoId);
        Task DeleteUserPhotosAsync(int userId);
        Task DeletePetPhotosAsync(int petId);
    }
}
</file>

<file path="PawMatch.Application/Interfaces/IRealtimeNotificationService.cs">
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using PawMatch.Domain;
namespace PawMatch.Application.Interfaces
{
    public interface IRealtimeNotificationService
    {
        Task SendMatchNotificationAsync(int user1Id, int user2Id, MatchResultDto matchResult);
        Task SendMessageAsync(int recipientId, Message message);
    }
}
</file>

<file path="PawMatch.Application/Interfaces/IUserService.cs">
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using System.Collections.Generic;
using PawMatch.Domain;
namespace PawMatch.Application.Interfaces
{
    public interface IUserService
    {
        Task<UserAuthResponseDto> RegisterAsync(UserRegisterDto dto);
        Task<UserAuthResponseDto> LoginAsync(UserLoginDto dto);
        Task<UserAuthResponseDto> UpdateProfileAsync(int id, UpdateProfileDto dto);
        Task DeleteUserAsync(int id);
        Task<User> GetUserByIdAsync(int id);
        Task<List<User>> GetUsersByIdsAsync(List<int> ids);
        Task<User> GetUserDomainByIdAsync(int id);
    }
}
</file>

<file path="PawMatch.Application/PawMatch.Application.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <ItemGroup>
        <ProjectReference Include="..\PawMatch.Domain\PawMatch.Domain.csproj" />
        <ProjectReference Include="..\PawMatch.Infrastructure\PawMatch.Infrastructure.csproj" />
    </ItemGroup>

    <ItemGroup>
        <PackageReference Include="BCrypt.Net-Next" Version="4.*" />
        <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="10.0.0-preview.5.25277.114" />
    </ItemGroup>

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

</Project>
</file>

<file path="PawMatch.Application/Services/DiscoverService.cs">
using PawMatch.Application.Interfaces;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Linq;
using PawMatch.Infrastructure;
using Microsoft.EntityFrameworkCore;
using PawMatch.Infrastructure.Interfaces;
using Microsoft.Extensions.Configuration;
using System;
using Microsoft.Extensions.Logging;
using PawMatch.Application.DTOs;
namespace PawMatch.Application.Services
{
    public class DiscoverService : IDiscoverService
    {
        private readonly AppDbContext _db;
        private readonly IUserSwipeRepository _userSwipeRepository;
        private readonly IConfiguration _configuration;
        private readonly ILogger<DiscoverService> _logger;
        public DiscoverService(AppDbContext db, IUserSwipeRepository userSwipeRepository, IConfiguration configuration, ILogger<DiscoverService> logger)
        {
            _db = db;
            _userSwipeRepository = userSwipeRepository;
            _configuration = configuration;
            _logger = logger;
        }
        public async Task<List<DiscoverUserPetDto>> DiscoverUsersAsync(int currentUserId, double? maxDistanceKm = null, string? preferredPetType = null, int? offset = null, int? limit = null)
        {
            // Configure exclusion and re-appearance durations from appsettings.json
            var swipeExclusionDurationDays = _configuration.GetValue<int?>("AppSettings:SwipeExclusionDurationDays") ?? 30; // Not directly used in the new logic but kept for consistency
            var swipeReappearDurationDays = _configuration.GetValue<int?>("AppSettings:SwipeReappearDurationDays") ?? 90;
            var reappearDate = DateTime.UtcNow.AddDays(-swipeReappearDurationDays);
            _logger.LogInformation($"DiscoverService: ReappearDate calculated as {reappearDate.ToShortDateString()}");
            // Get users that the current user has explicitly liked (IsLiked = true)
            // These users should generally be permanently excluded from discovery after the initial swipe,
            // unless a match is later unconfirmed. For simplicity, we exclude them.
            var likedUserIds = await _db.UserSwipes
                .Where(us => us.SwiperId == currentUserId && us.IsLiked)
                .Select(us => us.SwipedUserId)
                .ToListAsync();
            // Get users that the current user has passed (IsLiked = false) within the re-appearance duration.
            // Users passed before 'reappearDate' will be included in discovery again.
            var passedRecentlyUserIds = await _db.UserSwipes
                .Where(us => us.SwiperId == currentUserId && !us.IsLiked && us.SwipeDate >= reappearDate)
                .Select(us => us.SwipedUserId)
                                    .ToListAsync();
            // Combine both sets of excluded users: liked users (always excluded) and recently passed users.
            var excludedUserIds = likedUserIds.Union(passedRecentlyUserIds).ToList();
            _logger.LogInformation($"DiscoverService: Excluded User IDs: {string.Join(", ", excludedUserIds)}");
            // Start with all users except the current one and already excluded ones
            var query = _db.Users
                .Where(u => u.Id != currentUserId && !excludedUserIds.Contains(u.Id));
            // Apply location-based filtering (simplified for now, full PostGIS integration would be here)
            if (maxDistanceKm.HasValue)
            {
                // TODO: Implement actual geographical distance calculation with PostGIS
                // For now, this is a placeholder and doesn't actively filter by distance.
                // It ensures the parameter is used, but the logic would need PostGIS functions.
                // Example: query = query.Where(u => u.Latitude.HasValue && u.Longitude.HasValue &&
                //                                 _db.Database.ExecuteSqlRaw($"ST_DWithin(ST_SetSRID(ST_MakePoint({u.Longitude}, {u.Latitude}), 4326), ST_SetSRID(ST_MakePoint({currentUserLongitude}, {currentUserLatitude}), 4326), {maxDistanceKm * 1000})"));
            }
            // Apply pet type filtering
            if (!string.IsNullOrEmpty(preferredPetType))
            {
                // Filter users who have pets of the preferred type
                query = query.Where(u => u.Pets.Any(p => p.Type.ToLower() == preferredPetType.ToLower()));
            }
            var discoveredUserIds = await query.Select(u => u.Id).ToListAsync();
            // Kullanıcıları ve petlerini çek
            var usersWithDetails = await _db.Users
                .Where(u => discoveredUserIds.Contains(u.Id))
                .Include(u => u.Photos)
                .Include(u => u.Pets)
                    .ThenInclude(p => p.Photos)
                .ToListAsync(); // Verileri belleğe çek
            // Sayfalama uygula (bellekte)
            if (offset.HasValue)
            {
                usersWithDetails = usersWithDetails.Skip(offset.Value).ToList();
            }
            if (limit.HasValue)
            {
                usersWithDetails = usersWithDetails.Take(limit.Value).ToList();
            }
            var result = usersWithDetails.Select(u =>
            {
                var pet = u.Pets.FirstOrDefault();
                var photoIds = u.Photos.Select(p => p.Id).ToList();
                var petIds = u.Pets.Select(p => p.Id).ToList();
                return new DiscoverUserPetDto
                {
                    User = UserPublicDtoMapper.ToPublicDto(u, photoIds, petIds),
                    Pet = pet == null ? null : new DiscoverPetDto
                    {
                        Name = pet.Name,
                        Type = pet.Type,
                        Age = pet.Age,
                        Photos = pet.Photos.Select(pp => new DiscoverPhotoDto { GoogleDriveFileId = pp.GoogleDriveFileId }).ToList()
                    }
                };
            }).ToList();
            return result;
        }
    }
}
</file>

<file path="PawMatch.Application/Services/MatchService.cs">
using System.Collections.Generic;
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using PawMatch.Infrastructure;
using Microsoft.EntityFrameworkCore;
using PawMatch.Infrastructure.Interfaces;
using PawMatch.Domain;
using Microsoft.Extensions.Logging;
namespace PawMatch.Application.Services
{
    public class MatchService : IMatchService
    {
        private readonly AppDbContext _db;
        private readonly IUserSwipeRepository _userSwipeRepository;
        private readonly IRealtimeNotificationService _realtimeNotificationService;
        private readonly ILogger<MatchService> _logger;
        private readonly IMatchRepository _matchRepository;
        public MatchService(AppDbContext db, IUserSwipeRepository userSwipeRepository, IRealtimeNotificationService realtimeNotificationService, ILogger<MatchService> logger, IMatchRepository matchRepository)
        {
            _db = db;
            _userSwipeRepository = userSwipeRepository;
            _realtimeNotificationService = realtimeNotificationService;
            _logger = logger;
            _matchRepository = matchRepository;
        }
        public async Task<MatchResultDto> LikeOrPassAsync(int currentUserId, MatchActionDto dto)
        {
            if (currentUserId != dto.User1Id)
            {
                throw new UnauthorizedAccessException("Unauthorized: User ID mismatch.");
            }
            var userSwipe = new UserSwipe
            {
                SwiperId = dto.User1Id,
                SwipedUserId = dto.User2Id,
                IsLiked = dto.Liked,
                SwipeDate = DateTime.UtcNow
            };
            await _userSwipeRepository.AddAsync(userSwipe);
            var matchResult = new MatchResultDto { MatchId = 0, Confirmed = false };
            if (dto.Liked)
            {
                var reciprocalSwipe = await _userSwipeRepository.GetBySwiperAndSwipedUserAsync(dto.User2Id, dto.User1Id);
                if (reciprocalSwipe != null && reciprocalSwipe.IsLiked)
                {
                    var existingMatch = await _db.Matches
                        .FirstOrDefaultAsync(m => (m.User1Id == dto.User1Id && m.User2Id == dto.User2Id) ||
                                                    (m.User1Id == dto.User2Id && m.User2Id == dto.User1Id));
                    if (existingMatch == null)
                    {
                        var newMatch = new Match
                        {
                            User1Id = dto.User1Id,
                            User2Id = dto.User2Id,
                            Confirmed = true
                        };
                        await _db.Matches.AddAsync(newMatch);
                        await _db.SaveChangesAsync();
                        matchResult.MatchId = newMatch.Id;
                        _logger.LogInformation($"Yeni eşleşme oluşturuldu: MatchId={newMatch.Id}, User1Id={dto.User1Id}, User2Id={dto.User2Id}");
                    }
                    else
                    {
                        existingMatch.Confirmed = true;
                        _db.Matches.Update(existingMatch);
                        await _db.SaveChangesAsync();
                        matchResult.MatchId = existingMatch.Id;
                        _logger.LogInformation($"Mevcut eşleşme güncellendi: MatchId={existingMatch.Id}, User1Id={dto.User1Id}, User2Id={dto.User2Id}");
                    }
                    matchResult.Confirmed = true;
                    try
                    {
                        _logger.LogInformation($"Notification gönderiliyor: User1Id={dto.User1Id}, User2Id={dto.User2Id}, MatchId={matchResult.MatchId}");
                    await _realtimeNotificationService.SendMatchNotificationAsync(dto.User1Id, dto.User2Id, matchResult);
                        _logger.LogInformation($"Notification başarıyla gönderildi: User1Id={dto.User1Id}, User2Id={dto.User2Id}, MatchId={matchResult.MatchId}");
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, $"Notification gönderilemedi! User1Id={dto.User1Id}, User2Id={dto.User2Id}, MatchId={matchResult.MatchId}");
                    }
                }
            }
            else
            {
                var existingMatch = await _db.Matches
                    .FirstOrDefaultAsync(m => (m.User1Id == dto.User1Id && m.User2Id == dto.User2Id && m.Confirmed) ||
                                                (m.User1Id == dto.User2Id && m.User2Id == dto.User1Id && m.Confirmed));
                if (existingMatch != null)
                {
                    existingMatch.Confirmed = false;
                    _db.Matches.Update(existingMatch);
                    await _db.SaveChangesAsync();
                }
            }
            return matchResult;
        }
        /// <summary>
        /// Kullanıcının eşleşmelerini DTO olarak döndürür. Mapping sırasında User entity'den UserPublicDto'ya ve PhotoIds'e dönüştürülür.
        /// </summary>
        public async Task<List<MatchDto>> GetMatchesForUserAsync(int userId)
        {
            var matches = await _db.Matches
                .Where(m => m.Confirmed && (m.User1Id == userId || m.User2Id == userId))
                .Include(m => m.User1)
                .Include(m => m.User2)
                .ToListAsync();
            var result = new List<MatchDto>();
            foreach (var match in matches)
            {
                // Karşı tarafı bul
                var otherUser = match.User1Id == userId ? match.User2 : match.User1;
                var photoIds = await _db.Photos
                    .Where(p => p.UserId == otherUser.Id)
                    .Select(p => p.Id)
                    .ToListAsync();
                var petIds = await _db.Pets
                    .Where(p => p.UserId == otherUser.Id)
                    .Select(p => p.Id)
                    .ToListAsync();
                result.Add(new MatchDto
                {
                    MatchId = match.Id,
                    Confirmed = match.Confirmed,
                    User = UserPublicDtoMapper.ToPublicDto(otherUser, photoIds, petIds)
                });
            }
            return result;
        }
        public async Task<Match> GetMatchByIdAsync(int matchId)
        {
            return await _matchRepository.GetByIdAsync(matchId);
        }
    }
}
</file>

<file path="PawMatch.Application/Services/MessageService.cs">
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using PawMatch.Application.Interfaces;
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
namespace PawMatch.Application.Services
{
    public class MessageService : IMessageService
    {
        private readonly IMessageRepository _messageRepository;
        private readonly IRealtimeNotificationService _realtimeNotificationService;
        private readonly IUserRepository _userRepository;
        public MessageService(IMessageRepository messageRepository, IRealtimeNotificationService realtimeNotificationService, IUserRepository userRepository)
        {
            _messageRepository = messageRepository;
            _realtimeNotificationService = realtimeNotificationService;
            _userRepository = userRepository;
        }
        public async Task<Message> SendMessageAsync(int senderId, int recipientId, string content)
        {
            // Kullanıcı kontrolü
            var sender = await _userRepository.GetByIdAsync(senderId);
            if (sender == null)
                throw new ArgumentException($"Sender user not found: {senderId}");
            var recipient = await _userRepository.GetByIdAsync(recipientId);
            if (recipient == null)
                throw new ArgumentException($"Recipient user not found: {recipientId}");
            // (Opsiyonel) Yetkilendirme kontrolü: senderId ile dışarıdan gelen currentUserId eşleşmiyorsa
            // if (currentUserId != senderId) throw new UnauthorizedAccessException();
            var message = new Message
            {
                SenderId = senderId,
                RecipientId = recipientId,
                Content = content,
                Timestamp = DateTime.UtcNow,
                IsRead = false
            };
            await _messageRepository.AddMessageAsync(message);
            // Mesajı alıcıya SignalR üzerinden gönder
            await _realtimeNotificationService.SendMessageAsync(recipientId, message);
            return message;
        }
        public async Task<IEnumerable<Message>> GetChatHistoryAsync(int user1Id, int user2Id)
        {
            return await _messageRepository.GetMessagesBetweenUsersAsync(user1Id, user2Id);
        }
        public async Task<bool> MarkMessageAsReadAsync(int messageId)
        {
            var message = await _messageRepository.GetMessageByIdAsync(messageId);
            if (message == null) return false;
            message.IsRead = true;
            await _messageRepository.UpdateMessageAsync(message);
            return true;
        }
    }
}
</file>

<file path="PawMatch.Application/Services/PhotoService.cs">
using System;
using System.IO;
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
using PawMatch.Infrastructure;
using Microsoft.EntityFrameworkCore;
using System.Linq;
using System.Collections.Generic;
namespace PawMatch.Application.Services
{
    public class PhotoService : IPhotoService
    {
        private readonly AppDbContext _db;
        private readonly IStorageProvider _storageProvider;
        private readonly IDiscoverService _discoverService;
        public PhotoService(AppDbContext db, IStorageProvider storageProvider, IDiscoverService discoverService)
        {
            _db = db;
            _storageProvider = storageProvider;
            _discoverService = discoverService;
        }
        public async Task<PhotoDto> UploadPhotoAsync(PhotoUploadDto dto, Stream fileStream, string fileName = null, string contentType = null)
        {
            // Sınır ve tip kontrolleri üst katmanda yapılmalı
            var fileId = await _storageProvider.UploadAsync(fileStream, fileName, contentType);
            var photo = new Photo
            {
                FileName = fileName,
                GoogleDriveFileId = fileId,
                UploadDate = DateTime.UtcNow,
                UserId = dto.UserId,
                PetId = dto.PetId
            };
            _db.Photos.Add(photo);
            await _db.SaveChangesAsync();
            return new PhotoDto
            {
                Id = photo.Id,
                FileName = photo.FileName,
                ContentType = contentType,
                GoogleDriveFileId = fileId,
                UploadDate = photo.UploadDate,
                UserId = photo.UserId,
                PetId = photo.PetId
            };
        }
        public async Task<Stream> GetPhotoStreamAsync(int photoId, int userId)
        {
            var photo = await _db.Photos.FirstOrDefaultAsync(p => p.Id == photoId);
            if (photo == null) throw new Exception("Photo not found");
            // Sahiplik kontrolü
            if (photo.UserId == userId) return await _storageProvider.DownloadAsync(photo.GoogleDriveFileId);
            if (photo.PetId.HasValue)
            {
                var petOwnerId = await _db.Pets
                                            .Where(p => p.Id == photo.PetId.Value)
                                            .Select(p => p.UserId)
                                            .FirstOrDefaultAsync();
                if (petOwnerId == userId) return await _storageProvider.DownloadAsync(photo.GoogleDriveFileId);
            }
            if (photo.UserId.HasValue)
            {
                var discoveredUsers = await _discoverService.DiscoverUsersAsync(userId);
                var discoveredUserIds = discoveredUsers.Select(u => u.User.Id).ToList();
                if (discoveredUserIds.Contains(photo.UserId.Value))
                {
                    return await _storageProvider.DownloadAsync(photo.GoogleDriveFileId);
                }
            }
            throw new UnauthorizedAccessException("You are not authorized to view this photo.");
        }
        public async Task DeletePhotoAsync(int photoId)
        {
            var photo = await _db.Photos.FirstOrDefaultAsync(p => p.Id == photoId);
            if (photo == null) throw new Exception("Photo not found");
            await _storageProvider.DeleteAsync(photo.GoogleDriveFileId);
            _db.Photos.Remove(photo);
            await _db.SaveChangesAsync();
        }
        public async Task DeleteUserPhotosAsync(int userId)
        {
            var userPhotos = await _db.Photos.Where(p => p.UserId == userId).ToListAsync();
            foreach (var photo in userPhotos)
            {
                if (!string.IsNullOrEmpty(photo.GoogleDriveFileId))
                {
                    await _storageProvider.DeleteAsync(photo.GoogleDriveFileId);
                }
                _db.Photos.Remove(photo);
            }
            await _db.SaveChangesAsync();
        }
        public async Task DeletePetPhotosAsync(int petId)
        {
            var petPhotos = await _db.Photos.Where(p => p.PetId == petId).ToListAsync();
            foreach (var photo in petPhotos)
            {
                if (!string.IsNullOrEmpty(photo.GoogleDriveFileId))
                {
                    await _storageProvider.DeleteAsync(photo.GoogleDriveFileId);
                }
                _db.Photos.Remove(photo);
            }
            await _db.SaveChangesAsync();
        }
    }
}
</file>

<file path="PawMatch.Application/Services/UserService.cs">
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
using PawMatch.Infrastructure;
using BCrypt.Net;
using System.Linq;
using Microsoft.EntityFrameworkCore;
namespace PawMatch.Application.Services
{
    public class UserService : IUserService
    {
        private readonly IJwtProvider _jwtProvider;
        private readonly IUserRepository _userRepository;
        private readonly IPhotoService _photoService;
        private readonly AppDbContext _dbContext;
        public UserService(IUserRepository userRepository, IJwtProvider jwtProvider, IPhotoService photoService, AppDbContext dbContext)
        {
            _userRepository = userRepository;
            _jwtProvider = jwtProvider;
            _photoService = photoService;
            _dbContext = dbContext;
        }
        public async Task<UserAuthResponseDto> RegisterAsync(UserRegisterDto dto)
        {
            var user = new User
            {
                Name = dto.Name,
                Email = dto.Email,
                PasswordHash = BCrypt.Net.BCrypt.HashPassword(dto.Password)
            };
            await _userRepository.AddAsync(user);
            var token = _jwtProvider.GenerateToken(user);
            var userPhotos = await _dbContext.Photos
                                            .Where(p => p.UserId == user.Id)
                                            .Select(p => p.Id)
                                            .ToListAsync();
            return new UserAuthResponseDto
            {
                UserPrivate = new UserPrivateDto
                {
                    Id = user.Id,
                    Name = user.Name,
                    Email = user.Email,
                    Bio = user.Bio,
                    HasPet = user.HasPet,
                    HasProfile = !string.IsNullOrWhiteSpace(user.Name) && !string.IsNullOrWhiteSpace(user.Email) && !string.IsNullOrWhiteSpace(user.Bio) && user.HasPet,
                    PhotoIds = userPhotos
                },
                Token = token
            };
        }
        public async Task<UserAuthResponseDto> LoginAsync(UserLoginDto dto)
        {
            var user = await _userRepository.GetByEmailAsync(dto.Email);
            if (user == null || !BCrypt.Net.BCrypt.Verify(dto.Password, user.PasswordHash))
                throw new UnauthorizedAccessException("Geçersiz kimlik bilgileri");
            var token = _jwtProvider.GenerateToken(user);
            var userPhotos = await _dbContext.Photos
                                            .Where(p => p.UserId == user.Id)
                                            .Select(p => p.Id)
                                            .ToListAsync();
            return new UserAuthResponseDto
            {
                UserPrivate = new UserPrivateDto
                {
                    Id = user.Id,
                    Name = user.Name,
                    Email = user.Email,
                    Bio = user.Bio,
                    HasPet = user.HasPet,
                    HasProfile = !string.IsNullOrWhiteSpace(user.Name) && !string.IsNullOrWhiteSpace(user.Email) && !string.IsNullOrWhiteSpace(user.Bio) && user.HasPet,
                    PhotoIds = userPhotos
                },
                Token = token
            };
        }
        public async Task<UserAuthResponseDto> UpdateProfileAsync(int id, UpdateProfileDto dto)
        {
            var user = await _userRepository.GetByIdAsync(id);
            if (user == null)
                throw new KeyNotFoundException("Kullanıcı bulunamadı");
            user.Name = dto.Name;
            user.Bio = dto.Bio;
            user.HasPet = dto.HasPet;
            await _userRepository.UpdateAsync(user);
            var token = _jwtProvider.GenerateToken(user);
            var userPhotos = await _dbContext.Photos
                                            .Where(p => p.UserId == user.Id)
                                            .Select(p => p.Id)
                                            .ToListAsync();
            return new UserAuthResponseDto
            {
                UserPrivate = new UserPrivateDto
                {
                    Id = user.Id,
                    Name = user.Name,
                    Email = user.Email,
                    Bio = user.Bio,
                    HasPet = user.HasPet,
                    HasProfile = !string.IsNullOrWhiteSpace(user.Name) && !string.IsNullOrWhiteSpace(user.Email) && !string.IsNullOrWhiteSpace(user.Bio) && user.HasPet,
                    PhotoIds = userPhotos
                },
                Token = token
            };
        }
        public async Task DeleteUserAsync(int id)
        {
            var user = await _userRepository.GetByIdAsync(id);
            if (user == null)
            {
                throw new KeyNotFoundException("User not found.");
            }
            var pets = _dbContext.Pets.Where(p => p.UserId == id).ToList();
            foreach (var pet in pets)
            {
                await _photoService.DeletePetPhotosAsync(pet.Id);
                _dbContext.Pets.Remove(pet);
            }
            await _dbContext.SaveChangesAsync();
            await _photoService.DeleteUserPhotosAsync(id);
            await _userRepository.DeleteAsync(id);
        }
        /// <summary>
        /// API response için: Kullanıcıyı DTO olarak döndürür (login, register, profil için).
        /// </summary>
        public async Task<User> GetUserByIdAsync(int id)
        {
            var user = await _userRepository.GetByIdAsync(id);
            if (user == null)
            {
                throw new KeyNotFoundException("User not found.");
            }
            var userPhotos = await _dbContext.Photos
                                            .Where(p => p.UserId == user.Id)
                                            .Select(p => p)
                                            .ToListAsync();
            var petIds = await _dbContext.Pets
                                        .Where(p => p.UserId == user.Id)
                                        .Select(p => p)
                                        .ToListAsync();
            return new User
            {
                Id = user.Id,
                Name = user.Name,
                Email = user.Email,
                Bio = user.Bio,
                HasPet = user.HasPet,
                HasProfile = user.HasProfile,
                Photos = userPhotos,
                Pets = petIds
            };
        }
        /// <summary>
        /// Domain işlemleri için: Kullanıcıyı entity olarak döndürür.
        /// </summary>
        public async Task<User> GetUserDomainByIdAsync(int id)
        {
            return await _userRepository.GetByIdAsync(id);
        }
        /// <summary>
        /// Domain işlemleri için: Birden fazla kullanıcıyı entity olarak döndürür.
        /// </summary>
        public async Task<List<User>> GetUsersByIdsAsync(List<int> ids)
        {
            return await _userRepository.GetByIdsAsync(ids);
        }
    }
}
</file>

<file path="PawMatch.Domain/.gitignore">
# Build
bin/
obj/

# Metadata / Cache (IDE)
*.user
*.suo
*.cache

# Temporary files
*.tmp
*.log
</file>

<file path="PawMatch.Domain/Class1.cs">
namespace PawMatch.Domain;
public class Class1
{
}
</file>

<file path="PawMatch.Domain/Match.cs">
namespace PawMatch.Domain
{
    public class Match
    {
        public int Id { get; set; }
        public int User1Id { get; set; }
        public User User1 { get; set; }
        public int User2Id { get; set; }
        public User User2 { get; set; }
        public bool Confirmed { get; set; }
    }
}
</file>

<file path="PawMatch.Domain/Message.cs">
using System;
using System.ComponentModel.DataAnnotations.Schema;
namespace PawMatch.Domain
{
    public class Message
    {
        public int Id { get; set; }
        public int SenderId { get; set; }
        public int RecipientId { get; set; }
        public string Content { get; set; }
        public DateTime Timestamp { get; set; }
        public bool IsRead { get; set; }
        [ForeignKey("SenderId")]
        public User Sender { get; set; }
        [ForeignKey("RecipientId")]
        public User Recipient { get; set; }
    }
}
</file>

<file path="PawMatch.Domain/PawMatch.Domain.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

</Project>
</file>

<file path="PawMatch.Domain/Pet.cs">
using System.Collections.Generic;
namespace PawMatch.Domain
{
    public class Pet
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Type { get; set; }
        public int Age { get; set; }
        public string? Gender { get; set; }
        public int UserId { get; set; }
        public User User { get; set; }
        public List<Photo> Photos { get; set; } = new();
    }
}
</file>

<file path="PawMatch.Domain/Photo.cs">
using System;
namespace PawMatch.Domain
{
    public class Photo
    {
        public int Id { get; set; }
        public string FileName { get; set; }
        public string? GoogleDriveFileId { get; set; }
        public DateTime UploadDate { get; set; }
        public int? UserId { get; set; }
        public User? User { get; set; }
        public int? PetId { get; set; }
        public Pet? Pet { get; set; }
    }
}
</file>

<file path="PawMatch.Domain/User.cs">
using System.Collections.Generic;
using System.Linq;
namespace PawMatch.Domain
{
    public class User
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Email { get; set; }
        public string PasswordHash { get; set; }
        public string? Bio { get; set; }
        public bool HasPet { get; set; } = false;
        public bool HasProfile { get; set; } = false;
        public double? Latitude { get; set; }
        public double? Longitude { get; set; }
        public List<Photo> Photos { get; set; } = new();
        public List<Pet> Pets { get; set; } = new();
    }
    public static class UserExtensions
    {
        public static List<int> GetPhotoIds(this User user)
            => user.Photos?.Select(p => p.Id).ToList() ?? new List<int>();
        public static List<int> GetPetIds(this User user)
            => user.Pets?.Select(p => p.Id).ToList() ?? new List<int>();
    }
}
</file>

<file path="PawMatch.Domain/UserSwipe.cs">
namespace PawMatch.Domain
{
    public class UserSwipe
    {
        public int Id { get; set; }
        public int SwiperId { get; set; }
        public User Swiper { get; set; } // Navigation property
        public int SwipedUserId { get; set; }
        public User SwipedUser { get; set; } // Navigation property
        public bool IsLiked { get; set; }
        public DateTime SwipeDate { get; set; }
    }
}
</file>

<file path="PawMatch.Infrastructure/.gitignore">
# Build
bin/
obj/

# EF Core migration snapshots (if not needed in version control)
Migrations/*Snapshot.cs
</file>

<file path="PawMatch.Infrastructure/AppDbContext.cs">
using Microsoft.EntityFrameworkCore;
using PawMatch.Domain;
using BCrypt.Net;
namespace PawMatch.Infrastructure
{
    public class AppDbContext : DbContext
    {
        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }
        public DbSet<User> Users { get; set; }
        public DbSet<Pet> Pets { get; set; }
        public DbSet<Photo> Photos { get; set; }
        public DbSet<Match> Matches { get; set; }
        public DbSet<UserSwipe> UserSwipes { get; set; }
        public DbSet<Message> Messages { get; set; }
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);
            modelBuilder.Entity<UserSwipe>()
                .HasOne(us => us.Swiper)
                .WithMany()
                .HasForeignKey(us => us.SwiperId)
                .OnDelete(DeleteBehavior.Restrict); // Prevent cascade delete
            modelBuilder.Entity<UserSwipe>()
                .HasOne(us => us.SwipedUser)
                .WithMany()
                .HasForeignKey(us => us.SwipedUserId)
                .OnDelete(DeleteBehavior.Restrict); // Prevent cascade delete
            // Other existing configurations...
        }
        public static class AppDbContextSeed
        {
            public static void Seed(AppDbContext db)
            {
                if (!db.Users.Any())
                {
                    var user1 = new User { Name = "Berkan Mandacı", Email = "berkan_mandaci@hotmail.com", PasswordHash = BCrypt.Net.BCrypt.HashPassword("mandaci12"), Bio = "Kedisever", HasPet = true };
                    var user2 = new User { Name = "Zeynep", Email = "test2@example.com", PasswordHash = BCrypt.Net.BCrypt.HashPassword("mandaci12"), Bio = "Köpeksever", HasPet = false };
                    db.Users.AddRange(user1, user2);
                    db.SaveChanges();
                    var pet1 = new Pet { Name = "Boncuk", Type = "Kedi", Age = 2, UserId = user1.Id };
                    db.Pets.Add(pet1);
                    db.SaveChanges();
                    var photo1 = new Photo { FileName = "ali1.jpg", GoogleDriveFileId = "dummy-file-id-1", UploadDate = DateTime.UtcNow, UserId = user1.Id };
                    var photo2 = new Photo { FileName = "boncuk1.jpg", GoogleDriveFileId = "dummy-file-id-2", UploadDate = DateTime.UtcNow, PetId = pet1.Id };
                    var user1Photo = new Photo { FileName = "testphoto.jpg", GoogleDriveFileId = "user1-test-photo-id", UploadDate = DateTime.UtcNow, UserId = user1.Id };
                    var user2Photo = new Photo { FileName = "testphoto.jpg", GoogleDriveFileId = "user2-test-photo-id", UploadDate = DateTime.UtcNow, UserId = user2.Id };
                    db.Photos.AddRange(photo1, photo2, user1Photo, user2Photo);
                    db.SaveChanges();
                }
            }
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Class1.cs">
namespace PawMatch.Infrastructure;
public class Class1
{
}
</file>

<file path="PawMatch.Infrastructure/Interfaces/IJwtProvider.cs">
using PawMatch.Domain;
namespace PawMatch.Infrastructure.Interfaces
{
    public interface IJwtProvider
    {
        string GenerateToken(User user);
    }
}
</file>

<file path="PawMatch.Infrastructure/Interfaces/IMatchRepository.cs">
using System.Threading.Tasks;
using PawMatch.Domain;
namespace PawMatch.Infrastructure.Interfaces
{
    public interface IMatchRepository
    {
        Task<Match> GetByIdAsync(int matchId);
    }
}
</file>

<file path="PawMatch.Infrastructure/Interfaces/IMessageRepository.cs">
using PawMatch.Domain;
using System.Collections.Generic;
using System.Threading.Tasks;
namespace PawMatch.Infrastructure.Interfaces
{
    public interface IMessageRepository
    {
        Task AddMessageAsync(Message message);
        Task<IEnumerable<Message>> GetMessagesBetweenUsersAsync(int user1Id, int user2Id);
        Task<Message> GetMessageByIdAsync(int messageId);
        Task UpdateMessageAsync(Message message);
        Task DeleteMessageAsync(int messageId);
    }
}
</file>

<file path="PawMatch.Infrastructure/Interfaces/IStorageProvider.cs">
using System.IO;
using System.Threading.Tasks;
namespace PawMatch.Infrastructure.Interfaces
{
    public interface IStorageProvider
    {
        Task<string> UploadAsync(Stream fileStream, string fileName, string contentType);
        Task<Stream> DownloadAsync(string fileId);
        Task DeleteAsync(string fileId);
    }
}
</file>

<file path="PawMatch.Infrastructure/Interfaces/IUserRepository.cs">
using System.Threading.Tasks;
using PawMatch.Domain;
namespace PawMatch.Infrastructure.Interfaces
{
    public interface IUserRepository
    {
        Task AddAsync(User user);
        Task<User> GetByEmailAsync(string email);
        Task<User> GetByIdAsync(int id);
        Task UpdateAsync(User user);
        Task DeleteAsync(int id);
        Task<List<User>> GetByIdsAsync(List<int> ids);
    }
}
</file>

<file path="PawMatch.Infrastructure/Interfaces/IUserSwipeRepository.cs">
using PawMatch.Domain;
using System.Threading.Tasks;
namespace PawMatch.Infrastructure.Interfaces
{
    public interface IUserSwipeRepository
    {
        Task AddAsync(UserSwipe userSwipe);
        Task<UserSwipe> GetBySwiperAndSwipedUserAsync(int swiperId, int swipedUserId);
        // You can add more methods here as needed, e.g., to get recent swipes
    }
}
</file>

<file path="PawMatch.Infrastructure/Migrations/20250617224635_InitialCreate.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
#nullable disable
namespace PawMatch.Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Users",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    Name = table.Column<string>(type: "text", nullable: false),
                    Email = table.Column<string>(type: "text", nullable: false),
                    PasswordHash = table.Column<string>(type: "text", nullable: false),
                    Bio = table.Column<string>(type: "text", nullable: true),
                    HasPet = table.Column<bool>(type: "boolean", nullable: false),
                    HasProfile = table.Column<bool>(type: "boolean", nullable: false),
                    Latitude = table.Column<double>(type: "double precision", nullable: true),
                    Longitude = table.Column<double>(type: "double precision", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Users", x => x.Id);
                });
            migrationBuilder.CreateTable(
                name: "Matches",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    User1Id = table.Column<int>(type: "integer", nullable: false),
                    User2Id = table.Column<int>(type: "integer", nullable: false),
                    Confirmed = table.Column<bool>(type: "boolean", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Matches", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Matches_Users_User1Id",
                        column: x => x.User1Id,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_Matches_Users_User2Id",
                        column: x => x.User2Id,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });
            migrationBuilder.CreateTable(
                name: "Messages",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    SenderId = table.Column<int>(type: "integer", nullable: false),
                    RecipientId = table.Column<int>(type: "integer", nullable: false),
                    Content = table.Column<string>(type: "text", nullable: false),
                    Timestamp = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    IsRead = table.Column<bool>(type: "boolean", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Messages", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Messages_Users_RecipientId",
                        column: x => x.RecipientId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_Messages_Users_SenderId",
                        column: x => x.SenderId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });
            migrationBuilder.CreateTable(
                name: "Pets",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    Name = table.Column<string>(type: "text", nullable: false),
                    Type = table.Column<string>(type: "text", nullable: false),
                    Age = table.Column<int>(type: "integer", nullable: false),
                    Gender = table.Column<string>(type: "text", nullable: true),
                    UserId = table.Column<int>(type: "integer", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Pets", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Pets_Users_UserId",
                        column: x => x.UserId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });
            migrationBuilder.CreateTable(
                name: "UserSwipes",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    SwiperId = table.Column<int>(type: "integer", nullable: false),
                    SwipedUserId = table.Column<int>(type: "integer", nullable: false),
                    IsLiked = table.Column<bool>(type: "boolean", nullable: false),
                    SwipeDate = table.Column<DateTime>(type: "timestamp with time zone", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_UserSwipes", x => x.Id);
                    table.ForeignKey(
                        name: "FK_UserSwipes_Users_SwipedUserId",
                        column: x => x.SwipedUserId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                    table.ForeignKey(
                        name: "FK_UserSwipes_Users_SwiperId",
                        column: x => x.SwiperId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                });
            migrationBuilder.CreateTable(
                name: "Photos",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    FileName = table.Column<string>(type: "text", nullable: false),
                    GoogleDriveFileId = table.Column<string>(type: "text", nullable: true),
                    UploadDate = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    UserId = table.Column<int>(type: "integer", nullable: true),
                    PetId = table.Column<int>(type: "integer", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Photos", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Photos_Pets_PetId",
                        column: x => x.PetId,
                        principalTable: "Pets",
                        principalColumn: "Id");
                    table.ForeignKey(
                        name: "FK_Photos_Users_UserId",
                        column: x => x.UserId,
                        principalTable: "Users",
                        principalColumn: "Id");
                });
            migrationBuilder.CreateIndex(
                name: "IX_Matches_User1Id",
                table: "Matches",
                column: "User1Id");
            migrationBuilder.CreateIndex(
                name: "IX_Matches_User2Id",
                table: "Matches",
                column: "User2Id");
            migrationBuilder.CreateIndex(
                name: "IX_Messages_RecipientId",
                table: "Messages",
                column: "RecipientId");
            migrationBuilder.CreateIndex(
                name: "IX_Messages_SenderId",
                table: "Messages",
                column: "SenderId");
            migrationBuilder.CreateIndex(
                name: "IX_Pets_UserId",
                table: "Pets",
                column: "UserId");
            migrationBuilder.CreateIndex(
                name: "IX_Photos_PetId",
                table: "Photos",
                column: "PetId");
            migrationBuilder.CreateIndex(
                name: "IX_Photos_UserId",
                table: "Photos",
                column: "UserId");
            migrationBuilder.CreateIndex(
                name: "IX_UserSwipes_SwipedUserId",
                table: "UserSwipes",
                column: "SwipedUserId");
            migrationBuilder.CreateIndex(
                name: "IX_UserSwipes_SwiperId",
                table: "UserSwipes",
                column: "SwiperId");
        }
        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "Matches");
            migrationBuilder.DropTable(
                name: "Messages");
            migrationBuilder.DropTable(
                name: "Photos");
            migrationBuilder.DropTable(
                name: "UserSwipes");
            migrationBuilder.DropTable(
                name: "Pets");
            migrationBuilder.DropTable(
                name: "Users");
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Migrations/20250617224635_InitialCreate.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using PawMatch.Infrastructure;
#nullable disable
namespace PawMatch.Infrastructure.Migrations
{
    [DbContext(typeof(AppDbContext))]
    [Migration("20250617224635_InitialCreate")]
    partial class InitialCreate
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.17")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);
            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);
            modelBuilder.Entity("PawMatch.Domain.Match", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer");
                    NpgsqlPropertyBuilderExtensions.UseIdentityByDefaultColumn(b.Property<int>("Id"));
                    b.Property<bool>("Confirmed")
                        .HasColumnType("boolean");
                    b.Property<int>("User1Id")
                        .HasColumnType("integer");
                    b.Property<int>("User2Id")
                        .HasColumnType("integer");
                    b.HasKey("Id");
                    b.HasIndex("User1Id");
                    b.HasIndex("User2Id");
                    b.ToTable("Matches");
                });
            modelBuilder.Entity("PawMatch.Domain.Message", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer");
                    NpgsqlPropertyBuilderExtensions.UseIdentityByDefaultColumn(b.Property<int>("Id"));
                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("text");
                    b.Property<bool>("IsRead")
                        .HasColumnType("boolean");
                    b.Property<int>("RecipientId")
                        .HasColumnType("integer");
                    b.Property<int>("SenderId")
                        .HasColumnType("integer");
                    b.Property<DateTime>("Timestamp")
                        .HasColumnType("timestamp with time zone");
                    b.HasKey("Id");
                    b.HasIndex("RecipientId");
                    b.HasIndex("SenderId");
                    b.ToTable("Messages");
                });
            modelBuilder.Entity("PawMatch.Domain.Pet", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer");
                    NpgsqlPropertyBuilderExtensions.UseIdentityByDefaultColumn(b.Property<int>("Id"));
                    b.Property<int>("Age")
                        .HasColumnType("integer");
                    b.Property<string>("Gender")
                        .HasColumnType("text");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");
                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");
                    b.Property<int>("UserId")
                        .HasColumnType("integer");
                    b.HasKey("Id");
                    b.HasIndex("UserId");
                    b.ToTable("Pets");
                });
            modelBuilder.Entity("PawMatch.Domain.Photo", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer");
                    NpgsqlPropertyBuilderExtensions.UseIdentityByDefaultColumn(b.Property<int>("Id"));
                    b.Property<string>("FileName")
                        .IsRequired()
                        .HasColumnType("text");
                    b.Property<string>("GoogleDriveFileId")
                        .HasColumnType("text");
                    b.Property<int?>("PetId")
                        .HasColumnType("integer");
                    b.Property<DateTime>("UploadDate")
                        .HasColumnType("timestamp with time zone");
                    b.Property<int?>("UserId")
                        .HasColumnType("integer");
                    b.HasKey("Id");
                    b.HasIndex("PetId");
                    b.HasIndex("UserId");
                    b.ToTable("Photos");
                });
            modelBuilder.Entity("PawMatch.Domain.User", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer");
                    NpgsqlPropertyBuilderExtensions.UseIdentityByDefaultColumn(b.Property<int>("Id"));
                    b.Property<string>("Bio")
                        .HasColumnType("text");
                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");
                    b.Property<bool>("HasPet")
                        .HasColumnType("boolean");
                    b.Property<bool>("HasProfile")
                        .HasColumnType("boolean");
                    b.Property<double?>("Latitude")
                        .HasColumnType("double precision");
                    b.Property<double?>("Longitude")
                        .HasColumnType("double precision");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");
                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("text");
                    b.HasKey("Id");
                    b.ToTable("Users");
                });
            modelBuilder.Entity("PawMatch.Domain.UserSwipe", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer");
                    NpgsqlPropertyBuilderExtensions.UseIdentityByDefaultColumn(b.Property<int>("Id"));
                    b.Property<bool>("IsLiked")
                        .HasColumnType("boolean");
                    b.Property<DateTime>("SwipeDate")
                        .HasColumnType("timestamp with time zone");
                    b.Property<int>("SwipedUserId")
                        .HasColumnType("integer");
                    b.Property<int>("SwiperId")
                        .HasColumnType("integer");
                    b.HasKey("Id");
                    b.HasIndex("SwipedUserId");
                    b.HasIndex("SwiperId");
                    b.ToTable("UserSwipes");
                });
            modelBuilder.Entity("PawMatch.Domain.Match", b =>
                {
                    b.HasOne("PawMatch.Domain.User", "User1")
                        .WithMany()
                        .HasForeignKey("User1Id")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("PawMatch.Domain.User", "User2")
                        .WithMany()
                        .HasForeignKey("User2Id")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User1");
                    b.Navigation("User2");
                });
            modelBuilder.Entity("PawMatch.Domain.Message", b =>
                {
                    b.HasOne("PawMatch.Domain.User", "Recipient")
                        .WithMany()
                        .HasForeignKey("RecipientId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("PawMatch.Domain.User", "Sender")
                        .WithMany()
                        .HasForeignKey("SenderId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Recipient");
                    b.Navigation("Sender");
                });
            modelBuilder.Entity("PawMatch.Domain.Pet", b =>
                {
                    b.HasOne("PawMatch.Domain.User", "User")
                        .WithMany("Pets")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User");
                });
            modelBuilder.Entity("PawMatch.Domain.Photo", b =>
                {
                    b.HasOne("PawMatch.Domain.Pet", "Pet")
                        .WithMany("Photos")
                        .HasForeignKey("PetId");
                    b.HasOne("PawMatch.Domain.User", "User")
                        .WithMany("Photos")
                        .HasForeignKey("UserId");
                    b.Navigation("Pet");
                    b.Navigation("User");
                });
            modelBuilder.Entity("PawMatch.Domain.UserSwipe", b =>
                {
                    b.HasOne("PawMatch.Domain.User", "SwipedUser")
                        .WithMany()
                        .HasForeignKey("SwipedUserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.HasOne("PawMatch.Domain.User", "Swiper")
                        .WithMany()
                        .HasForeignKey("SwiperId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.Navigation("SwipedUser");
                    b.Navigation("Swiper");
                });
            modelBuilder.Entity("PawMatch.Domain.Pet", b =>
                {
                    b.Navigation("Photos");
                });
            modelBuilder.Entity("PawMatch.Domain.User", b =>
                {
                    b.Navigation("Pets");
                    b.Navigation("Photos");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/PawMatch.Infrastructure.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <ItemGroup>
      <ProjectReference Include="..\PawMatch.Domain\PawMatch.Domain.csproj" />
    </ItemGroup>

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.*" />
      <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.*" />
      <PackageReference Include="Microsoft.IdentityModel.Tokens" Version="8.12.0" />
      <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.*" />
      <PackageReference Include="BCrypt.Net-Next" Version="4.*" />
      <PackageReference Include="Google.Apis.Drive.v3" Version="1.*" />
      <PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="8.12.0" />
    </ItemGroup>

    <ItemGroup>
      <Folder Include="Migrations\" />
    </ItemGroup>

</Project>
</file>

<file path="PawMatch.Infrastructure/Providers/GoogleDriveStorageProvider.cs">
using Google.Apis.Auth.OAuth2;
using Google.Apis.Drive.v3;
using Google.Apis.Drive.v3.Data;
using Google.Apis.Services;
using PawMatch.Infrastructure.Interfaces;
using System;
using System.IO;
using System.Threading.Tasks;
namespace PawMatch.Infrastructure.Providers
{
    public class GoogleDriveStorageProvider : IStorageProvider
    {
        private readonly DriveService _driveService;
        public GoogleDriveStorageProvider()
        {
            var credentialsPath = Environment.GetEnvironmentVariable("GoogleDrive__CredentialsPath")
                ?? "api/credentials/credentials.json";
            var credential = GoogleCredential.FromFile(credentialsPath)
                .CreateScoped(DriveService.Scope.Drive);
            _driveService = new DriveService(new BaseClientService.Initializer
            {
                HttpClientInitializer = credential,
                ApplicationName = "PawMatch"
            });
        }
        public async Task<string> UploadAsync(Stream fileStream, string fileName, string contentType)
        {
            var fileMetadata = new Google.Apis.Drive.v3.Data.File
            {
                Name = fileName,
                Parents = new[] { "root" }
            };
            var request = _driveService.Files.Create(fileMetadata, fileStream, contentType);
            request.Fields = "id";
            var file = await request.UploadAsync();
            if (file.Status != Google.Apis.Upload.UploadStatus.Completed)
                throw new Exception("Google Drive upload failed: " + file.Exception?.Message);
            return request.ResponseBody.Id;
        }
        public async Task<Stream> DownloadAsync(string fileId)
        {
            var stream = new MemoryStream();
            var request = _driveService.Files.Get(fileId);
            await request.DownloadAsync(stream);
            stream.Position = 0;
            return stream;
        }
        public async Task DeleteAsync(string fileId)
        {
            await _driveService.Files.Delete(fileId).ExecuteAsync();
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Providers/JwtProvider.cs">
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
using System;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using Microsoft.IdentityModel.Tokens;
using System.Text;
namespace PawMatch.Infrastructure.Providers
{
    public class JwtProvider : IJwtProvider
    {
        public string GenerateToken(User user)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.ASCII.GetBytes("super-secret-key-which-is-at-least-32-chars!");
            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(new[]
                {
                    new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
                    new Claim(ClaimTypes.Name, user.Name ?? "")
                }),
                Expires = DateTime.UtcNow.AddDays(7),
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
            };
            var token = tokenHandler.CreateToken(tokenDescriptor);
            return tokenHandler.WriteToken(token);
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Repositories/MatchRepository.cs">
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
namespace PawMatch.Infrastructure.Repositories
{
    public class MatchRepository : IMatchRepository
    {
        private readonly AppDbContext _db;
        public MatchRepository(AppDbContext db)
        {
            _db = db;
        }
        public async Task<Match> GetByIdAsync(int matchId)
        {
            return await _db.Matches
                .Include(m => m.User1)
                .Include(m => m.User2)
                .FirstOrDefaultAsync(m => m.Id == matchId);
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Repositories/MessageRepository.cs">
using Microsoft.EntityFrameworkCore;
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
namespace PawMatch.Infrastructure.Repositories
{
    public class MessageRepository : IMessageRepository
    {
        private readonly AppDbContext _db;
        public MessageRepository(AppDbContext db)
        {
            _db = db;
        }
        public async Task AddMessageAsync(Message message)
        {
            await _db.Messages.AddAsync(message);
            await _db.SaveChangesAsync();
        }
        public async Task<IEnumerable<Message>> GetMessagesBetweenUsersAsync(int user1Id, int user2Id)
        {
            return await _db.Messages
                .Where(m => (m.SenderId == user1Id && m.RecipientId == user2Id) ||
                            (m.SenderId == user2Id && m.RecipientId == user1Id))
                .OrderBy(m => m.Timestamp)
                .ToListAsync();
        }
        public async Task<Message> GetMessageByIdAsync(int messageId)
        {
            return await _db.Messages.FindAsync(messageId);
        }
        public async Task UpdateMessageAsync(Message message)
        {
            _db.Messages.Update(message);
            await _db.SaveChangesAsync();
        }
        public async Task DeleteMessageAsync(int messageId)
        {
            var message = await _db.Messages.FindAsync(messageId);
            if (message != null)
            {
                _db.Messages.Remove(message);
                await _db.SaveChangesAsync();
            }
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Repositories/UserRepository.cs">
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
using System.Collections.Generic;
using System.Linq;
namespace PawMatch.Infrastructure.Repositories
{
    public class UserRepository : IUserRepository
    {
        private readonly AppDbContext _context;
        public UserRepository(AppDbContext context)
        {
            _context = context;
        }
        public async Task AddAsync(User user)
        {
            _context.Users.Add(user);
            await _context.SaveChangesAsync();
        }
        public async Task<User> GetByEmailAsync(string email)
        {
            return await _context.Users.FirstOrDefaultAsync(u => u.Email == email);
        }
        public async Task<User> GetByIdAsync(int id)
        {
            return await _context.Users.FirstOrDefaultAsync(u => u.Id == id);
        }
        public async Task UpdateAsync(User user)
        {
            _context.Users.Update(user);
            await _context.SaveChangesAsync();
        }
        public async Task DeleteAsync(int id)
        {
            var user = await _context.Users.FindAsync(id);
            if (user != null)
            {
                _context.Users.Remove(user);
                await _context.SaveChangesAsync();
            }
            // If user is not found, we can choose to throw an exception or handle it silently
            // For now, we will assume the UserService handles the KeyNotFoundException
        }
        public async Task<List<User>> GetByIdsAsync(List<int> ids)
        {
            return await _context.Users.Where(u => ids.Contains(u.Id)).ToListAsync();
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Repositories/UserSwipeRepository.cs">
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
using Microsoft.EntityFrameworkCore;
using System.Threading.Tasks;
namespace PawMatch.Infrastructure.Repositories
{
    public class UserSwipeRepository : IUserSwipeRepository
    {
        private readonly AppDbContext _context;
        public UserSwipeRepository(AppDbContext context)
        {
            _context = context;
        }
        public async Task AddAsync(UserSwipe userSwipe)
        {
            await _context.UserSwipes.AddAsync(userSwipe);
            await _context.SaveChangesAsync();
        }
        public async Task<UserSwipe> GetBySwiperAndSwipedUserAsync(int swiperId, int swipedUserId)
        {
            return await _context.UserSwipes
                .FirstOrDefaultAsync(us => us.SwiperId == swiperId && us.SwipedUserId == swipedUserId);
        }
    }
}
</file>

<file path="PawMatch.sln">
Microsoft Visual Studio Solution File, Format Version 12.00
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PawMatch.Domain", "PawMatch.Domain/PawMatch.Domain.csproj", "{F6CA9996-D9C2-4FB4-A293-3F412AB97DD4}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PawMatch.Application", "PawMatch.Application/PawMatch.Application.csproj", "{7ABBB121-3284-42FD-ADA8-CD07A5612CB3}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PawMatch.Infrastructure", "PawMatch.Infrastructure/PawMatch.Infrastructure.csproj", "{43542647-5483-4625-A2F6-894D7951E00A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PawMatch.Api", "PawMatch.Api/PawMatch.Api.csproj", "{7F93D292-D228-4989-B0E5-7F9874577145}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PawMatch.Tests", "PawMatch.Tests/PawMatch.Tests.csproj", "{82857D4F-42CE-4EC7-B067-1D2DEB8FA860}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F6CA9996-D9C2-4FB4-A293-3F412AB97DD4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F6CA9996-D9C2-4FB4-A293-3F412AB97DD4}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F6CA9996-D9C2-4FB4-A293-3F412AB97DD4}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F6CA9996-D9C2-4FB4-A293-3F412AB97DD4}.Release|Any CPU.Build.0 = Release|Any CPU
		{7ABBB121-3284-42FD-ADA8-CD07A5612CB3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7ABBB121-3284-42FD-ADA8-CD07A5612CB3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7ABBB121-3284-42FD-ADA8-CD07A5612CB3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7ABBB121-3284-42FD-ADA8-CD07A5612CB3}.Release|Any CPU.Build.0 = Release|Any CPU
		{43542647-5483-4625-A2F6-894D7951E00A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{43542647-5483-4625-A2F6-894D7951E00A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{43542647-5483-4625-A2F6-894D7951E00A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{43542647-5483-4625-A2F6-894D7951E00A}.Release|Any CPU.Build.0 = Release|Any CPU
		{7F93D292-D228-4989-B0E5-7F9874577145}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7F93D292-D228-4989-B0E5-7F9874577145}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7F93D292-D228-4989-B0E5-7F9874577145}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7F93D292-D228-4989-B0E5-7F9874577145}.Release|Any CPU.Build.0 = Release|Any CPU
		{82857D4F-42CE-4EC7-B067-1D2DEB8FA860}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{82857D4F-42CE-4EC7-B067-1D2DEB8FA860}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{82857D4F-42CE-4EC7-B067-1D2DEB8FA860}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{82857D4F-42CE-4EC7-B067-1D2DEB8FA860}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal
</file>

<file path="PawMatch.sln.DotSettings.user">
<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003A0200000A_002Eil_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FDecompilerCache_003FILViewer_003F649f9a5315084d038b64e29ea11b1fb56d20_003F0a_003F47eddea8_003F0200000A_002Eil/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003ABase64UrlEncoder_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FDecompilerCache_003Fdecompiler_003F29ff067b86f14e4bb4efbb61ca7e366c5c020_003Ff6_003F277c54ee_003FBase64UrlEncoder_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003ADbContext_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FSourcesCache_003F3bd4df5aff92cabbc4d630be64227073db1b8539b3a1e47786b4b189d7cdb7_003FDbContext_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003A02000016pdb250_002Eil_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FDecompilerCache_003FILViewer_003F0a57c2beca0544ffa75a747802553d2326ae48_003F57_003F47fe8aeb_003F02000016pdb250_002Eil/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AIClassFixture_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FSourcesCache_003Fae7664a35557e6da52239284f9951659c394efee9e9d3754a7747669271fb12_003FIClassFixture_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AJwtSecurityTokenHandler_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FSourcesCache_003F3d4c4ed34e5f94ebe465430b2133a366a26598c20abf8ccde35f7e7ea36e_003FJwtSecurityTokenHandler_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AMatch_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FSourcesCache_003F881b94df1ada40f2f8c71240a283a0fc70144caad05031eb18539ff2f812f67a_003FMatch_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AOpenApiWorkspace_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FSourcesCache_003F89ac77946ec583874df87ebad9601cd883ff54a65af730c0192aaa794f94ab_003FOpenApiWorkspace_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/Environment/AssemblyExplorer/XmlDocument/@EntryValue">&lt;AssemblyExplorer&gt;&#xD;
  &lt;Assembly Path="C:\Users\berka\.nuget\packages\system.identitymodel.tokens.jwt\8.12.0\lib\net8.0\System.IdentityModel.Tokens.Jwt.dll" /&gt;&#xD;
&lt;/AssemblyExplorer&gt;</s:String>
	<s:String x:Key="/Default/Environment/UnitTesting/UnitTestSessionStore/Sessions/=28db82e0_002D24d3_002D451e_002D9b1c_002Dd8e294443eee/@EntryIndexedValue">&lt;SessionState ContinuousTestingMode="0" IsActive="True" Name="All tests from &amp;lt;PawMatch.Tests&amp;gt; #2" xmlns="urn:schemas-jetbrains-com:jetbrains-ut-session"&gt;&#xD;
  &lt;Project Location="C:\Projects\Business\PawMatch\api\PawMatch.Tests" Presentation="&amp;lt;PawMatch.Tests&amp;gt;" /&gt;&#xD;
&lt;/SessionState&gt;</s:String>
	<s:String x:Key="/Default/Environment/UnitTesting/UnitTestSessionStore/Sessions/=7b7a92e2_002D6eb4_002D4d97_002D9873_002Dc07e1d6ae584/@EntryIndexedValue">&lt;SessionState ContinuousTestingMode="0" Name="All tests from &amp;lt;PawMatch.Tests&amp;gt;" xmlns="urn:schemas-jetbrains-com:jetbrains-ut-session"&gt;&#xD;
  &lt;Project Location="C:\Projects\Business\PawMatch\api\PawMatch.Tests" Presentation="&amp;lt;PawMatch.Tests&amp;gt;" /&gt;&#xD;
&lt;/SessionState&gt;</s:String></wpf:ResourceDictionary>
</file>

<file path="PawMatch.Tests/.gitignore">
# Build
bin/
obj/

# Test Results
TestResults/
*.trx
*.coverage
*.coveragexml
coverage/

# Logs
*.log
logs/
</file>

<file path="PawMatch.Tests/CustomWebApplicationFactory.cs">
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using PawMatch.Infrastructure;
using PawMatch.Api; // PawMatch.Api projesini import edin
using Moq; // Add this using statement
using PawMatch.Infrastructure.Interfaces; // Add this using statement
using System.Linq; // Already there, but ensure it is
using System.Collections.Concurrent; // Add for ConcurrentDictionary
using Microsoft.Extensions.Hosting; // Required for IHostEnvironment
using Microsoft.Extensions.Hosting.Internal; // Required for HostingEnvironment
using Microsoft.Extensions.Configuration;
namespace PawMatch.Tests;
public class CustomWebApplicationFactory<TProgram> : WebApplicationFactory<TProgram> where TProgram : class
{
    // In-memory storage for mocked files
    private readonly ConcurrentDictionary<string, (string FileName, Stream Content)> _mockedFiles = new ConcurrentDictionary<string, (string, Stream)>();
    private readonly string _databaseName;
    public CustomWebApplicationFactory()
    {
        _databaseName = Guid.NewGuid().ToString();
    }
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.UseEnvironment("Testing");
        builder.ConfigureServices(services =>
        {
            // Remove all existing DbContextOptions<AppDbContext> registrations
            var dbContextOptionsDescriptors = services.Where(
                d => d.ServiceType == typeof(DbContextOptions<AppDbContext>)).ToList();
            foreach (var descriptor in dbContextOptionsDescriptors)
            {
                services.Remove(descriptor);
            }
            // Remove all existing AppDbContext registrations
            var appDbContextDescriptors = services.Where(
                d => d.ServiceType == typeof(AppDbContext)).ToList();
            foreach (var descriptor in appDbContextDescriptors)
            {
                services.Remove(descriptor);
            }
            // Remove the real IStorageProvider registration if it exists
            var storageProviderDescriptor = services.SingleOrDefault(
                d => d.ServiceType == typeof(IStorageProvider));
            if (storageProviderDescriptor != null)
            {
                services.Remove(storageProviderDescriptor);
            }
            // Remove existing IHostEnvironment registration if any
            var hostEnvironmentDescriptor = services.SingleOrDefault(d =>
                d.ServiceType == typeof(IHostEnvironment));
            if (hostEnvironmentDescriptor != null)
            {
                services.Remove(hostEnvironmentDescriptor);
            }
            // Add a custom IHostEnvironment for testing to ensure it's Production
            services.AddSingleton<IHostEnvironment>(new HostingEnvironment
            {
                EnvironmentName = "Testing",
                ApplicationName = "PawMatch.Api"
            });
            // Add a DbContext using an in-memory database for testing
            services.AddDbContext<AppDbContext>(options =>
            {
                options.UseInMemoryDatabase(_databaseName);
            });
            // Register a mocked IStorageProvider
            var mockStorageProvider = new Mock<IStorageProvider>();
            // Configure mock behavior for UploadAsync
            mockStorageProvider.Setup(s => s.UploadAsync(It.IsAny<Stream>(), It.IsAny<string>(), It.IsAny<string>()))
                               .ReturnsAsync((Stream stream, string fileName, string contentType) =>
                               {
                                   var fileId = Guid.NewGuid().ToString();
                                   var memoryStream = new MemoryStream();
                                   stream.CopyTo(memoryStream);
                                   memoryStream.Position = 0; // Reset position for future reads
                                   _mockedFiles[fileId] = (fileName, memoryStream);
                                   return fileId;
                               });
            // Configure mock behavior for DeleteAsync
            mockStorageProvider.Setup(s => s.DeleteAsync(It.IsAny<string>()))
                               .Returns((string fileId) =>
                               {
                                   _mockedFiles.TryRemove(fileId, out _);
                                   return Task.CompletedTask;
                               });
            // Configure mock behavior for DownloadAsync
            mockStorageProvider.Setup(s => s.DownloadAsync(It.IsAny<string>()))
                               .ReturnsAsync((string fileId) =>
                               {
                                   if (_mockedFiles.TryGetValue(fileId, out var fileData))
                                   {
                                       var newMemoryStream = new MemoryStream();
                                       fileData.Content.CopyTo(newMemoryStream);
                                       newMemoryStream.Position = 0;
                                       return newMemoryStream;
                                   }
                                   // Return an empty stream for not found files (or throw specific exception)
                                   return new MemoryStream(); 
                               });
            services.AddSingleton(mockStorageProvider.Object);
            // Build the service provider.
            var sp = services.BuildServiceProvider();
            // Create a scope to obtain a reference to the database contexts
            using (var scope = sp.CreateScope())
            {
                var scopedServices = scope.ServiceProvider;
                var db = scopedServices.GetRequiredService<AppDbContext>();
                // Ensure the database is created and is clean for each test.
                db.Database.EnsureDeleted(); // Clear the database before creating
                db.Database.EnsureCreated();
                // Seed the database with some test data.
                // We can add simple data here for tests, or use the existing seed method if suitable.
                PawMatch.Infrastructure.AppDbContext.AppDbContextSeed.Seed(db);
            }
        });
    }
}
</file>

<file path="PawMatch.Tests/DiscoverServiceTests.cs">
using Xunit;
using Microsoft.AspNetCore.Mvc.Testing;
using System.Threading.Tasks;
using PawMatch.Api;
using System.Net.Http;
using System.Net.Http.Json;
using PawMatch.Application.DTOs;
using System.Text.Json;
using System.Net;
using PawMatch.Infrastructure;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.EntityFrameworkCore;
using System.Linq;
using PawMatch.Domain;
using System;
using PawMatch.Application.Interfaces;
namespace PawMatch.Tests
{
    public class DiscoverServiceTests : IClassFixture<CustomWebApplicationFactory<Program>>
    {
        private readonly HttpClient _client;
        private readonly CustomWebApplicationFactory<Program> _factory;
        public DiscoverServiceTests(CustomWebApplicationFactory<Program> factory)
        {
            _factory = factory;
            _client = _factory.CreateClient();
        }
        private async Task<(string token, int userId)> RegisterAndLoginNewUser(string name, string email, string password)
        {
            var registerDto = new UserRegisterDto { Name = name, Email = email, Password = password };
            var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerDto);
            registerResponse.EnsureSuccessStatusCode();
            var authResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
            return (authResponse.Data.Token, authResponse.Data.UserPrivate.Id);
        }
        [Fact]
        public async Task Discover_ExcludesSwipedUsersWithinExclusionPeriod()
        {
            // Arrange
            var (_, user1Id) = await RegisterAndLoginNewUser("DiscUser1", "disc1@example.com", "Password123!");
            var (_, user2Id) = await RegisterAndLoginNewUser("DiscUser2", "disc2@example.com", "Password123!");
            var (_, user3Id) = await RegisterAndLoginNewUser("DiscUser3", "disc3@example.com", "Password123!");
            // User1 swipes (likes) User2 directly in the database
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var userSwipe = new UserSwipe
                {
                    SwiperId = user1Id,
                    SwipedUserId = user2Id,
                    IsLiked = true,
                    SwipeDate = DateTime.UtcNow
                };
                await dbContext.UserSwipes.AddAsync(userSwipe);
                await dbContext.SaveChangesAsync();
            }
            // Act: User1 discovers users by directly calling the service
            using (var scope = _factory.Services.CreateScope())
            {
                var discoverService = scope.ServiceProvider.GetRequiredService<IDiscoverService>();
                var discoveredUsers = await discoverService.DiscoverUsersAsync(user1Id);
                var discoveredUserIds = discoveredUsers.Select(u => u.User.Id).ToList();
                // Assert
                Assert.NotNull(discoveredUserIds);
                Assert.DoesNotContain(user2Id, discoveredUserIds); // User2 should be excluded
                Assert.Contains(user3Id, discoveredUserIds); // User3 should be discoverable
            }
        }
        [Fact]
        public async Task Discover_IncludesUsersSwipedOnOutsideExclusionPeriod()
        {
            // Arrange
            var (_, user1Id) = await RegisterAndLoginNewUser("DiscUser4", "disc4@example.com", "Password123!");
            var (_, user2Id) = await RegisterAndLoginNewUser("DiscUser5", "disc5@example.com", "Password123!");
            var (_, user3Id) = await RegisterAndLoginNewUser("DiscUser6", "disc6@example.com", "Password123!");
            // Manually add a swipe record for User1 swiping User2, but set SwipeDate to be outside the exclusion period
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var userSwipe = new UserSwipe
                {
                    SwiperId = user1Id,
                    SwipedUserId = user2Id,
                    IsLiked = true,
                    SwipeDate = DateTime.UtcNow.AddDays(-60) // Assuming default exclusion is 30 days
                };
                await dbContext.UserSwipes.AddAsync(userSwipe);
                await dbContext.SaveChangesAsync();
            }
            // Act: User1 discovers users by directly calling the service
            using (var scope = _factory.Services.CreateScope())
            {
                var discoverService = scope.ServiceProvider.GetRequiredService<IDiscoverService>();
                var discoveredUsers = await discoverService.DiscoverUsersAsync(user1Id);
                var discoveredUserIds = discoveredUsers.Select(u => u.User.Id).ToList();
                // Assert
                Assert.NotNull(discoveredUserIds);
                // User2 should NOT be in the discovered list for User1 because the swipe was a like, which are permanently excluded.
                Assert.DoesNotContain(user2Id, discoveredUserIds); 
                Assert.Contains(user3Id, discoveredUserIds);
            }
        }
        [Fact]
        public async Task Discover_ReincludesPassedUsersAfterReappearDuration()
        {
            // Arrange
            var (_, user1Id) = await RegisterAndLoginNewUser("ReappearUser1", "reappear1@example.com", "Password123!");
            var (_, user2Id) = await RegisterAndLoginNewUser("ReappearUser2", "reappear2@example.com", "Password123!");
            var (_, user3Id) = await RegisterAndLoginNewUser("ReappearUser3", "reappear3@example.com", "Password123!");
            // User1 passes User2, but the swipe date is older than the reappear duration (e.g., 90 days default)
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var userSwipe = new UserSwipe
                {
                    SwiperId = user1Id,
                    SwipedUserId = user2Id,
                    IsLiked = false, // Passed
                    SwipeDate = DateTime.UtcNow.AddDays(-100) // Older than 90 days reappear duration
                };
                await dbContext.UserSwipes.AddAsync(userSwipe);
                await dbContext.SaveChangesAsync();
            }
            // Act: User1 discovers users by directly calling the service
            using (var scope = _factory.Services.CreateScope())
            {
                var discoverService = scope.ServiceProvider.GetRequiredService<IDiscoverService>();
                var discoveredUsers = await discoverService.DiscoverUsersAsync(user1Id);
                var discoveredUserIds = discoveredUsers.Select(u => u.User.Id).ToList();
                // Assert
                Assert.NotNull(discoveredUserIds);
                Assert.Contains(user2Id, discoveredUserIds); // User2 should reappear in discovery list
                Assert.Contains(user3Id, discoveredUserIds); // User3 should still be discoverable
            }
        }
        [Fact]
        public async Task Discover_ExcludesPassedUsersWithinReappearDuration()
        {
            // Arrange
            var (_, user1Id) = await RegisterAndLoginNewUser("ExcludeReappearUser1", "exreappear1@example.com", "Password123!");
            var (_, user2Id) = await RegisterAndLoginNewUser("ExcludeReappearUser2", "exreappear2@example.com", "Password123!");
            var (_, user3Id) = await RegisterAndLoginNewUser("ExcludeReappearUser3", "exreappear3@example.com", "Password123!");
            // User1 passes User2, and the swipe date is within the reappear duration (e.g., 90 days default)
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var userSwipe = new UserSwipe
                {
                    SwiperId = user1Id,
                    SwipedUserId = user2Id,
                    IsLiked = false, // Passed
                    SwipeDate = DateTime.UtcNow.AddDays(-10) // Within 90 days reappear duration
                };
                await dbContext.UserSwipes.AddAsync(userSwipe);
                await dbContext.SaveChangesAsync();
            }
            // Act: User1 discovers users by directly calling the service
            using (var scope = _factory.Services.CreateScope())
            {
                var discoverService = scope.ServiceProvider.GetRequiredService<IDiscoverService>();
                var discoveredUsers = await discoverService.DiscoverUsersAsync(user1Id);
                var discoveredUserIds = discoveredUsers.Select(u => u.User.Id).ToList();
                // Assert
                Assert.NotNull(discoveredUserIds);
                Assert.DoesNotContain(user2Id, discoveredUserIds); // User2 should NOT reappear in discovery list yet
                Assert.Contains(user3Id, discoveredUserIds); // User3 should still be discoverable
            }
        }
        [Fact]
        public async Task Discover_WithMaxDistanceKm_ReturnsSuccess()
        {
            // Arrange
            var (user1Token, user1Id) = await RegisterAndLoginNewUser("DiscUser7", "disc7@example.com", "Password123!");
            var (user2Token, user2Id) = await RegisterAndLoginNewUser("DiscUser8", "disc8@example.com", "Password123!");
            // Act
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user1Token);
            var discoverResponse = await _client.GetAsync($"/api/v1/matches/discover?maxDistanceKm=100");
            // Assert
            discoverResponse.EnsureSuccessStatusCode();
            var result = await discoverResponse.Content.ReadFromJsonAsync<ApiResponse<List<DiscoverUserPetDto>>>();
            Assert.NotNull(result);
            Assert.NotNull(result.Data);
            // Further assertions would depend on actual geographical data and filtering logic
        }
        [Fact]
        public async Task Discover_WithPreferredPetType_ReturnsSuccess()
        {
            // Arrange
            var (user1Token, user1Id) = await RegisterAndLoginNewUser("DiscUser9", "disc9@example.com", "Password123!");
            var (user2Token, user2Id) = await RegisterAndLoginNewUser("DiscUser10", "disc10@example.com", "Password123!");
            // Act
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user1Token);
            var discoverResponse = await _client.GetAsync($"/api/v1/matches/discover?preferredPetType=dog");
            // Assert
            discoverResponse.EnsureSuccessStatusCode();
            var result = await discoverResponse.Content.ReadFromJsonAsync<ApiResponse<List<DiscoverUserPetDto>>>();
            Assert.NotNull(result);
            Assert.NotNull(result.Data);
            // Further assertions would depend on actual pet data and filtering logic
        }
    }
}
</file>

<file path="PawMatch.Tests/MatchesControllerTests.cs">
using Xunit;
using Microsoft.AspNetCore.Mvc.Testing;
using System.Threading.Tasks;
using PawMatch.Api;
using System.Net.Http;
using System.Net.Http.Json;
using PawMatch.Application.DTOs;
using System.Text.Json;
using System.Net;
using PawMatch.Infrastructure;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.EntityFrameworkCore;
using System.Linq;
using PawMatch.Domain;
using Moq;
using PawMatch.Application.Interfaces;
using PawMatch.Application.Services;
using PawMatch.Infrastructure.Repositories;
using PawMatch.Infrastructure.Interfaces;
using Microsoft.Extensions.Logging;
namespace PawMatch.Tests
{
    public class MatchesControllerTests : IClassFixture<CustomWebApplicationFactory<Program>>
    {
        private readonly HttpClient _client;
        private readonly CustomWebApplicationFactory<Program> _factory;
        public MatchesControllerTests(CustomWebApplicationFactory<Program> factory)
        {
            _factory = factory;
            _client = _factory.CreateClient();
        }
        private async Task<(string token, int userId)> AuthenticateUser(string email, string password)
        {
            var loginDto = new UserLoginDto { Email = email, Password = password };
            var loginResponse = await _client.PostAsJsonAsync("/api/v1/users/login", loginDto);
            loginResponse.EnsureSuccessStatusCode();
            var authResponse = await loginResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
            return (authResponse.Data.Token, authResponse.Data.UserPrivate.Id);
        }
        private async Task<(string token, int userId)> RegisterAndLoginNewUser(string name, string email, string password)
        {
            var registerDto = new UserRegisterDto { Name = name, Email = email, Password = password };
            var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerDto);
            registerResponse.EnsureSuccessStatusCode();
            var authResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
            return (authResponse.Data.Token, authResponse.Data.UserPrivate.Id);
        }
        [Fact]
        public async Task LikeOrPass_SuccessfulLikeAndReciprocalMatch_ReturnsConfirmedTrue()
        {
            // Arrange
            var (user1Token, user1Id) = await RegisterAndLoginNewUser("TestUser1", "test1@example.com", "Password123!");
            var (user2Token, user2Id) = await RegisterAndLoginNewUser("TestUser2", "test2@example.com", "Password123!");
            // User2 likes User1 (reciprocal swipe)
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user2Token);
            var user2LikesUser1Dto = new MatchActionDto { User1Id = user2Id, User2Id = user1Id, Liked = true };
            await _client.PostAsJsonAsync("/api/v1/matches", user2LikesUser1Dto);
            // Act: User1 likes User2
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user1Token);
            var user1LikesUser2Dto = new MatchActionDto { User1Id = user1Id, User2Id = user2Id, Liked = true };
            var response = await _client.PostAsJsonAsync("/api/v1/matches", user1LikesUser2Dto);
            // Assert
            response.EnsureSuccessStatusCode();
            var result = await response.Content.ReadFromJsonAsync<ApiResponse<MatchResultDto>>();
            Assert.NotNull(result);
            Assert.True(result.Data.Confirmed);
            Assert.True(result.Data.MatchId > 0);
            // Verify match in DB
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var match = await dbContext.Matches.FirstOrDefaultAsync(m => (m.User1Id == user1Id && m.User2Id == user2Id) || (m.User1Id == user2Id && m.User2Id == user1Id));
                Assert.NotNull(match);
                Assert.True(match.Confirmed);
            }
        }
        [Fact]
        public async Task LikeOrPass_SuccessfulLikeNoReciprocalMatch_ReturnsConfirmedFalse()
        {
            // Arrange
            var (user1Token, user1Id) = await RegisterAndLoginNewUser("TestUser3", "test3@example.com", "Password123!");
            var (user2Token, user2Id) = await RegisterAndLoginNewUser("TestUser4", "test4@example.com", "Password123!");
            // Act: User1 likes User2 (no reciprocal like yet)
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user1Token);
            var user1LikesUser2Dto = new MatchActionDto { User1Id = user1Id, User2Id = user2Id, Liked = true };
            var response = await _client.PostAsJsonAsync("/api/v1/matches", user1LikesUser2Dto);
            // Assert
            response.EnsureSuccessStatusCode();
            var result = await response.Content.ReadFromJsonAsync<ApiResponse<MatchResultDto>>();
            Assert.NotNull(result);
            Assert.False(result.Data.Confirmed);
            Assert.Equal(0, result.Data.MatchId); // No match created yet
            // Verify no match in DB
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var match = await dbContext.Matches.FirstOrDefaultAsync(m => (m.User1Id == user1Id && m.User2Id == user2Id) || (m.User1Id == user2Id && m.User2Id == user1Id));
                Assert.Null(match);
            }
        }
        [Fact]
        public async Task LikeOrPass_SuccessfulPass_ReturnsConfirmedFalseAndUpdatesExistingMatch()
        {
            // Arrange
            var (user1Token, user1Id) = await RegisterAndLoginNewUser("TestUser5", "test5@example.com", "Password123!");
            var (user2Token, user2Id) = await RegisterAndLoginNewUser("TestUser6", "test6@example.com", "Password123!");
            // Ensure a confirmed match exists first
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                await dbContext.Matches.AddAsync(new Domain.Match { User1Id = user1Id, User2Id = user2Id, Confirmed = true });
                await dbContext.SaveChangesAsync();
            }
            // Act: User1 passes User2
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user1Token);
            var user1PassesUser2Dto = new MatchActionDto { User1Id = user1Id, User2Id = user2Id, Liked = false };
            var response = await _client.PostAsJsonAsync("/api/v1/matches", user1PassesUser2Dto);
            // Assert
            response.EnsureSuccessStatusCode();
            var result = await response.Content.ReadFromJsonAsync<ApiResponse<MatchResultDto>>();
            Assert.NotNull(result);
            Assert.False(result.Data.Confirmed);
            // Verify match is unconfirmed in DB
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var match = await dbContext.Matches.FirstOrDefaultAsync(m => (m.User1Id == user1Id && m.User2Id == user2Id) || (m.User1Id == user2Id && m.User2Id == user1Id));
                Assert.NotNull(match);
                Assert.False(match.Confirmed);
            }
        }
        [Fact]
        public async Task LikeOrPass_InvalidUser1Id_ReturnsUnauthorized()
        {
            // Arrange
            var (user1Token, user1Id) = await RegisterAndLoginNewUser("TestUser7", "test7@example.com", "Password123!");
            var (_, user2Id) = await RegisterAndLoginNewUser("TestUser8", "test8@example.com", "Password123!");
            // Act: User1 tries to act on behalf of a different user (user2Id)
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user1Token);
            var invalidActionDto = new MatchActionDto { User1Id = user2Id, User2Id = user1Id, Liked = true }; // Invalid User1Id
            var response = await _client.PostAsJsonAsync("/api/v1/matches", invalidActionDto);
            // Assert
            Assert.Equal(HttpStatusCode.Unauthorized, response.StatusCode);
        }
        [Fact]
        public async Task LikeOrPassAsync_ConfirmedMatch_CallsSendMatchNotificationAsyncForBothUsers()
        {
            // Arrange
            var dbContextOptions = new DbContextOptionsBuilder<AppDbContext>()
                .UseInMemoryDatabase(databaseName: $"TestDb_{Guid.NewGuid()}")
                .Options;
            using var db = new AppDbContext(dbContextOptions);
            var userSwipeRepo = new UserSwipeRepository(db);
            var mockNotification = new Mock<IRealtimeNotificationService>();
            var mockLogger = new Mock<ILogger<MatchService>>();
            var mockMatchRepo = new Mock<IMatchRepository>();
            var matchService = new MatchService(db, userSwipeRepo, mockNotification.Object, mockLogger.Object, mockMatchRepo.Object);
            // Kullanıcılar ve reciprocal swipe oluştur
            var user1Id = 1;
            var user2Id = 2;
            db.Users.Add(new User { Id = user1Id, Name = "User1", Email = "user1@example.com", PasswordHash = "hashed" });
            db.Users.Add(new User { Id = user2Id, Name = "User2", Email = "user2@example.com", PasswordHash = "hashed" });
            db.SaveChanges();
            await userSwipeRepo.AddAsync(new UserSwipe { SwiperId = user2Id, SwipedUserId = user1Id, IsLiked = true, SwipeDate = DateTime.UtcNow });
            var dto = new MatchActionDto { User1Id = user1Id, User2Id = user2Id, Liked = true };
            // Act
            var result = await matchService.LikeOrPassAsync(user1Id, dto);
            // Assert
            Assert.True(result.Confirmed);
            mockNotification.Verify(m => m.SendMatchNotificationAsync(user1Id, user2Id, It.Is<MatchResultDto>(r => r.Confirmed)), Times.Once);
        }
        [Fact]
        public async Task LikeOrPassAsync_NoReciprocalMatch_DoesNotCallSendMatchNotificationAsync()
        {
            // Arrange
            var dbContextOptions = new DbContextOptionsBuilder<AppDbContext>()
                .UseInMemoryDatabase(databaseName: $"TestDb_{Guid.NewGuid()}")
                .Options;
            using var db = new AppDbContext(dbContextOptions);
            var userSwipeRepo = new UserSwipeRepository(db);
            var mockNotification = new Mock<IRealtimeNotificationService>();
            var mockLogger = new Mock<ILogger<MatchService>>();
            var mockMatchRepo = new Mock<IMatchRepository>();
            var matchService = new MatchService(db, userSwipeRepo, mockNotification.Object, mockLogger.Object, mockMatchRepo.Object);
            var user1Id = 1;
            var user2Id = 2;
            db.Users.Add(new User { Id = user1Id, Name = "User1", Email = "user1@example.com", PasswordHash = "hashed" });
            db.Users.Add(new User { Id = user2Id, Name = "User2", Email = "user2@example.com", PasswordHash = "hashed" });
            db.SaveChanges();
            // reciprocal swipe yok
            var dto = new MatchActionDto { User1Id = user1Id, User2Id = user2Id, Liked = true };
            // Act
            var result = await matchService.LikeOrPassAsync(user1Id, dto);
            // Assert
            Assert.False(result.Confirmed);
            mockNotification.Verify(m => m.SendMatchNotificationAsync(It.IsAny<int>(), It.IsAny<int>(), It.IsAny<MatchResultDto>()), Times.Never);
        }
    }
    public class MessageServiceNotificationTests
    {
        [Fact]
        public async Task SendMessageAsync_ValidMessage_CallsSendMessageNotificationAndSavesToDb()
        {
            // Arrange
            var dbContextOptions = new DbContextOptionsBuilder<AppDbContext>()
                .UseInMemoryDatabase(databaseName: $"TestDb_{Guid.NewGuid()}")
                .Options;
            using var db = new AppDbContext(dbContextOptions);
            var messageRepo = new MessageRepository(db);
            var mockNotification = new Mock<IRealtimeNotificationService>();
            var mockUserRepo = new Mock<IUserRepository>();
            var messageService = new MessageService(messageRepo, mockNotification.Object, mockUserRepo.Object);
            // Test users
            var senderId = 1;
            var recipientId = 2;
            var sender = new User { Id = senderId, Name = "Sender", Email = "sender@example.com", PasswordHash = "hashed" };
            var recipient = new User { Id = recipientId, Name = "Recipient", Email = "recipient@example.com", PasswordHash = "hashed" };
            db.Users.Add(sender);
            db.Users.Add(recipient);
            db.SaveChanges();
            mockUserRepo.Setup(r => r.GetByIdAsync(senderId)).ReturnsAsync(sender);
            mockUserRepo.Setup(r => r.GetByIdAsync(recipientId)).ReturnsAsync(recipient);
            var content = "Merhaba!";
            // Act
            var message = await messageService.SendMessageAsync(senderId, recipientId, content);
            // Assert
            Assert.NotNull(message);
            Assert.Equal(senderId, message.SenderId);
            Assert.Equal(recipientId, message.RecipientId);
            Assert.Equal(content, message.Content);
            mockNotification.Verify(m => m.SendMessageAsync(recipientId, It.Is<Message>(msg => msg.Content == content && msg.SenderId == senderId)), Times.Once);
            // Mesaj veritabanına kaydedildi mi?
            var dbMessage = db.Messages.FirstOrDefault(m => m.SenderId == senderId && m.RecipientId == recipientId && m.Content == content);
            Assert.NotNull(dbMessage);
        }
        [Fact]
        public async Task SendMessageAsync_InvalidRecipient_ThrowsArgumentException()
        {
            // Arrange
            var dbContextOptions = new DbContextOptionsBuilder<AppDbContext>()
                .UseInMemoryDatabase(databaseName: $"TestDb_{Guid.NewGuid()}")
                .Options;
            using var db = new AppDbContext(dbContextOptions);
            var messageRepo = new MessageRepository(db);
            var mockNotification = new Mock<IRealtimeNotificationService>();
            var mockUserRepo = new Mock<IUserRepository>();
            var messageService = new MessageService(messageRepo, mockNotification.Object, mockUserRepo.Object);
            var senderId = 1;
            var recipientId = 999; // Geçersiz
            var sender = new User { Id = senderId, Name = "Sender", Email = "sender@example.com", PasswordHash = "hashed" };
            db.Users.Add(sender);
            db.SaveChanges();
            mockUserRepo.Setup(r => r.GetByIdAsync(senderId)).ReturnsAsync(sender);
            mockUserRepo.Setup(r => r.GetByIdAsync(recipientId)).ReturnsAsync((User)null);
            var content = "Geçersiz alıcıya mesaj";
            // Act & Assert
            await Assert.ThrowsAsync<ArgumentException>(() => messageService.SendMessageAsync(senderId, recipientId, content));
        }
        [Fact]
        public async Task SendMessageAsync_InvalidSender_ThrowsArgumentException()
        {
            // Arrange
            var dbContextOptions = new DbContextOptionsBuilder<AppDbContext>()
                .UseInMemoryDatabase(databaseName: $"TestDb_{Guid.NewGuid()}")
                .Options;
            using var db = new AppDbContext(dbContextOptions);
            var messageRepo = new MessageRepository(db);
            var mockNotification = new Mock<IRealtimeNotificationService>();
            var mockUserRepo = new Mock<IUserRepository>();
            var messageService = new MessageService(messageRepo, mockNotification.Object, mockUserRepo.Object);
            var senderId = 1; // Geçersiz
            var recipientId = 2;
            var recipient = new User { Id = recipientId, Name = "Recipient", Email = "recipient@example.com", PasswordHash = "hashed" };
            db.Users.Add(recipient);
            db.SaveChanges();
            mockUserRepo.Setup(r => r.GetByIdAsync(senderId)).ReturnsAsync((User)null);
            mockUserRepo.Setup(r => r.GetByIdAsync(recipientId)).ReturnsAsync(recipient);
            var content = "Yetkisiz gönderici";
            // Act & Assert
            await Assert.ThrowsAsync<ArgumentException>(() => messageService.SendMessageAsync(senderId, recipientId, content));
        }
    }
}
</file>

<file path="PawMatch.Tests/PawMatch.Tests.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>

        <IsPackable>false</IsPackable>
        <IsTestProject>true</IsTestProject>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="coverlet.collector" Version="6.0.0"/>
        <PackageReference Include="Microsoft.AspNetCore.SignalR.Client" Version="10.0.0-preview.5.25277.114" />
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.8.0"/>
        <PackageReference Include="xunit" Version="2.*"/>
        <PackageReference Include="xunit.runner.visualstudio" Version="2.5.3"/>
        <PackageReference Include="Moq" Version="4.*"/>
        <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="8.*"/>
        <PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="8.*" />
        <ProjectReference Include="..\PawMatch.Api\PawMatch.Api.csproj" />
        <ProjectReference Include="..\PawMatch.Application\PawMatch.Application.csproj" />
        <ProjectReference Include="..\PawMatch.Domain\PawMatch.Domain.csproj" />
        <ProjectReference Include="..\PawMatch.Infrastructure\PawMatch.Infrastructure.csproj" />
    </ItemGroup>

    <ItemGroup>
        <Using Include="Xunit"/>
    </ItemGroup>

</Project>
</file>

<file path="PawMatch.Tests/PhotosControllerTests.cs">
using System.Net.Http.Json;
using Xunit;
using System.Threading.Tasks;
using PawMatch.Api;
using PawMatch.Application.DTOs;
using System.Net.Http.Headers;
using System.IO;
namespace PawMatch.Tests;
public class PhotosControllerTests : IClassFixture<CustomWebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public PhotosControllerTests(CustomWebApplicationFactory<Program> factory)
    {
        _client = factory.CreateClient();
    }
    [Fact]
    public async Task UploadUserPhoto_ValidFileAndAuth_ReturnsSuccess()
    {
        // Arrange: Register and log in a user
        var registerRequest = new UserRegisterDto
        {
            Name = "Photo Uploader",
            Email = "photoupload@example.com",
            Password = "Password123!"
        };
        var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerRequest);
        registerResponse.EnsureSuccessStatusCode();
        var registerApiResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        var authToken = registerApiResponse.Data.Token;
        _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", authToken);
        // Create a mock file (testphoto.jpg)
        var filePath = "testphoto.jpg";
        var fileContent = "This is a dummy image content for testing.";
        var memoryStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(fileContent));
        var content = new MultipartFormDataContent();
        var streamContent = new StreamContent(memoryStream);
        streamContent.Headers.ContentType = new MediaTypeHeaderValue("image/jpeg");
        content.Add(streamContent, "file", filePath);
        // Act
        var response = await _client.PostAsync("/api/v1/photos/user", content);
        // Assert
        response.EnsureSuccessStatusCode(); // Expect 200 OK
        var apiResponse = await response.Content.ReadFromJsonAsync<ApiResponse<PhotoDto>>();
        Assert.NotNull(apiResponse);
        Assert.Equal("success", apiResponse.Status);
        Assert.NotNull(apiResponse.Data);
        Assert.Equal(filePath, apiResponse.Data.FileName);
        Assert.NotNull(apiResponse.Data.GoogleDriveFileId);
        // Clean up
        _client.DefaultRequestHeaders.Authorization = null;
    }
    [Fact]
    public async Task GetPhoto_ValidIdAndAuth_ReturnsPhotoStream()
    {
        // Arrange: Register, log in, and upload a photo
        var registerRequest = new UserRegisterDto
        {
            Name = "Photo Getter",
            Email = "photoget@example.com",
            Password = "Password123!"
        };
        var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerRequest);
        registerResponse.EnsureSuccessStatusCode();
        var registerApiResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        var authToken = registerApiResponse.Data.Token;
        _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", authToken);
        var filePath = "testphoto_get.jpg";
        var fileContent = "This is content for getting a photo.";
        var memoryStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(fileContent));
        var content = new MultipartFormDataContent();
        var streamContent = new StreamContent(memoryStream);
        streamContent.Headers.ContentType = new MediaTypeHeaderValue("image/jpeg");
        content.Add(streamContent, "file", filePath);
        var uploadResponse = await _client.PostAsync("/api/v1/photos/user", content);
        uploadResponse.EnsureSuccessStatusCode();
        var uploadApiResponse = await uploadResponse.Content.ReadFromJsonAsync<ApiResponse<PhotoDto>>();
        var googleDriveFileId = uploadApiResponse.Data.GoogleDriveFileId;
        // Act: Get the photo stream
        var getResponse = await _client.GetAsync($"/api/v1/photos/{googleDriveFileId}");
        // Assert: Check if the response is successful and content matches
        getResponse.EnsureSuccessStatusCode();
        var returnedContent = await getResponse.Content.ReadAsStringAsync();
        Assert.Equal(fileContent, returnedContent);
        // Clean up
        _client.DefaultRequestHeaders.Authorization = null;
    }
    [Fact]
    public async Task DeletePhoto_ValidIdAndAuth_ReturnsSuccess()
    {
        // Arrange: Register, log in, and upload a photo
        var registerRequest = new UserRegisterDto
        {
            Name = "Photo Deleter",
            Email = "photodelete@example.com",
            Password = "Password123!"
        };
        var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerRequest);
        registerResponse.EnsureSuccessStatusCode();
        var registerApiResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        var authToken = registerApiResponse.Data.Token;
        _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", authToken);
        var filePath = "testphoto_delete.jpg";
        var fileContent = "This is content for deleting a photo.";
        var memoryStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(fileContent));
        var content = new MultipartFormDataContent();
        var streamContent = new StreamContent(memoryStream);
        streamContent.Headers.ContentType = new MediaTypeHeaderValue("image/jpeg");
        content.Add(streamContent, "file", filePath);
        var uploadResponse = await _client.PostAsync("/api/v1/photos/user", content);
        uploadResponse.EnsureSuccessStatusCode();
        var uploadApiResponse = await uploadResponse.Content.ReadFromJsonAsync<ApiResponse<PhotoDto>>();
        var googleDriveFileId = uploadApiResponse.Data.GoogleDriveFileId; // Use GoogleDriveFileId for deletion
        // Act: Delete the photo
        var deleteResponse = await _client.DeleteAsync($"/api/v1/photos/{googleDriveFileId}");
        // Assert: Check if the deletion was successful
        deleteResponse.EnsureSuccessStatusCode(); // Expect 200 OK
        var deleteApiResponse = await deleteResponse.Content.ReadFromJsonAsync<ApiResponse<object>>();
        Assert.NotNull(deleteApiResponse);
        Assert.Equal("success", deleteApiResponse.Status);
        // Optional: Try to get the photo again to confirm deletion (expect 404 Not Found)
        var getResponseAfterDelete = await _client.GetAsync($"/api/v1/photos/{googleDriveFileId}");
        Assert.Equal(System.Net.HttpStatusCode.NotFound, getResponseAfterDelete.StatusCode); // Changed from Unauthorized to NotFound
        // Clean up
        _client.DefaultRequestHeaders.Authorization = null;
    }
}
</file>

<file path="PawMatch.Tests/SignalRHubTests.cs">
using Microsoft.AspNetCore.SignalR.Client;
using PawMatch.Api;
using System.Net.Http;
using System.Net.Http.Json;
using PawMatch.Application.DTOs;
using System.Threading.Tasks;
using System;
namespace PawMatch.Tests;
public class SignalRHubTests : IClassFixture<CustomWebApplicationFactory<Program>>
{
    private readonly CustomWebApplicationFactory<Program> _factory;
    public SignalRHubTests(CustomWebApplicationFactory<Program> factory)
    {
        _factory = factory;
    }
    private async Task<string> RegisterAndLoginNewUser(string name, string email, string password)
    {
        var client = _factory.CreateClient();
        var registerDto = new UserRegisterDto { Name = name, Email = email, Password = password };
        var registerResponse = await client.PostAsJsonAsync("/api/v1/users/register", registerDto);
        registerResponse.EnsureSuccessStatusCode();
        var authResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        return authResponse.Data.Token;
    }
    private HubConnection CreateAuthenticatedHubConnection(string token)
    {
        var client = _factory.CreateClient();
        return new HubConnectionBuilder()
            .WithUrl(client.BaseAddress + "chatHub", options =>
            {
                options.HttpMessageHandlerFactory = _ => _factory.Server.CreateHandler();
                options.AccessTokenProvider = () => Task.FromResult(token);
            })
            .Build();
    }
    [Fact]
    public async Task SignalR_Service_Is_Registered()
    {
        // Arrange
        var token = await RegisterAndLoginNewUser("SignalRUser1", $"signalruser1_{Guid.NewGuid()}@example.com", "Password123!");
        var hubConnection = CreateAuthenticatedHubConnection(token);
        // Act & Assert
        await hubConnection.StartAsync();
        Assert.Equal(HubConnectionState.Connected, hubConnection.State);
        await hubConnection.StopAsync();
    }
    [Fact]
    public async Task ChatHub_Endpoint_Is_Accessible()
    {
        var token = await RegisterAndLoginNewUser("SignalRUser2", $"signalruser2_{Guid.NewGuid()}@example.com", "Password123!");
        var hubConnection = CreateAuthenticatedHubConnection(token);
        await hubConnection.StartAsync();
        Assert.Equal(HubConnectionState.Connected, hubConnection.State);
        await hubConnection.StopAsync();
    }
    [Fact]
    public async Task OnConnectedAsync_AddsUserToGroup()
    {
        var token = await RegisterAndLoginNewUser("SignalRUser3", $"signalruser3_{Guid.NewGuid()}@example.com", "Password123!");
        var hubConnection = CreateAuthenticatedHubConnection(token);
        bool connected = false;
        hubConnection.Closed += error =>
        {
            connected = false;
            return Task.CompletedTask;
        };
        await hubConnection.StartAsync();
        connected = hubConnection.State == HubConnectionState.Connected;
        Assert.True(connected);
        await hubConnection.StopAsync();
    }
    [Fact]
    public async Task OnDisconnectedAsync_RemovesUserFromGroup()
    {
        var token = await RegisterAndLoginNewUser("SignalRUser4", $"signalruser4_{Guid.NewGuid()}@example.com", "Password123!");
        var hubConnection = CreateAuthenticatedHubConnection(token);
        await hubConnection.StartAsync();
        await hubConnection.StopAsync();
        Assert.Equal(HubConnectionState.Disconnected, hubConnection.State);
    }
    [Fact]
    public async Task Multiple_Clients_Can_Connect_And_Disconnect()
    {
        var token1 = await RegisterAndLoginNewUser("SignalRUser5", $"signalruser5_{Guid.NewGuid()}@example.com", "Password123!");
        var token2 = await RegisterAndLoginNewUser("SignalRUser6", $"signalruser6_{Guid.NewGuid()}@example.com", "Password123!");
        var hubConnection1 = CreateAuthenticatedHubConnection(token1);
        var hubConnection2 = CreateAuthenticatedHubConnection(token2);
        await hubConnection1.StartAsync();
        await hubConnection2.StartAsync();
        Assert.Equal(HubConnectionState.Connected, hubConnection1.State);
        Assert.Equal(HubConnectionState.Connected, hubConnection2.State);
        await hubConnection1.StopAsync();
        await hubConnection2.StopAsync();
        Assert.Equal(HubConnectionState.Disconnected, hubConnection1.State);
        Assert.Equal(HubConnectionState.Disconnected, hubConnection2.State);
    }
}
</file>

<file path="PawMatch.Tests/UsersControllerTests.cs">
using System.Net.Http.Json;
using Xunit;
using System.Threading.Tasks;
using PawMatch.Api;
using PawMatch.Application.DTOs;
using System.Net.Http.Headers;
namespace PawMatch.Tests;
// Removed duplicated DTO definitions from here, they are now referenced from PawMatch.Application.DTOs
public class UsersControllerTests : IClassFixture<CustomWebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public UsersControllerTests(CustomWebApplicationFactory<Program> factory)
    {
        _client = factory.CreateClient();
    }
    [Fact]
    public async Task Register_ValidUser_ReturnsSuccessAndToken()
    {
        // Arrange
        var request = new UserRegisterDto
        {
            Name = "Test User",
            Email = "test@example.com",
            Password = "Password123!"
        };
        // Act
        var response = await _client.PostAsJsonAsync("/api/v1/users/register", request);
        // Assert
        response.EnsureSuccessStatusCode(); // Status Code 200-299
        var apiResponse = await response.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        Assert.NotNull(apiResponse);
        Assert.Equal("success", apiResponse.Status);
        Assert.NotNull(apiResponse.Data);
        Assert.NotNull(apiResponse.Data.UserPrivate);
        Assert.NotNull(apiResponse.Data.Token);
        Assert.Equal(request.Email, apiResponse.Data.UserPrivate.Email);
        Assert.NotNull(apiResponse.Data.UserPrivate.PhotoIds);
        Assert.Empty(apiResponse.Data.UserPrivate.PhotoIds);
    }
    [Fact]
    public async Task Login_ValidCredentials_ReturnsSuccessAndToken()
    {
        // Arrange: First, register a user to ensure we have credentials to log in with
        var registerRequest = new UserRegisterDto
        {
            Name = "Login Test User",
            Email = "logintest@example.com",
            Password = "Password123!"
        };
        await _client.PostAsJsonAsync("/api/v1/users/register", registerRequest);
        var loginRequest = new UserLoginDto
        {
            Email = registerRequest.Email,
            Password = registerRequest.Password
        };
        // Act
        var response = await _client.PostAsJsonAsync("/api/v1/users/login", loginRequest);
        // Assert
        response.EnsureSuccessStatusCode();
        var apiResponse = await response.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        Assert.NotNull(apiResponse);
        Assert.Equal("success", apiResponse.Status);
        Assert.NotNull(apiResponse.Data);
        Assert.NotNull(apiResponse.Data.UserPrivate);
        Assert.NotNull(apiResponse.Data.Token);
        Assert.Equal(loginRequest.Email, apiResponse.Data.UserPrivate.Email);
        Assert.NotNull(apiResponse.Data.UserPrivate.PhotoIds);
        Assert.Empty(apiResponse.Data.UserPrivate.PhotoIds);
    }
    [Fact]
    public async Task UpdateProfile_ValidData_ReturnsSuccessAndUpdatedUser()
    {
        // Arrange: Register and log in a user to get a valid token
        var registerRequest = new UserRegisterDto
        {
            Name = "Profile Update User",
            Email = "profileupdate@example.com",
            Password = "Password123!"
        };
        var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerRequest);
        registerResponse.EnsureSuccessStatusCode();
        var registerApiResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        var authToken = registerApiResponse.Data.Token;
        _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", authToken);
        var updateRequest = new UpdateProfileDto
        {
            Name = "Updated Name",
            Bio = "Updated Bio",
            HasPet = true
        };
        // Act
        var response = await _client.PatchAsJsonAsync("/api/v1/users/profile", updateRequest);
        // Assert
        response.EnsureSuccessStatusCode();
        var apiResponse = await response.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        Assert.NotNull(apiResponse);
        Assert.Equal("success", apiResponse.Status);
        Assert.NotNull(apiResponse.Data);
        Assert.NotNull(apiResponse.Data.UserPrivate);
        Assert.Equal(updateRequest.Name, apiResponse.Data.UserPrivate.Name);
        Assert.Equal(updateRequest.Bio, apiResponse.Data.UserPrivate.Bio);
        Assert.Equal(updateRequest.HasPet, apiResponse.Data.UserPrivate.HasPet);
        Assert.NotNull(apiResponse.Data.UserPrivate.PhotoIds);
        Assert.Empty(apiResponse.Data.UserPrivate.PhotoIds);
        // Clean up the Authorization header for subsequent tests
        _client.DefaultRequestHeaders.Authorization = null;
    }
    [Fact]
    public async Task DeleteMyAccount_ValidUser_ReturnsSuccessAndDeletesAccount()
    {
        // Arrange: Register and log in a user to get a valid token
        var registerRequest = new UserRegisterDto
        {
            Name = "Delete User Test",
            Email = "deleteuser@example.com",
            Password = "Password123!"
        };
        var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerRequest);
        registerResponse.EnsureSuccessStatusCode();
        var registerApiResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        var authToken = registerApiResponse.Data.Token;
        _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", authToken);
        // Act: Delete the user's account
        var deleteResponse = await _client.DeleteAsync("/api/v1/users/me");
        // Assert: Check if the deletion was successful
        deleteResponse.EnsureSuccessStatusCode(); // Expect 200 OK
        var deleteApiResponse = await deleteResponse.Content.ReadFromJsonAsync<ApiResponse<object>>();
        Assert.NotNull(deleteApiResponse);
        Assert.Equal("success", deleteApiResponse.Status);
        // Optional: Try to log in with the deleted user's credentials to confirm deletion
        _client.DefaultRequestHeaders.Authorization = null; // Clear header for next request
        var loginRequest = new UserLoginDto
        {
            Email = registerRequest.Email,
            Password = registerRequest.Password
        };
        var loginResponseAfterDelete = await _client.PostAsJsonAsync("/api/v1/users/login", loginRequest);
        // Assert: Expect Unauthorized (401) as the account should be deleted
        Assert.Equal(System.Net.HttpStatusCode.Unauthorized, loginResponseAfterDelete.StatusCode);
    }
    [Fact]
    public async Task GetUserProfile_ValidUser_ReturnsSuccessAndProfile()
    {
        // Arrange
        var client = _client;
        var registerDto = new UserRegisterDto { Name = "Test User", Email = "test.profile@example.com", Password = "Password123!" };
        var registerResponse = await client.PostAsJsonAsync("/api/v1/users/register", registerDto);
        registerResponse.EnsureSuccessStatusCode();
        var loginDto = new UserLoginDto { Email = "test.profile@example.com", Password = "Password123!" };
        var loginResponse = await client.PostAsJsonAsync("/api/v1/users/login", loginDto);
        loginResponse.EnsureSuccessStatusCode();
        var authResponse = await loginResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", authResponse?.Data?.Token);
        // Act
        var profileResponse = await client.GetAsync("/api/v1/users/me");
        // Assert
        profileResponse.EnsureSuccessStatusCode();
        var apiResponse = await profileResponse.Content.ReadFromJsonAsync<ApiResponse<UserPrivateDto>>();
        Assert.NotNull(apiResponse);
        Assert.Equal("Success", apiResponse.Status);
        Assert.NotNull(apiResponse.Data);
        Assert.Equal(registerDto.Email, apiResponse.Data.Email);
        Assert.Equal(registerDto.Name, apiResponse.Data.Name);
        Assert.False(apiResponse.Data.HasPet);
        Assert.False(apiResponse.Data.HasProfile);
        Assert.NotNull(apiResponse.Data.PhotoIds);
        Assert.Empty(apiResponse.Data.PhotoIds);
    }
}
</file>

<file path="PawMatch.Tests/UserSwipes.csv">
"Id","SwiperId","SwipedUserId","IsLiked","SwipeDate"
1,1,2,False,"2025-06-17 15:04:15.883298+00"
2,1,2,False,"2025-06-17 15:04:42.517078+00"
3,2,1,False,"2025-06-17 15:05:00.737813+00"
</file>

<file path="wait-for-it.sh">
#!/usr/bin/env bash
# Use this script to test if a given TCP host/port are available
WAITFORIT_cmdname=${0##*/}
echoerr() { if [[ $WAITFORIT_QUIET -ne 1 ]]; then echo "$@" 1>&2; fi }
usage()
{
    cat << USAGE >&2
Usage:
    $WAITFORIT_cmdname host:port [-s] [-t timeout] [-- command args]
    -h HOST | --host=HOST       Host or IP under test
    -p PORT | --port=PORT       TCP port under test
                                Alternatively, you specify the host and port as host:port
    -s | --strict               Only execute subcommand if the test succeeds
    -q | --quiet                Don't output any status messages
    -t TIMEOUT | --timeout=TIMEOUT
                                Timeout in seconds, zero for no timeout
    -- COMMAND ARGS             Execute command with args after the test finishes
USAGE
    exit 1
}
wait_for()
{
    if [[ $WAITFORIT_TIMEOUT -gt 0 ]]; then
        echoerr "$WAITFORIT_cmdname: waiting $WAITFORIT_TIMEOUT seconds for $WAITFORIT_HOST:$WAITFORIT_PORT"
    else
        echoerr "$WAITFORIT_cmdname: waiting for $WAITFORIT_HOST:$WAITFORIT_PORT without a timeout"
    fi
    WAITFORIT_start_ts=$(date +%s)
    while :
    do
        if [[ $WAITFORIT_ISBUSY -eq 1 ]]; then
            nc -z $WAITFORIT_HOST $WAITFORIT_PORT
            WAITFORIT_result=$?
        else
            (echo -n > /dev/tcp/$WAITFORIT_HOST/$WAITFORIT_PORT) >/dev/null 2>&1
            WAITFORIT_result=$?
        fi
        if [[ $WAITFORIT_result -eq 0 ]]; then
            WAITFORIT_end_ts=$(date +%s)
            echoerr "$WAITFORIT_cmdname: $WAITFORIT_HOST:$WAITFORIT_PORT is available after $((WAITFORIT_end_ts - WAITFORIT_start_ts)) seconds"
            break
        fi
        sleep 1
    done
    return $WAITFORIT_result
}
wait_for_wrapper()
{
    # In order to support SIGINT during timeout: http://unix.stackexchange.com/a/57692
    if [[ $WAITFORIT_QUIET -eq 1 ]]; then
        timeout $WAITFORIT_BUSYTIMEFLAG $WAITFORIT_TIMEOUT $0 --quiet --child --host=$WAITFORIT_HOST --port=$WAITFORIT_PORT --timeout=$WAITFORIT_TIMEOUT &
    else
        timeout $WAITFORIT_BUSYTIMEFLAG $WAITFORIT_TIMEOUT $0 --child --host=$WAITFORIT_HOST --port=$WAITFORIT_PORT --timeout=$WAITFORIT_TIMEOUT &
    fi
    WAITFORIT_PID=$!
    trap "kill -INT -$WAITFORIT_PID" INT
    wait $WAITFORIT_PID
    WAITFORIT_RESULT=$?
    if [[ $WAITFORIT_RESULT -ne 0 ]]; then
        echoerr "$WAITFORIT_cmdname: timeout occurred after waiting $WAITFORIT_TIMEOUT seconds for $WAITFORIT_HOST:$WAITFORIT_PORT"
    fi
    return $WAITFORIT_RESULT
}
# process arguments
while [[ $# -gt 0 ]]
do
    case "$1" in
        *:* )
        WAITFORIT_hostport=(${1//:/ })
        WAITFORIT_HOST=${WAITFORIT_hostport[0]}
        WAITFORIT_PORT=${WAITFORIT_hostport[1]}
        shift 1
        ;;
        --child)
        WAITFORIT_CHILD=1
        shift 1
        ;;
        -q | --quiet)
        WAITFORIT_QUIET=1
        shift 1
        ;;
        -s | --strict)
        WAITFORIT_STRICT=1
        shift 1
        ;;
        -h)
        WAITFORIT_HOST="$2"
        if [[ $WAITFORIT_HOST == "" ]]; then break; fi
        shift 2
        ;;
        --host=*)
        WAITFORIT_HOST="${1#*=}"
        shift 1
        ;;
        -p)
        WAITFORIT_PORT="$2"
        if [[ $WAITFORIT_PORT == "" ]]; then break; fi
        shift 2
        ;;
        --port=*)
        WAITFORIT_PORT="${1#*=}"
        shift 1
        ;;
        -t)
        WAITFORIT_TIMEOUT="$2"
        if [[ $WAITFORIT_TIMEOUT == "" ]]; then break; fi
        shift 2
        ;;
        --timeout=*)
        WAITFORIT_TIMEOUT="${1#*=}"
        shift 1
        ;;
        --)
        shift
        WAITFORIT_CLI=("$@")
        break
        ;;
        --help)
        usage
        ;;
        *)
        echoerr "Unknown argument: $1"
        usage
        ;;
    esac
done
if [[ "$WAITFORIT_HOST" == "" || "$WAITFORIT_PORT" == "" ]]; then
    echoerr "Error: you need to provide a host and port to test."
    usage
fi
WAITFORIT_TIMEOUT=${WAITFORIT_TIMEOUT:-15}
WAITFORIT_STRICT=${WAITFORIT_STRICT:-0}
WAITFORIT_CHILD=${WAITFORIT_CHILD:-0}
WAITFORIT_QUIET=${WAITFORIT_QUIET:-0}
# Check to see if timeout is from busybox?
WAITFORIT_TIMEOUT_PATH=$(type -p timeout)
WAITFORIT_TIMEOUT_PATH=$(realpath $WAITFORIT_TIMEOUT_PATH 2>/dev/null || readlink -f $WAITFORIT_TIMEOUT_PATH)
WAITFORIT_BUSYTIMEFLAG=""
if [[ $WAITFORIT_TIMEOUT_PATH =~ "busybox" ]]; then
    WAITFORIT_ISBUSY=1
    # Check if busybox timeout uses -t flag
    # (recent Alpine versions don't support -t anymore)
    if timeout &>/dev/stdout | grep -q -e '-t '; then
        WAITFORIT_BUSYTIMEFLAG="-t"
    fi
else
    WAITFORIT_ISBUSY=0
fi
if [[ $WAITFORIT_CHILD -gt 0 ]]; then
    wait_for
    WAITFORIT_RESULT=$?
    exit $WAITFORIT_RESULT
else
    if [[ $WAITFORIT_TIMEOUT -gt 0 ]]; then
        wait_for_wrapper
        WAITFORIT_RESULT=$?
    else
        wait_for
        WAITFORIT_RESULT=$?
    fi
fi
if [[ $WAITFORIT_CLI != "" ]]; then
    if [[ $WAITFORIT_RESULT -ne 0 && $WAITFORIT_STRICT -eq 1 ]]; then
        echoerr "$WAITFORIT_cmdname: strict mode, refusing to execute subprocess"
        exit $WAITFORIT_RESULT
    fi
    exec "${WAITFORIT_CLI[@]}"
else
    exit $WAITFORIT_RESULT
fi
</file>

<file path="docker-compose.yml">
version: '3.8'
services:
  caddy:
    image: caddy:latest
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./caddy/Caddyfile:/etc/caddy/Caddyfile
      - caddy_data:/data
      - caddy_config:/config
    depends_on:
      - api
  api:
    build:
      context: .
      dockerfile: Dockerfile
    restart: unless-stopped
    expose:
      - "8080"
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - ConnectionStrings__DefaultConnection=Host=db;Database=pawmatch;Username=postgres;Password=mandaci12
      - GoogleDrive__CredentialsPath=/app/credentials/credentials.json
    volumes:
      - ./credentials:/app/credentials
    depends_on:
      - db
    command: ["/wait-for-it.sh", "db:5432", "--", "dotnet", "PawMatch.Api.dll"]
  db:
    image: postgres:15
    restart: unless-stopped
    environment:
      - POSTGRES_DB=pawmatch
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=mandaci12
    volumes:
      - db-data:/var/lib/postgresql/data
    ports:
      - "5433:5432"
volumes:
  db-data:
  caddy_data:
  caddy_config:
</file>

<file path="PawMatch.Api/Program.cs">
using Microsoft.EntityFrameworkCore;
using PawMatch.Infrastructure;
using PawMatch.Infrastructure.Interfaces;
using PawMatch.Infrastructure.Repositories;
using PawMatch.Infrastructure.Providers;
using PawMatch.Application.Interfaces;
using PawMatch.Application.Services;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using Microsoft.OpenApi.Models;
namespace PawMatch.Api;
public class Program
{
    public static void Main(string[] args)
    {
var builder = WebApplication.CreateBuilder(args);
builder.WebHost.UseUrls("http://0.0.0.0:8080");
// Add services to the container.
builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "PawMatch API", Version = "v1" });
    // JWT Bearer Auth için:
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Description = "JWT Authorization header using the Bearer scheme. Example: \"Bearer {token}\"",
        Name = "Authorization",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.Http,
        Scheme = "bearer",
        BearerFormat = "JWT"
    });
    c.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            new string[] {}
        }
    });
});
// DbContext
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));
// DI
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddSingleton<IJwtProvider, JwtProvider>();
builder.Services.AddScoped<IMatchService, MatchService>();
builder.Services.AddScoped<IDiscoverService, DiscoverService>();
builder.Services.AddScoped<IUserSwipeRepository, UserSwipeRepository>();
builder.Services.AddSingleton<IStorageProvider, GoogleDriveStorageProvider>();
builder.Services.AddScoped<IPhotoService, PhotoService>();
builder.Services.AddScoped<IMessageRepository, MessageRepository>();
builder.Services.AddScoped<IMessageService, MessageService>();
builder.Services.AddScoped<IRealtimeNotificationService, PawMatch.Api.Services.SignalRNotificationService>();
builder.Services.AddScoped<IMatchRepository, MatchRepository>();
builder.Services.AddSignalR();
// CORS Policy ekle
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowWebApp",
        policy => policy
            .AllowAnyOrigin()
            .AllowAnyHeader()
            .AllowAnyMethod()
    );
});
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = false,
            ValidateAudience = false,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(System.Text.Encoding.ASCII.GetBytes("super-secret-key-which-is-at-least-32-chars!"))
        };
        options.Events = new JwtBearerEvents
        {
            OnMessageReceived = context =>
            {
                var accessToken = context.Request.Query["access_token"];
                // Eğer istek SignalR hub'a ise, token'ı query string'den al
                var path = context.HttpContext.Request.Path;
                if (!string.IsNullOrEmpty(accessToken) && path.StartsWithSegments("/chatHub"))
                {
                    context.Token = accessToken;
                }
                return Task.CompletedTask;
            }
        };
    });
var app = builder.Build();
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
// CORS middleware'i authentication'dan önce ekle
app.UseCors("AllowWebApp");
//app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
app.MapHub<PawMatch.Api.Hubs.ChatHub>("/chatHub");
// Sadece development ortamında otomatik migration uygula
if (app.Environment.IsDevelopment() && !app.Environment.IsEnvironment("Testing"))
{
    using (var scope = app.Services.CreateScope())
    {
        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();
        db.Database.Migrate();
        PawMatch.Infrastructure.AppDbContext.AppDbContextSeed.Seed(db);
    }
}
app.Run();
    }
}
</file>

</files>
