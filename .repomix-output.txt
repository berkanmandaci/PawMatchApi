This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
api/obj/PawMatch.Infrastructure.EntityFrameworkCore.targets
ApiDoc.md
DevLog.md
docker-compose.yml
Dockerfile
ef_core_migration_guide.md
iyileÅŸtirme.md
matchandmessagesfeaturedoc.md
matchandmessagesfeaturetodo.md
messagesystem.md
PawMatch.Api/.gitignore
PawMatch.Api/appsettings.json
PawMatch.Api/Controllers/BaseController.cs
PawMatch.Api/Controllers/MatchesController.cs
PawMatch.Api/Controllers/MessagesController.cs
PawMatch.Api/Controllers/PhotosController.cs
PawMatch.Api/Controllers/UsersController.cs
PawMatch.Api/Controllers/WeatherForecastController.cs
PawMatch.Api/Hubs/ChatHub.cs
PawMatch.Api/PawMatch.Api.csproj
PawMatch.Api/PawMatch.Api.http
PawMatch.Api/Program.cs
PawMatch.Api/Properties/launchSettings.json
PawMatch.Api/Services/SignalRNotificationService.cs
PawMatch.Api/WeatherForecast.cs
PawMatch.Application/.gitignore
PawMatch.Application/Class1.cs
PawMatch.Application/DTOs/DiscoverUserPetDto.cs
PawMatch.Application/DTOs/MatchActionDto.cs
PawMatch.Application/DTOs/MatchDto.cs
PawMatch.Application/DTOs/MessageDto.cs
PawMatch.Application/DTOs/PetDto.cs
PawMatch.Application/DTOs/PhotoDto.cs
PawMatch.Application/DTOs/PhotoUploadDto.cs
PawMatch.Application/DTOs/UpdateProfileDto.cs
PawMatch.Application/DTOs/UserAuthResponseDto.cs
PawMatch.Application/DTOs/UserBaseDto.cs
PawMatch.Application/DTOs/UserLoginDto.cs
PawMatch.Application/DTOs/UserPublicDto.cs
PawMatch.Application/DTOs/UserRegisterDto.cs
PawMatch.Application/Interfaces/IDiscoverService.cs
PawMatch.Application/Interfaces/IMatchService.cs
PawMatch.Application/Interfaces/IMessageService.cs
PawMatch.Application/Interfaces/IPhotoService.cs
PawMatch.Application/Interfaces/IRealtimeNotificationService.cs
PawMatch.Application/Interfaces/IUserService.cs
PawMatch.Application/PawMatch.Application.csproj
PawMatch.Application/Services/DiscoverService.cs
PawMatch.Application/Services/MatchService.cs
PawMatch.Application/Services/MessageService.cs
PawMatch.Application/Services/PhotoService.cs
PawMatch.Application/Services/UserService.cs
PawMatch.Domain/.gitignore
PawMatch.Domain/Class1.cs
PawMatch.Domain/Match.cs
PawMatch.Domain/Message.cs
PawMatch.Domain/PawMatch.Domain.csproj
PawMatch.Domain/Pet.cs
PawMatch.Domain/Photo.cs
PawMatch.Domain/User.cs
PawMatch.Domain/UserSwipe.cs
PawMatch.Infrastructure/.gitignore
PawMatch.Infrastructure/AppDbContext.cs
PawMatch.Infrastructure/Class1.cs
PawMatch.Infrastructure/Interfaces/IJwtProvider.cs
PawMatch.Infrastructure/Interfaces/IMatchRepository.cs
PawMatch.Infrastructure/Interfaces/IMessageRepository.cs
PawMatch.Infrastructure/Interfaces/IStorageProvider.cs
PawMatch.Infrastructure/Interfaces/IUserRepository.cs
PawMatch.Infrastructure/Interfaces/IUserSwipeRepository.cs
PawMatch.Infrastructure/Migrations/20250617224635_InitialCreate.cs
PawMatch.Infrastructure/Migrations/20250617224635_InitialCreate.Designer.cs
PawMatch.Infrastructure/PawMatch.Infrastructure.csproj
PawMatch.Infrastructure/Providers/GoogleDriveStorageProvider.cs
PawMatch.Infrastructure/Providers/JwtProvider.cs
PawMatch.Infrastructure/Repositories/MatchRepository.cs
PawMatch.Infrastructure/Repositories/MessageRepository.cs
PawMatch.Infrastructure/Repositories/UserRepository.cs
PawMatch.Infrastructure/Repositories/UserSwipeRepository.cs
PawMatch.sln
PawMatch.sln.DotSettings.user
PawMatch.Tests/.gitignore
PawMatch.Tests/CustomWebApplicationFactory.cs
PawMatch.Tests/DiscoverServiceTests.cs
PawMatch.Tests/MatchesControllerTests.cs
PawMatch.Tests/PawMatch.Tests.csproj
PawMatch.Tests/PhotosControllerTests.cs
PawMatch.Tests/SignalRHubTests.cs
PawMatch.Tests/UsersControllerTests.cs
PawMatch.Tests/UserSwipes.csv
wait-for-it.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="iyileÅŸtirme.md">
1. Eksik ve Yetersiz Ä°ÅŸ MantÄ±ÄŸÄ± ImplementasyonlarÄ± (TODO'lar ve Yer Tutucular):
MatchService.cs - LikeOrPassAsync metodu: Bu metot ÅŸu anda sadece statik bir MatchResultDto dÃ¶ndÃ¼rÃ¼yor ve iÃ§inde aÃ§Ä±kÃ§a bir TODO: GerÃ§ek eÅŸleÅŸme mantÄ±ÄŸÄ± eklenecek notu bulunuyor. Bu, eÅŸleÅŸme mekanizmasÄ±nÄ±n temel iÅŸ mantÄ±ÄŸÄ±nÄ±n henÃ¼z tamamlanmadÄ±ÄŸÄ± anlamÄ±na geliyor.
DiscoverService.cs - GetDiscoveredUserIdsAsync metodu: Bu metot, keÅŸif algoritmasÄ± iÃ§in bir yer tutucu niteliÄŸinde. Åu anda sadece mevcut kullanÄ±cÄ± dÄ±ÅŸÄ±ndaki ilk 5 kullanÄ±cÄ± ID'sini dÃ¶ndÃ¼rÃ¼yor. Ä°Ã§indeki yorumlar da (Bu ÅŸimdilik sahte bir keÅŸif algoritmasÄ±dÄ±r.) gerÃ§ek bir keÅŸif mantÄ±ÄŸÄ±nÄ±n (konum, tercihler vb. temel alarak) henÃ¼z uygulanmadÄ±ÄŸÄ±nÄ± gÃ¶steriyor. MatchesController'daki keÅŸif algoritmasÄ±nÄ±n burada uygulanmasÄ± gerektiÄŸi belirtilmiÅŸ.
PhotosController.cs - UploadPetPhoto'daki Pet Sahiplik KontrolÃ¼: Bu endpoint'te evcil hayvanÄ±n gerÃ§ekten fotoÄŸrafÄ± yÃ¼kleyen kullanÄ±cÄ±ya ait olup olmadÄ±ÄŸÄ±na dair bir kontrol eksikliÄŸi var. Kodda // Dummy sahiplik kontrolÃ¼ (gerÃ§ek uygulamada DB'den kontrol edilmeli) ÅŸeklinde bir yorum ve yorum satÄ±rÄ± olarak bÄ±rakÄ±lmÄ±ÅŸ bir _petService.UserOwnsPet Ã§aÄŸrÄ±sÄ± bulunuyor. Bu, Ã¶nemli bir gÃ¼venlik aÃ§Ä±ÄŸÄ±dÄ±r ve bu kontrolÃ¼n acilen gerÃ§ek bir doÄŸrulama ile deÄŸiÅŸtirilmesi gerekmektedir.
2. GÃ¼venlik ve YapÄ±landÄ±rma Eksiklikleri/Ä°yileÅŸtirme AlanlarÄ±:
JwtProvider.cs - Sabit KodlanmÄ±ÅŸ JWT Gizli AnahtarÄ±: JWT token'larÄ±nÄ±n oluÅŸturulduÄŸu JwtProvider.cs dosyasÄ±nda, gizli anahtar ("super-secret-key-which-is-at-least-32-chars!") doÄŸrudan kod iÃ§ine yazÄ±lmÄ±ÅŸtÄ±r. Bu, bir gÃ¼venlik zafiyetidir. Bu anahtarÄ±n appsettings.json gibi bir yapÄ±landÄ±rma dosyasÄ±ndan veya ortam deÄŸiÅŸkenlerinden okunacak ÅŸekilde gÃ¼ncellenmesi gerekmektedir. Program.cs'te de aynÄ± anahtar kullanÄ±lÄ±yor, bu da merkezi bir yapÄ±landÄ±rmanÄ±n Ã¶nemini vurguluyor.
GoogleDriveStorageProvider.cs - Kimlik Bilgileri Yolu YÃ¶netimi: Google Drive kimlik bilgileri iÃ§in varsayÄ±lan yol "api/credentials/credentials.json" olarak sabit kodlanmÄ±ÅŸ. Ortam deÄŸiÅŸkeninden okunmasÄ± tercih edilse de, bu dosyanÄ±n hassas veri iÃ§erebileceÄŸi ve .gitignore dosyasÄ± ile kesinlikle sÃ¼rÃ¼m kontrol sisteminden dÄ±ÅŸlanmasÄ± gerektiÄŸi unutulmamalÄ±dÄ±r. Genellikle, hassas kimlik bilgisi dosyalarÄ±nÄ±n bir volume Ã¼zerinden mount edilmesi en iyi yaklaÅŸÄ±mdÄ±r, ki docker-compose.yml bunu zaten yapÄ±yor. Ancak geliÅŸtirme ortamÄ±nda sabit kodlanmÄ±ÅŸ yolun kullanÄ±lmasÄ± durumunda dikkatli olunmalÄ±dÄ±r.
docker-compose.yml - ASPNETCORE_ENVIRONMENT=Production Ortam DeÄŸiÅŸkeni: docker-compose.yml dosyasÄ±nda app servisi iÃ§in ASPNETCORE_ENVIRONMENT=Production olarak ayarlanmÄ±ÅŸ. Ancak Program.cs'te veritabanÄ± migrasyon ve seed iÅŸlemleri app.Environment.IsDevelopment() && !app.Environment.IsEnvironment("Testing") koÅŸuluna baÄŸlÄ±. EÄŸer bu docker-compose.yml geliÅŸtirme iÃ§in kullanÄ±lÄ±yorsa, ortam deÄŸiÅŸkeni Development olarak ayarlanmalÄ± veya migrasyon ve seed iÅŸlemleri konteynerin baÅŸlangÄ±cÄ±nda ayrÄ± bir script (Ã¶rneÄŸin wait-for-it.sh'in ardÄ±ndan) ile yÃ¶netilmelidir. Aksi takdirde, geliÅŸtirme ortamÄ±nda veritabanÄ± otomatik olarak oluÅŸturulup seedlenmeyecektir.
PhotosController.cs - GetPhoto iÃ§in Content-Type Belirleme: GetPhoto endpoint'inde dÃ¶nen fotoÄŸraf akÄ±ÅŸÄ±nÄ±n Content-Type'Ä± image/jpeg olarak sabit kodlanmÄ±ÅŸtÄ±r. PhotoDto'da ContentType alanÄ± olmasÄ±na raÄŸmen, bu deÄŸer veritabanÄ±ndan Ã§ekilip yanÄ±ta yansÄ±tÄ±lmÄ±yor. Bu kÃ¼Ã§Ã¼k bir kusurdur ve dinamik olarak belirlenmesi daha doÄŸru olacaktÄ±r.
3. Test AltyapÄ±sÄ±nda Potansiyel GeliÅŸtirmeler (Genel Ä°yileÅŸtirme):
Hata Senaryosu Testlerinin KapsamÄ±: UsersControllerTests.cs ve PhotosControllerTests.cs genellikle baÅŸarÄ±lÄ± senaryolarÄ± kapsÄ±yor. GeÃ§ersiz girdiler (validation hatalarÄ±), yetkilendirme hatalarÄ± (geÃ§ersiz token), bulunamayan kaynaklar (404 Not Found) ve sunucu tarafÄ± hatalarÄ± (500 Internal Server Error) gibi olumsuz senaryolar iÃ§in daha fazla test eklemek, API'nin saÄŸlamlÄ±ÄŸÄ±nÄ± artÄ±racaktÄ±r.
</file>

<file path=".gitignore">
.idea/
.env
</file>

<file path="api/obj/PawMatch.Infrastructure.EntityFrameworkCore.targets">
<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="GetEFProjectMetadata">
    <MSBuild Condition=" '$(TargetFramework)' == '' "
             Projects="$(MSBuildProjectFile)"
             Targets="GetEFProjectMetadata"
             Properties="TargetFramework=$(TargetFrameworks.Split(';')[0]);EFProjectMetadataFile=$(EFProjectMetadataFile)" />
    <ItemGroup Condition=" '$(TargetFramework)' != '' ">
      <EFProjectMetadata Include="AssemblyName: $(AssemblyName)" />
      <EFProjectMetadata Include="Language: $(Language)" />
      <EFProjectMetadata Include="OutputPath: $(OutputPath)" />
      <EFProjectMetadata Include="Platform: $(Platform)" />
      <EFProjectMetadata Include="PlatformTarget: $(PlatformTarget)" />
      <EFProjectMetadata Include="ProjectAssetsFile: $(ProjectAssetsFile)" />
      <EFProjectMetadata Include="ProjectDir: $(ProjectDir)" />
      <EFProjectMetadata Include="RootNamespace: $(RootNamespace)" />
      <EFProjectMetadata Include="RuntimeFrameworkVersion: $(RuntimeFrameworkVersion)" />
      <EFProjectMetadata Include="TargetFileName: $(TargetFileName)" />
      <EFProjectMetadata Include="TargetFrameworkMoniker: $(TargetFrameworkMoniker)" />
      <EFProjectMetadata Include="Nullable: $(Nullable)" />
      <EFProjectMetadata Include="TargetFramework: $(TargetFramework)" />
      <EFProjectMetadata Include="TargetPlatformIdentifier: $(TargetPlatformIdentifier)" />
    </ItemGroup>
    <WriteLinesToFile Condition=" '$(TargetFramework)' != '' "
                      File="$(EFProjectMetadataFile)"
                      Lines="@(EFProjectMetadata)" />
  </Target>
</Project>
</file>

<file path="ApiDoc.md">
# PawMatch Backend API DokÃ¼mantasyonu

Bu dokÃ¼man, PawMatch uygulamasÄ±nÄ±n backend API'lerini ve uyulmasÄ± gereken temel kurallarÄ± Ã¶zetler.

## 1. Genel Kurallar

*   **Mimari**: KatmanlÄ± mimari (.NET 8+ MVC - Controller-Based API) kullanÄ±lmÄ±ÅŸtÄ±r. Ä°ÅŸ mantÄ±ÄŸÄ± servis katmanÄ±nda (`PawMatch.Application.Services`), veri eriÅŸimi repository deseniyle (`PawMatch.Infrastructure.Repositories`) yÃ¶netilir.
*   **SOLID Prensipleri**: Kod genel olarak SOLID prensiplerine uygun tasarlanmÄ±ÅŸtÄ±r, Ã¶zellikle baÄŸÄ±mlÄ±lÄ±klarÄ±n arayÃ¼zler Ã¼zerinden enjekte edilmesi (`IUserService`, `IStorageProvider` vb.) dikkat Ã§eker.
*   **RESTful Prensipler**: API endpoint'leri RESTful prensiplere uygun olarak HTTP metotlarÄ± (GET, POST, PATCH, DELETE) kullanÄ±r.
*   **API Versiyonlama**: TÃ¼m API endpoint'leri `/api/v1/` Ã¶n eki ile versiyonlanmÄ±ÅŸtÄ±r.
*   **YanÄ±t FormatÄ±**: BaÅŸarÄ±lÄ± API yanÄ±tlarÄ± `{ "data": {}, "status": "success", "error": null }` formatÄ±ndadÄ±r. Hata yanÄ±tlarÄ± genellikle `{ "status": "error", "error": "mesaj" }` formatÄ±nÄ± kullanÄ±r.
*   **Kimlik DoÄŸrulama**: Ã‡oÄŸu endpoint JWT (JSON Web Token) ile korunmaktadÄ±r. KullanÄ±cÄ± kimliÄŸi doÄŸrulama iÃ§in `[Authorize]` niteliÄŸi kullanÄ±lÄ±r.
*   **GÃ¼venlik**:
    *   Åifreler BCrypt ile hash'lenir.
    *   Google Drive'da depolanan fotoÄŸraflar Ã¶zeldir (private) ve doÄŸrudan herkese aÃ§Ä±k baÄŸlantÄ±lar paylaÅŸÄ±lmaz.
    *   FotoÄŸraf yÃ¼klemeleri iÃ§in dosya tipi (JPEG/PNG) ve boyutu (maksimum 5 MB) doÄŸrulamasÄ± yapÄ±lÄ±r.
    *   FotoÄŸraf gÃ¶rÃ¼ntÃ¼leme iÃ§in geliÅŸmiÅŸ yetkilendirme kurallarÄ± uygulanÄ±r (sadece fotoÄŸrafÄ±n sahibi, evcil hayvanÄ±n sahibi veya keÅŸif listesindeki kullanÄ±cÄ±lar eriÅŸebilir).
*   **VeritabanÄ±**: PostgreSQL, Entity Framework Core (Code First) ile kullanÄ±lÄ±r. Testler iÃ§in in-memory veritabanÄ± kullanÄ±lÄ±r.
*   **KonteynerleÅŸtirme**: Uygulama Docker kullanÄ±larak konteynerleÅŸtirilmiÅŸtir. `docker-compose.yml` ile uygulama ve PostgreSQL veritabanÄ± servisleri birlikte yÃ¶netilir.

## 2. API Endpoint'leri

### 2.1. Kimlik DoÄŸrulama ve KullanÄ±cÄ± YÃ¶netimi (`/api/v1/users`)

*   **KullanÄ±cÄ± KaydÄ±**
    *   `POST /api/v1/users/register`
    *   AÃ§Ä±klama: Yeni bir kullanÄ±cÄ± hesabÄ± oluÅŸturur ve baÅŸarÄ±lÄ± olursa JWT token dÃ¶ndÃ¼rÃ¼r.
    *   Girdi DTO: `UserRegisterDto` (name, email, password)
    *   Ã‡Ä±ktÄ± DTO: `UserAuthResponseDto` (user: UserDto, token)

*   **KullanÄ±cÄ± GiriÅŸi**
    *   `POST /api/v1/users/login`
    *   AÃ§Ä±klama: Mevcut bir kullanÄ±cÄ±nÄ±n kimlik bilgileriyle giriÅŸ yapar ve JWT token dÃ¶ndÃ¼rÃ¼r.
    *   Girdi DTO: `UserLoginDto` (email, password)
    *   Ã‡Ä±ktÄ± DTO: `UserAuthResponseDto` (user: UserDto, token)

*   **KullanÄ±cÄ± Profilini GÃ¼ncelleme**
    *   `PATCH /api/v1/users/profile`
    *   AÃ§Ä±klama: KimliÄŸi doÄŸrulanmÄ±ÅŸ kullanÄ±cÄ±nÄ±n profil bilgilerini (adÄ±, biyografisi, evcil hayvanÄ± olup olmadÄ±ÄŸÄ±) gÃ¼nceller.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   Girdi DTO: `UpdateProfileDto` (name, bio, hasPet)
    *   Ã‡Ä±ktÄ± DTO: `UserAuthResponseDto` (user: UserDto, token)

*   **KullanÄ±cÄ± HesabÄ±nÄ± Silme**
    *   `DELETE /api/v1/users/me`
    *   AÃ§Ä±klama: KimliÄŸi doÄŸrulanmÄ±ÅŸ kullanÄ±cÄ±nÄ±n hesabÄ±nÄ± ve iliÅŸkili tÃ¼m verilerini (evcil hayvanlar, fotoÄŸraflar) siler.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   Girdi: Yok
    *   Ã‡Ä±ktÄ±: BaÅŸarÄ±lÄ± yanÄ±t (`status: "success"`)

*   **KullanÄ±cÄ± Profil Bilgilerini Getirme**
    *   `GET /api/v1/users/me`
    *   AÃ§Ä±klama: KimliÄŸi doÄŸrulanmÄ±ÅŸ kullanÄ±cÄ±nÄ±n profil bilgilerini dÃ¶ndÃ¼rÃ¼r.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   Girdi: Yok
    *   Ã‡Ä±ktÄ± DTO: `UserDto` (id, name, email, bio, hasPet, hasProfile, PhotoIds)

### 2.2. EÅŸleÅŸme ve KeÅŸif MekanizmasÄ± (`/api/v1/matches`)

*   **KullanÄ±cÄ±/Pet KartlarÄ±nÄ± KeÅŸfetme**
    *   `GET /api/v1/matches/discover`
    *   AÃ§Ä±klama: KeÅŸif iÃ§in uygun kullanÄ±cÄ± ve evcil hayvan kartlarÄ±nÄ± listeler. Åu anda giriÅŸ yapan kullanÄ±cÄ± dÄ±ÅŸÄ±ndaki tÃ¼m kullanÄ±cÄ±larÄ± basitÃ§e listeler.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   Sorgu Parametreleri: `maxDistanceKm` (int, opsiyonel), `offset` (int, opsiyonel), `limit` (int, opsiyonel)
    *   Ã‡Ä±ktÄ± DTO: `List<DiscoverUserPetDto>` (user: DiscoverUserDto, pet: DiscoverPetDto)

*   **BeÄŸenme/GeÃ§me Ä°ÅŸlemi**
    *   `POST /api/v1/matches`
    *   AÃ§Ä±klama: Bir kullanÄ±cÄ±ya yÃ¶nelik beÄŸenme (like) veya geÃ§me (pass) iÅŸlemini gerÃ§ekleÅŸtirir. EÅŸleÅŸme mantÄ±ÄŸÄ± henÃ¼z tamamlanmamÄ±ÅŸtÄ±r (TODO).
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   Girdi DTO: `MatchActionDto` (user1Id, user2Id, liked)
    *   Ã‡Ä±ktÄ± DTO: `MatchResultDto` (matchId, confirmed)

### 2.3. FotoÄŸraf YÃ¶netimi (`/api/v1/photos`)

*   **KullanÄ±cÄ± Profil FotoÄŸrafÄ± YÃ¼kleme**
    *   `POST /api/v1/photos/user`
    *   AÃ§Ä±klama: KimliÄŸi doÄŸrulanmÄ±ÅŸ kullanÄ±cÄ±ya bir fotoÄŸraf yÃ¼kler.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   Girdi: Multipart form-data (`IFormFile` - JPEG/PNG, maks. 5 MB)
    *   Ã‡Ä±ktÄ± DTO: `PhotoDto` (id, fileName, contentType, googleDriveFileId, uploadDate, userId, petId)

*   **Pet FotoÄŸrafÄ± YÃ¼kleme**
    *   `POST /api/v1/users/pets/{petId}/photos`
    *   AÃ§Ä±klama: Belirtilen evcil hayvana bir fotoÄŸraf yÃ¼kler.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   URL Parametreleri: `petId` (int)
    *   Girdi: Multipart form-data (`IFormFile` - JPEG/PNG, maks. 5 MB)
    *   Ã‡Ä±ktÄ± DTO: `PhotoDto` (id, fileName, contentType, googleDriveFileId, uploadDate, userId, petId)

*   **FotoÄŸraf GÃ¶rÃ¼ntÃ¼leme**
    *   `GET /api/v1/photos/{id}`
    *   AÃ§Ä±klama: Belirtilen Google Drive Dosya KimliÄŸine (`id`) sahip fotoÄŸrafÄ±n akÄ±ÅŸÄ±nÄ± dÃ¶ndÃ¼rÃ¼r. Yetkilendirme kurallarÄ± uygulanÄ±r.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   URL Parametreleri: `id` (string - Google Drive File ID)
    *   Ã‡Ä±ktÄ±: FotoÄŸraf akÄ±ÅŸÄ± (`FileStreamResult`)

*   **FotoÄŸraf Silme**
    *   `DELETE /api/v1/photos/{id}`
    *   AÃ§Ä±klama: Belirtilen Google Drive Dosya KimliÄŸine (`id`) sahip fotoÄŸrafÄ± hem Google Drive'dan hem de veritabanÄ±ndan siler.
    *   Yetkilendirme: Gerekli (`[Authorize]`)
    *   URL Parametreleri: `id` (string - Google Drive File ID)
    *   Ã‡Ä±ktÄ±: BaÅŸarÄ±lÄ± yanÄ±t (`status: "success"`)

## 3. Repository KatmanÄ± GÃ¼ncellemesi

- EÅŸleÅŸme iÅŸlemleri iÃ§in IMatchRepository arayÃ¼zÃ¼ ve MatchRepository implementasyonu eklendi.
- MatchService, eÅŸleÅŸme iÅŸlemlerinde doÄŸrudan DbContext yerine MatchRepository kullanÄ±yor.
- Program.cs'de IMatchRepository iÃ§in DI kaydÄ± yapÄ±ldÄ±.
- MesajlaÅŸma ve eÅŸleÅŸme endpointleri iÃ§in repository altyapÄ±sÄ± tamamlandÄ±.
</file>

<file path="DevLog.md">
# 2024-06-15 GeliÅŸtirme GÃ¼nlÃ¼ÄŸÃ¼

- JWT authentication gerÃ§ek anahtar ile uygulandÄ±, demo iÃ§in 32+ karakterlik key kullanÄ±ldÄ±
- Swagger/OpenAPI aÃ§Ä±klamalarÄ± login, register, profil ve matches endpointlerine eklendi
- Dummy user, pet ve photo verileri iÃ§in seed iÅŸlemi eklendi (development ortamÄ±nda otomatik)
- /api/v1/matches/discover ve /api/v1/matches (like/pass) endpointleri eklendi, JWT ile korumalÄ±
- Discover endpointi artÄ±k veritabanÄ±ndaki tÃ¼m kullanÄ±cÄ±larÄ± (giriÅŸ yapan hariÃ§), pet ve fotoÄŸraflarÄ±yla dÃ¶ndÃ¼rÃ¼yor
- Dockerfile ve docker-compose ile wait-for-it.sh entegrasyonu yapÄ±ldÄ±, migration/seed iÅŸlemleri sorunsuz baÅŸlatÄ±lÄ±yor
- JWT Ã¼retimi ve doÄŸrulamasÄ± iÃ§in gerekli NuGet paketleri eklendi
- HatalÄ± token, kÄ±sa anahtar, vs. gibi build ve runtime hatalarÄ± giderildi
- Kodda eksik kalan mock/boÅŸ metotlar gerÃ§ek veritabanÄ± sorgularÄ± ile gÃ¼ncellendi

# 2024-06-14 GeliÅŸtirme GÃ¼nlÃ¼ÄŸÃ¼

- Proje iskeleti oluÅŸturuldu (Api, Application, Domain, Infrastructure, Tests katmanlarÄ±)
- Dockerfile ve docker-compose.yml hazÄ±rlandÄ±, PostgreSQL entegrasyonu saÄŸlandÄ±
- Gerekli NuGet paketleri ve projeler arasÄ± referanslar eklendi
- User, Pet, Photo entity'leri ve DbContext yazÄ±ldÄ±
- KullanÄ±cÄ± kayÄ±t ve login iÃ§in DTO, servis, repository, controller ve JWT altyapÄ±sÄ± kuruldu
- EF Core migration ve database update iÅŸlemleri iÃ§in rehberlik edildi
- Build ve migration hatalarÄ± giderildi (referans, namespace, connection string, tablo eksikliÄŸi)
- Proje baÅŸarÄ±yla ayaÄŸa kaldÄ±rÄ±ldÄ± ve temel API endpointleri Ã§alÄ±ÅŸÄ±r hale getirildi

# 2024-06-15 GeliÅŸtirme GÃ¼nlÃ¼ÄŸÃ¼ (DevamÄ±)

- JWT'den userId Ã§ekme iÅŸlemleri iÃ§in merkezi `BaseController` oluÅŸturuldu.
- `UsersController`, `PhotosController`, `MatchesController` ve `WeatherForecastController` artÄ±k `BaseController`'dan miras alÄ±yor ve `GetUserIdFromClaims()` fonksiyonunu kullanÄ±yor.
- `GetUserIdFromClaims()` fonksiyonundaki hatalÄ± claim adÄ± (`"nameid"` yerine `ClaimTypes.NameIdentifier`) dÃ¼zeltildi, bÃ¶ylece kullanÄ±cÄ± kimlik doÄŸrulama sorunlarÄ± giderildi.
- FotoÄŸraf yÃ¼kleme endpointleri ve akÄ±ÅŸlarÄ± tamamen test edildi ve baÅŸarÄ±lÄ± ÅŸekilde Ã§alÄ±ÅŸÄ±yor (Ã¶rn. `POST /api/v1/photos/user`).
- `api/photofeature.md` ve `app/photofeature.md` dosyalarÄ± gÃ¼ncel backend ve frontend implementasyonlarÄ±na uygun ÅŸekilde revize edildi, hatalÄ± endpoint isimleri ve akÄ±ÅŸlar dÃ¼zeltildi.
- `docs/PawMatch Backend Guidelines.markdown` dokÃ¼manÄ± gÃ¼ncel backend mimarisi ve endpoint detaylarÄ±na gÃ¶re revize edildi, eski ve hatalÄ± bilgiler temizlendi.
- `IDiscoverService` ve `DiscoverService` eklendi, DiscoverService ÅŸimdilik basit bir keÅŸif listesi saÄŸlÄ±yor.
- FotoÄŸraf gÃ¶rÃ¼ntÃ¼leme endpointindeki eriÅŸim kontrolÃ¼ gÃ¼ncellendi: kullanÄ±cÄ± kendi fotoÄŸrafÄ±nÄ±, kendi evcil hayvanÄ±nÄ±n fotoÄŸrafÄ±nÄ± veya keÅŸfedilenler listesindeki bir kullanÄ±cÄ±nÄ±n fotoÄŸrafÄ±nÄ± gÃ¶rebiliyor.

# 2024-06-16 GeliÅŸtirme GÃ¼nlÃ¼ÄŸÃ¼

- KullanÄ±cÄ± kayÄ±t, giriÅŸ ve profil gÃ¼ncelleme API uÃ§ noktalarÄ± iÃ§in entegrasyon testleri eklendi.
- Test ortamÄ±nda `AppDbContext` ve `Program` sÄ±nÄ±fÄ± ile ilgili eriÅŸim ve uyumluluk sorunlarÄ± giderildi.
- KullanÄ±cÄ±nÄ±n kendi hesabÄ±nÄ± silebilmesi iÃ§in `DELETE /api/v1/users/me` uÃ§ noktasÄ± ve `UserService` iÃ§inde `DeleteUserAsync` metodu uygulandÄ±.
- Hesap silindiÄŸinde kullanÄ±cÄ±ya ve evcil hayvanlara ait fotoÄŸraflarÄ±n da silinmesi iÃ§in `IPhotoService`'e ilgili metotlar eklendi ve `UserService` iÃ§inde Ã§aÄŸrÄ±ldÄ±.
- Google Drive entegrasyonu testleri iÃ§in `IStorageProvider` arayÃ¼zÃ¼ mock'lanarak test ortamÄ± baÄŸÄ±mlÄ±lÄ±klarÄ± giderildi.
- FotoÄŸraf yÃ¼kleme testlerinde `StreamContent` iÃ§in `ContentType` baÅŸlÄ±ÄŸÄ± doÄŸru ÅŸekilde ayarlandÄ±.
- FotoÄŸraf testlerinde devam eden `FileName` boÅŸ ve `404 Not Found` hatalarÄ± Ã¼zerinde Ã§alÄ±ÅŸÄ±lmaya devam edildi.

# 2024-06-18 GeliÅŸtirme GÃ¼nlÃ¼ÄŸÃ¼

- EÅŸleÅŸme Fonksiyonu (`LikeOrPassAsync`) ve Temel DÃ¶ngÃ¼sÃ¼ UygulandÄ±:
  - `UserSwipe` modeli oluÅŸturuldu.
  - `AppDbContext`'e `DbSet<UserSwipe>` eklendi ve iliÅŸkiler yapÄ±landÄ±rÄ±ldÄ±.
  - `IUserSwipeRepository` ve `UserSwipeRepository` uygulandÄ±.
  - `IUserSwipeRepository` baÄŸÄ±mlÄ±lÄ±k enjeksiyonu iÃ§in kaydedildi.
  - `MatchService.LikeOrPassAsync` metodu, girdi doÄŸrulama, `UserSwipe` kaydÄ± oluÅŸturma, karÅŸÄ±lÄ±klÄ± beÄŸenileri kontrol ederek eÅŸleÅŸme onayÄ± ve "pas geÃ§me" eylemleri iÃ§in uygulandÄ±.
  - `appsettings.json` dosyasÄ±na `SwipeExclusionDurationDays` ayarÄ± eklendi.

- KeÅŸfetme Servisi GeliÅŸtirmeleri:
  - `IDiscoverService` arayÃ¼zÃ¼ `GetDiscoveredUserIdsAsync` metodu iÃ§in `maxDistanceKm` ve `preferredPetType` parametreleri iÃ§erecek ÅŸekilde gÃ¼ncellendi.
  - `DiscoverService.GetDiscoveredUserIdsAsync` metodu, yapÄ±landÄ±rÄ±labilir bir sÃ¼re iÃ§inde zaten kaydÄ±rÄ±lmÄ±ÅŸ kullanÄ±cÄ±larÄ± filtreleyecek ÅŸekilde gÃ¼ncellendi.

- Testler ve Hata DÃ¼zeltmeleri:
  - `MatchesController` ve `DiscoverService` iÃ§in entegrasyon testleri oluÅŸturuldu.
  - Test sÄ±nÄ±flarÄ±nda `IClassFixture` kullanÄ±mÄ± dÃ¼zeltildi (`CustomWebApplicationFactory<Program>` olarak).
  - Testler iÃ§in `CustomWebApplicationFactory` iÃ§inde `ASPNETCORE_ENVIRONMENT` ortam deÄŸiÅŸkeni "Production" olarak ayarlandÄ±.
  - `DiscoverServiceTests.cs` dosyasÄ±ndaki `IDiscoverService` bulunamadÄ± hatasÄ± giderildi.
  - `DiscoverServiceTests.cs` test izolasyonunu iyileÅŸtirmek iÃ§in doÄŸrudan in-memory veritabanÄ±na `UserSwipe` varlÄ±klarÄ± eklendi.
  - `DiscoverService.GetDiscoveredUserIdsAsync` metodundan `.Take(5)` Ã§aÄŸrÄ±sÄ± kaldÄ±rÄ±ldÄ±, bÃ¶ylece servis tÃ¼m keÅŸfedilebilir kullanÄ±cÄ±larÄ± dÃ¶ndÃ¼rdÃ¼.
  - TÃ¼m testler baÅŸarÄ±yla geÃ§ti.

- Frontend Ekibi Ä°Ã§in DokÃ¼mantasyon:
  - `app/backendTalimat.md` dosyasÄ± oluÅŸturularak `POST /api/v1/matches` ve `GET /api/v1/matches/discover` API endpointleri detaylÄ± bir ÅŸekilde belgelendi.

- YapÄ±lacaklar Listesi GÃ¼ncellemesi:
  - `api/matchandmessagesfeaturetodo.md` dosyasÄ±ndaki ilgili gÃ¶revler tamamlandÄ± olarak iÅŸaretlendi.

# 2024-06-19 GeliÅŸtirme GÃ¼nlÃ¼ÄŸÃ¼

- GerÃ§ek ZamanlÄ± Ä°letiÅŸim (SignalR) AltyapÄ±sÄ± (Backend) UygulandÄ±:
  - `PawMatch.Api` projesine `Microsoft.AspNetCore.SignalR` NuGet paketi eklendi.
  - `api/PawMatch.Api/Program.cs` dosyasÄ±nda SignalR servisleri kaydedildi ve Hub endpoint'i (`/chatHub`) yapÄ±landÄ±rÄ±ldÄ±.
  - `api/PawMatch.Api/Hubs/ChatHub.cs` adÄ±nda yeni bir SignalR Hub sÄ±nÄ±fÄ± oluÅŸturuldu. Bu Hub, `OnConnectedAsync()` ve `OnDisconnectedAsync()` metotlarÄ±nÄ± iÃ§eriyor ve kullanÄ±cÄ± ID'lerini baÄŸlantÄ± ID'leriyle iliÅŸkilendiriyor.

- EÅŸleÅŸme Bildirimleri Entegrasyonu:
  - `MatchService.cs` iÃ§ine `IHubContext<ChatHub>` baÄŸÄ±mlÄ±lÄ±ÄŸÄ± enjekte edildi.
  - `MatchService.cs` iÃ§indeki `LikeOrPassAsync` metodu, karÅŸÄ±lÄ±klÄ± bir eÅŸleÅŸme olduÄŸunda eÅŸleÅŸen her iki kullanÄ±cÄ±ya da `ChatHub` Ã¼zerinden anlÄ±k bildirim (`ReceiveMatchNotification`) gÃ¶nderecek ÅŸekilde gÃ¼ncellendi.

- MesajlaÅŸma Entegrasyonu:
  - `PawMatch.Domain/Message.cs` modeli oluÅŸturuldu (Id, SenderId, RecipientId, Content, Timestamp, IsRead).
  - `api/PawMatch.Infrastructure/AppDbContext.cs` iÃ§ine `DbSet<Message>` eklendi.
  - `api/PawMatch.Infrastructure/Interfaces/IMessageRepository.cs` arayÃ¼zÃ¼ ve `api/PawMatch.Infrastructure/Repositories/MessageRepository.cs` uygulamasÄ± oluÅŸturuldu.
  - `IMessageRepository` ve `IMessageService` baÄŸÄ±mlÄ±lÄ±k enjeksiyonu iÃ§in `api/PawMatch.Api/Program.cs`'e kaydedildi.
  - `api/PawMatch.Application/Interfaces/IMessageService.cs` arayÃ¼zÃ¼ ve `api/PawMatch.Application/Services/MessageService.cs` uygulamasÄ± oluÅŸturuldu. `MessageService` iÃ§ine `IHubContext<ChatHub>` ve `IMessageRepository` enjekte edildi.
  - `MessageService.cs` iÃ§indeki `SendMessageAsync` metodu, mesaj veritabanÄ±na kaydedildikten sonra alÄ±cÄ±ya SignalR Ã¼zerinden anlÄ±k mesaj (`ReceiveMessage`) gÃ¶nderecek ÅŸekilde uygulandÄ±.

- Kimlik DoÄŸrulama ve Yetkilendirme (SignalR):
  - `api/PawMatch.Api/Hubs/ChatHub.cs` sÄ±nÄ±fÄ±na `[Authorize]` niteliÄŸi eklendi, bÃ¶ylece Hub JWT tabanlÄ± kimlik doÄŸrulama ile gÃ¼vence altÄ±na alÄ±ndÄ±.
  - Hub metotlarÄ± iÃ§inde `Context.User.Identity.Name` veya `Context.UserIdentifier` ile kullanÄ±cÄ± ID'sine eriÅŸim saÄŸlandÄ±.

- YapÄ±lacaklar Listesi GÃ¼ncellemesi:
  - `docs/RealtimeConnectiontodo.md` dosyasÄ±ndaki ilgili gÃ¶revler tamamlandÄ± olarak iÅŸaretlendi.

- Mimari Ä°yileÅŸtirmeler ve BaÄŸÄ±mlÄ±lÄ±k Giderme (KatmanlÄ± Mimari):
  - `PawMatch.Application.Interfaces` iÃ§inde `IRealtimeNotificationService` adÄ±nda yeni bir arayÃ¼z tanÄ±mlandÄ±. Bu arayÃ¼z, gerÃ§ek zamanlÄ± bildirim gÃ¶nderme ihtiyacÄ±nÄ± soyutluyor.
  - `PawMatch.Api/Services` dizininde `SignalRNotificationService` adÄ±nda bir sÄ±nÄ±f oluÅŸturuldu. Bu sÄ±nÄ±f `IRealtimeNotificationService` arayÃ¼zÃ¼nÃ¼ implement ediyor ve `IHubContext<ChatHub>`'Ä± kullanarak SignalR'a Ã¶zel Ã§aÄŸrÄ±larÄ± yÃ¶netiyor. Bu sayede SignalR baÄŸÄ±mlÄ±lÄ±ÄŸÄ± API katmanÄ±nda kaldÄ±.
  - `MatchService.cs` ve `MessageService.cs` servislerinin constructor'larÄ± `IHubContext<ChatHub>` yerine yeni `IRealtimeNotificationService` arayÃ¼zÃ¼nÃ¼ enjekte edecek ÅŸekilde deÄŸiÅŸtirildi. Ä°lgili metodlarda da bu yeni arayÃ¼z kullanÄ±larak bildirim gÃ¶nderme iÅŸlemleri gerÃ§ekleÅŸtirildi.
  - `Program.cs`'te `IRealtimeNotificationService`'in `SignalRNotificationService` implementasyonuyla birlikte baÄŸÄ±mlÄ±lÄ±k enjeksiyonu iÃ§in kaydedildi.
  - Uygulama servislerinden gereksiz `Microsoft.AspNetCore.SignalR` `using` ifadeleri kaldÄ±rÄ±ldÄ±.

- MesajlaÅŸma Servisi (MessageService) Hata YÃ¶netimi ve Testler:
  - ArtÄ±k geÃ§ersiz alÄ±cÄ±ya veya gÃ¶nderen kullanÄ±cÄ±ya mesaj gÃ¶nderilmek istendiÄŸinde `MessageService.SendMessageAsync` metodu exception (ArgumentException) fÄ±rlatÄ±yor.
  - Bu davranÄ±ÅŸ iÃ§in birim ve entegrasyon testleri yazÄ±ldÄ±; geÃ§ersiz alÄ±cÄ± veya gÃ¶nderen durumunda hata fÄ±rlatÄ±ldÄ±ÄŸÄ± doÄŸrulandÄ±.
  - TÃ¼m testler context7 SignalR best practice'lerine uygun ÅŸekilde baÅŸarÄ±yla geÃ§ti.
  - Frontend dokÃ¼mantasyonuna (app/backendTalimat.md) bu hata yÃ¶netimiyle ilgili notlar ve kullanÄ±cÄ±ya uygun uyarÄ± gÃ¶sterilmesi gerektiÄŸi eklendi.

# 2024-06-20 GeliÅŸtirme GÃ¼nlÃ¼ÄŸÃ¼

- IMatchRepository arayÃ¼zÃ¼ ve MatchRepository implementasyonu eklendi. MatchService artÄ±k doÄŸrudan DbContext yerine repository kullanÄ±yor.
- Program.cs'de IMatchRepository iÃ§in DI kaydÄ± yapÄ±ldÄ±.
- MesajlaÅŸma ve eÅŸleÅŸme endpointleri iÃ§in repository altyapÄ±sÄ± tamamlandÄ±.
</file>

<file path="Dockerfile">
# Build aÅŸamasÄ±
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY . .
RUN dotnet restore
RUN dotnet publish PawMatch.Api/PawMatch.Api.csproj -c Release -o /app/publish

# Runtime aÅŸamasÄ±
FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY --from=build /app/publish .
COPY wait-for-it.sh /wait-for-it.sh
RUN chmod +x /wait-for-it.sh
# ENTRYPOINT satÄ±rÄ±nÄ± kaldÄ±rÄ±yorum, komut docker-compose'dan alÄ±nacak.
</file>

<file path="ef_core_migration_guide.md">
## ğŸ“¦ Entity Framework Core Migration KullanÄ±m KÄ±lavuzu

Bu dÃ¶kÃ¼man, **EF Core Code First** yaklaÅŸÄ±mÄ±yla veri tabanÄ± migration'larÄ±nÄ±n nasÄ±l oluÅŸturulup uygulandÄ±ÄŸÄ±nÄ± adÄ±m adÄ±m aÃ§Ä±klar.

> ğŸ’¡ **Not:** AÅŸaÄŸÄ±daki komutlar Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rken terminalde `C:\Projects\Business\PawMatch\api` klasÃ¶rÃ¼nde (ana projenin bulunduÄŸu dizin) olunmasÄ± gerekir.

---

### ğŸ§± Migration OluÅŸturmak

```bash
 dotnet ef migrations add <MIGRATION_ADI> --project PawMatch.Infrastructure --startup-project PawMatch.Api
```

#### Parametreler:

- `<MIGRATION_ADI>`: Migration'a verilecek isim.
  - Ã–rnek: `InitialCreate`, `AddedPetEntity`, `UpdateUserEmail`

#### Sabit Parametreler:

- `--project PawMatch.Infrastructure`: `DbContext` ve entity'lerin bulunduÄŸu proje katmanÄ±.
- `--startup-project PawMatch.Api`: `Program.cs` ve `appsettings.json` gibi dosyalarÄ±n bulunduÄŸu baÅŸlangÄ±Ã§ projesi.

#### Ã–rnek:

```bash
dotnet ef migrations add InitialCreate --project PawMatch.Infrastructure --startup-project PawMatch.Api
```

> âš ï¸ Bu komutu Ã§alÄ±ÅŸtÄ±rmadan Ã¶nce projelerin derlenebilir durumda olduÄŸundan emin olun.

---

### ğŸ—ï¸ VeritabanÄ±nÄ± GÃ¼ncellemek

```bash
dotnet ef database update --project PawMatch.Infrastructure --startup-project PawMatch.Api
```

#### Sabit Parametreler:

- `--project PawMatch.Infrastructure`
- `--startup-project PawMatch.Api`

#### AÃ§Ä±klama:

Bu komut, mevcut en son migration'Ä± kullanarak veritabanÄ±nÄ± gÃ¼nceller.

#### Ã–rnek:

```bash
dotnet ef database update --project PawMatch.Infrastructure --startup-project PawMatch.Api
```

> Bu iÅŸlem sonucunda veritabanÄ±nda gerekli tablolar oluÅŸturulur veya gÃ¼ncellenir.

---

### ğŸ” Yeni Migration Eklemek

Yeni bir model eklendikten veya mevcut modellerde deÄŸiÅŸiklik yapÄ±ldÄ±ktan sonra tekrar migration oluÅŸturmak gerekir:

```bash
dotnet ef migrations add <YENI_MIGRATION_ADI> --project PawMatch.Infrastructure --startup-project PawMatch.Api
```

#### Ã–rnek:

```bash
dotnet ef migrations add AddedPetEntity --project PawMatch.Infrastructure --startup-project PawMatch.Api
```

> Migration adÄ±, yapÄ±lan deÄŸiÅŸikliÄŸi tanÄ±mlayacak ÅŸekilde verilmelidir. Ã–rnekler: `RenamedUserField`, `RemovedOldTable`, `AddProfilePictureToUser`

---

### âœ… Notlar

- EF Core CLI aracÄ±nÄ±n kurulu olduÄŸundan emin olun:

```bash
dotnet tool install --global dotnet-ef
```

- Projenizde `Microsoft.EntityFrameworkCore.Design` paketi kurulu olmalÄ±dÄ±r:

```bash
dotnet add package Microsoft.EntityFrameworkCore.Design
```

- TÃ¼m komutlar, proje kÃ¶k dizininden (solution ".sln" dosyasÄ±nÄ±n bulunduÄŸu yer, bu durumda `C:\Projects\Business\PawMatch\api`) Ã§alÄ±ÅŸtÄ±rÄ±lmalÄ±dÄ±r.
</file>

<file path="matchandmessagesfeaturedoc.md">
# PawMatch EÅŸleÅŸme ve MesajlaÅŸma Ã–zelliÄŸi Planlama DokÃ¼mantasyonu

Bu dokÃ¼man, PawMatch uygulamasÄ±nda eÅŸleÅŸme mekanizmasÄ±nÄ±n geliÅŸtirilmesi ve uÃ§tan uca mesajlaÅŸma altyapÄ±sÄ±nÄ±n planlanmasÄ± iÃ§in ayrÄ±ntÄ±lÄ± bilgileri iÃ§erir. Bu aÅŸamada sadece planlama yapÄ±lmakta, kod yazÄ±mÄ± henÃ¼z baÅŸlamamÄ±ÅŸtÄ±r.

## 1. Ã–zellik: `MatchService.cs` - `LikeOrPassAsync` GeliÅŸtirmesi

Bu Ã¶zellik, kullanÄ±cÄ±larÄ±n birbirlerini beÄŸenmesi veya geÃ§mesi durumunda gerÃ§ekleÅŸecek eÅŸleÅŸme mantÄ±ÄŸÄ±nÄ± tanÄ±mlayacaktÄ±r.

**Mevcut Durum:**
`MatchActionDto` (User1Id, User2Id, Liked) girdisi alÄ±yor ve `MatchResultDto` (MatchId, Confirmed) dÃ¶ndÃ¼rÃ¼yor. Mevcut implementasyon bir yer tutucudur (`TODO`).

**Planlama:**

1.  **Girdi DoÄŸrulama**: `MatchActionDto` iÃ§indeki `User1Id`'nin, isteÄŸi yapan kimliÄŸi doÄŸrulanmÄ±ÅŸ kullanÄ±cÄ±nÄ±n ID'si olduÄŸundan emin olunmalÄ±dÄ±r. Yetkisiz bir ID gelirse hata fÄ±rlatÄ±lmalÄ±dÄ±r.
2.  **KullanÄ±cÄ± KaydÄ±nÄ± Tutma (Swipe GeÃ§miÅŸi)**:
    *   KullanÄ±cÄ±larÄ±n birbiri Ã¼zerindeki beÄŸenme/geÃ§me eylemlerini kaydetmek iÃ§in yeni bir veri modeli/tablosu (`UserSwipe`) gereklidir. Bu, hem geÃ§miÅŸi tutacak hem de tekrar karÅŸÄ±laÅŸma engellemesini saÄŸlayacaktÄ±r.
    *   EÄŸer `MatchActionDto.Liked` `true` ise (beÄŸenme eylemi), bu eylem `UserSwipe` tablosuna kaydedilir.
    *   EÄŸer `MatchActionDto.Liked` `false` ise (geÃ§me eylemi), bu da `UserSwipe` tablosuna kaydedilir.
3.  **EÅŸleÅŸme KontrolÃ¼**:
    *   Mevcut kullanÄ±cÄ± (User1), hedef kullanÄ±cÄ±yÄ± (User2) beÄŸendiyse (`Liked = true`):
        *   VeritabanÄ±nda User2'nin de User1'i daha Ã¶nce beÄŸenip beÄŸenmediÄŸi (`UserSwipe` tablosunda `SwiperId = User2Id` ve `SwipedUserId = User1Id` ve `IsLiked = true` olan bir kayÄ±t var mÄ±) kontrol edilir.
        *   EÄŸer karÅŸÄ±lÄ±klÄ± bir beÄŸeni varsa, yani bir "eÅŸleÅŸme" gerÃ§ekleÅŸtiyse:
            *   `Match` tablosunda bu iki kullanÄ±cÄ± arasÄ±nda yeni bir eÅŸleÅŸme kaydÄ± oluÅŸturulur veya mevcut eÅŸleÅŸme (`Confirmed = false` ise) `Confirmed = true` olarak gÃ¼ncellenir.
            *   YanÄ±t olarak `MatchResultDto` iÃ§inde `Confirmed = true` ve ilgili `MatchId` dÃ¶ndÃ¼rÃ¼lÃ¼r.
        *   EÄŸer karÅŸÄ±lÄ±klÄ± beÄŸeni yoksa, sadece beÄŸenme eylemi kaydedilir ve `MatchResultDto` iÃ§inde `Confirmed = false` dÃ¶ndÃ¼rÃ¼lÃ¼r.
    *   EÄŸer mevcut kullanÄ±cÄ± (User1) hedef kullanÄ±cÄ±yÄ± (User2) geÃ§tiyse (`Liked = false`):
        *   Sadece geÃ§me eylemi kaydedilir. Bir eÅŸleÅŸme gerÃ§ekleÅŸmez.
        *   EÄŸer bu iki kullanÄ±cÄ± arasÄ±nda daha Ã¶nce onaylanmÄ±ÅŸ bir eÅŸleÅŸme varsa, bu eÅŸleÅŸmenin durumu `Confirmed = false` olarak gÃ¼ncellenmeli veya silinmelidir (genellikle durum gÃ¼ncellemek geÃ§miÅŸi korumak adÄ±na tercih edilir).
        *   YanÄ±t olarak `MatchResultDto` iÃ§inde `Confirmed = false` dÃ¶ndÃ¼rÃ¼lÃ¼r.
4.  **VeritabanÄ± Ä°ÅŸlemleri**: `UserSwipe` kayÄ±tlarÄ± ve `Match` tablosu gÃ¼ncellemeleri transaction iÃ§erisinde yapÄ±lmalÄ±dÄ±r.
5.  **YanÄ±t**: Ä°ÅŸlem sonucuna gÃ¶re `MatchResultDto` dÃ¶ndÃ¼rÃ¼lÃ¼r.

## 2. Ã–zellik: KullanÄ±cÄ±nÄ±n BeÄŸendiÄŸi veya GeÃ§tiÄŸi KullanÄ±cÄ±larÄ±n VeritabanÄ±nda TutulmasÄ± ve Tekrar KarÅŸÄ±laÅŸma Engellemesi

Bu Ã¶zellik, keÅŸif algoritmasÄ±nÄ±n iyileÅŸtirilmesi ve kullanÄ±cÄ±lara daha Ã¶nce etkileÅŸimde bulunduklarÄ± profillerin tekrar gÃ¶sterilmemesini saÄŸlayacaktÄ±r.

**Planlama (AltyapÄ±):**

1.  **Yeni Veri Modeli (`UserSwipe`)**:
    *   **Konum**: `PawMatch.Domain/UserSwipe.cs`
    *   **Ã–zellikler**:
        *   `Id` (int): Birincil anahtar.
        *   `SwiperId` (int): Swipe eylemini yapan kullanÄ±cÄ±nÄ±n ID'si (Foreign Key: `User`).
        *   `SwipedUserId` (int): Swipe eylemine maruz kalan kullanÄ±cÄ±nÄ±n ID'si (Foreign Key: `User`).
        *   `IsLiked` (bool): `true` ise beÄŸenme, `false` ise geÃ§me.
        *   `SwipeDate` (DateTimeOffset / DateTime UTC): Swipe eyleminin gerÃ§ekleÅŸtiÄŸi zaman damgasÄ±.
    *   **Ä°liÅŸkiler**: `User` modeli ile iki adet bire-Ã§ok iliÅŸki (Swiper ve SwipedUser).
2.  **`AppDbContext` GÃ¼ncellemesi**: `AppDbContext.cs` dosyasÄ±na `DbSet<UserSwipe> UserSwipes { get; set; }` eklenecektir.
3.  **VeritabanÄ± Migrasyonu**: `UserSwipe` tablosunu veritabanÄ±na eklemek iÃ§in yeni bir Entity Framework Core migrasyonu oluÅŸturulacaktÄ±r.
4.  **`IUserSwipeRepository` (Opsiyonel ama Ã–nerilir)**: `UserSwipe` iÅŸlemleri iÃ§in (`AddAsync`, `GetBySwiperAndSwipedUserAsync`, `GetRecentSwipesAsync` vb.) bir `IUserSwipeRepository` arayÃ¼zÃ¼ ve `UserRepository.cs` gibi somut bir implementasyon (`UserSwipeRepository.cs`) oluÅŸturulmasÄ±, veri eriÅŸim mantÄ±ÄŸÄ±nÄ± daha dÃ¼zenli hale getirir.
5.  **`DiscoverService` GeliÅŸtirmesi**:
    *   `DiscoverService.DiscoverUsersAsync` (tekil keÅŸif metodu) gÃ¼ncellenecektir.
    *   Bu metod, `currentUserId`'nin belirli bir sÃ¼re (`configurableDuration` gibi bir ayardan okunabilir) iÃ§inde zaten beÄŸenmiÅŸ veya geÃ§miÅŸ olduÄŸu kullanÄ±cÄ±larÄ± (`UserSwipe` tablosundan) sorgulayarak hariÃ§ tutmalÄ±dÄ±r.
    *   **SÃ¼re AyarÄ±**: Bu "deÄŸiÅŸken sÃ¼re" (`configurableDuration`), `appsettings.json` gibi bir yapÄ±landÄ±rma dosyasÄ±nda tutulmalÄ±dÄ±r (Ã¶rn. `SwipeExclusionDurationDays: 30`).
    *   **Konum TabanlÄ± Filtreleme**: `PawMatch Backend Guidelines.markdown`'da belirtilen PostGIS tabanlÄ± konum filtreleme (`maxDistanceKm` parametresi) `DiscoverService` iÃ§inde uygulanmalÄ±dÄ±r.
    *   **Pet TÃ¼rÃ¼ Filtreleme**: YÃ¶nergelerde belirtilen pet tÃ¼rÃ¼ filtrelemesi de keÅŸif algoritmasÄ±na dahil edilmelidir.

## 3. Ã–zellik: UÃ§tan Uca Mesaj Åifreleme (AltyapÄ± PlanlamasÄ±)

Bu, mesajlaÅŸma Ã¶zelliÄŸinin gelecekteki gÃ¼venliÄŸini saÄŸlamaya yÃ¶nelik Ã¶nemli bir adÄ±mdÄ±r. Backend, ÅŸifrelenmemiÅŸ mesaj iÃ§eriÄŸine asla eriÅŸemez.

**Planlama (AltyapÄ±):**

1.  **Anahtar YÃ¶netimi**:
    *   **Herkese AÃ§Ä±k/Ã–zel Anahtar Ã‡iftleri (Public/Private Key Pairs)**: Her kullanÄ±cÄ± iÃ§in bir asimetrik anahtar Ã§ifti (Ã¶rneÄŸin RSA veya Eliptik EÄŸri Kriptografisi) gereklidir.
    *   **Ã–zel Anahtar Depolama**: KullanÄ±cÄ±nÄ±n Ã¶zel anahtarlarÄ± **ASLA sunucuda saklanmayacaktÄ±r**. Bunlar istemci tarafÄ±nda (mobil uygulama) oluÅŸturulmalÄ± ve kullanÄ±cÄ±nÄ±n cihazÄ±nda gÃ¼venli bir ÅŸekilde (Ã¶rneÄŸin mobil cihazÄ±n gÃ¼venli bÃ¶lgesi, anahtar zinciri veya gÃ¼Ã§lÃ¼ bir parola tÃ¼retme mekanizmasÄ±yla) saklanmalÄ±dÄ±r.
    *   **Herkese AÃ§Ä±k Anahtar Depolama**: KullanÄ±cÄ±nÄ±n herkese aÃ§Ä±k anahtarlarÄ± sunucuda saklanacaktÄ±r (Ã¶rneÄŸin `User` tablosunda yeni bir sÃ¼tun veya ayrÄ± bir `UserPublicKey` tablosunda). Bu anahtarlar, diÄŸer kullanÄ±cÄ±larÄ±n mesajlarÄ± ÅŸifrelemesi iÃ§in kullanÄ±lacaktÄ±r.
2.  **Åifreleme SÃ¼reci (Kavramsal)**:
    *   **Ä°stemci TarafÄ±nda Åifreleme**: Mesaj iÃ§eriÄŸi, sunucuya gÃ¶nderilmeden Ã¶nce gÃ¶nderen istemci tarafÄ±nda ÅŸifrelenmelidir.
    *   **Symmetric Oturum AnahtarÄ± (Session Key)**: Her bir mesajlaÅŸma oturumu (veya her mesaj iÃ§in), daha kÃ¼Ã§Ã¼k ve hÄ±zlÄ± bir simetrik anahtar (Ã¶rneÄŸin AES-256) oluÅŸturulacaktÄ±r. MesajÄ±n kendisi bu simetrik anahtar ile ÅŸifrelenecektir.
    *   **Asimetrik Anahtar DeÄŸiÅŸimi**: Bu simetrik oturum anahtarÄ±, alÄ±cÄ±nÄ±n **herkese aÃ§Ä±k anahtarÄ±** kullanÄ±larak ÅŸifrelenecektir. BÃ¶ylece, mesajla birlikte gÃ¶nderilen ÅŸifrelenmiÅŸ oturum anahtarÄ±, yalnÄ±zca alÄ±cÄ±nÄ±n **Ã¶zel anahtarÄ±** ile Ã§Ã¶zÃ¼lebilir.
    *   **Mesaj YapÄ±sÄ±**: Mesajlar, ÅŸifrelenmiÅŸ iÃ§erik, ÅŸifrelenmiÅŸ oturum anahtarÄ± ve mesajÄ±n Ã§Ã¶zÃ¼lmesinde kullanÄ±lacak ek ÅŸifreleme parametrelerini (IV, nonce vb.) iÃ§erecektir.
3.  **Sunucunun RolÃ¼**:
    *   Sunucu, ÅŸifrelenmemiÅŸ mesaj iÃ§eriÄŸine **hiÃ§bir zaman** eriÅŸemeyecektir.
    *   ÅifrelenmiÅŸ mesajlarÄ± ve ilgili anahtar paketlerini veritabanÄ±nda saklayacaktÄ±r.
    *   KullanÄ±cÄ±larÄ±n herkese aÃ§Ä±k anahtarlarÄ±nÄ± yÃ¶netmekten ve eÅŸleÅŸen kullanÄ±cÄ±lara daÄŸÄ±tmaktan sorumlu olacaktÄ±r.
    *   MesajlarÄ±n meta verilerini (kimden, kime, zaman damgasÄ±, eÅŸleÅŸme ID'si) yÃ¶netecektir.
4.  **VeritabanÄ± DeÄŸiÅŸiklikleri**:
    *   `User` Modeli: Herkese aÃ§Ä±k anahtar iÃ§in `PublicKey` (string veya byte dizisi) gibi bir alan eklenebilir.
    *   `Message` Modeli: `Content` alanÄ± artÄ±k ÅŸifrelenmiÅŸ veriyi (Base64 kodlanmÄ±ÅŸ string veya byte dizisi) saklayacaktÄ±r.
    *   MesajÄ±n ÅŸifrelenmiÅŸ simetrik oturum anahtarÄ±nÄ± ve diÄŸer ÅŸifreleme meta verilerini tutmak iÃ§in yeni bir tablo (`MessageKeyBundle` gibi) gerekebilir. Bu tablo, belirli bir mesaj veya sohbetle iliÅŸkilendirilecektir.
5.  **API DeÄŸiÅŸiklikleri (Kavramsal)**:
    *   KullanÄ±cÄ±larÄ±n herkese aÃ§Ä±k anahtarlarÄ±nÄ± yÃ¼klemesi ve almasÄ± iÃ§in yeni endpoint'ler gerekebilir.
    *   Mevcut `POST /api/v1/messages` endpoint'i, artÄ±k ÅŸifrelenmiÅŸ mesaj iÃ§eriÄŸini ve ÅŸifrelenmiÅŸ oturum anahtarÄ±nÄ± kabul edecek ÅŸekilde gÃ¼ncellenmelidir.
    *   Mevcut `GET /api/v1/messages/{matchId}` endpoint'i, ÅŸifrelenmiÅŸ mesajlarÄ± ve istemci tarafÄ±nda Ã§Ã¶zÃ¼mleme iÃ§in gerekli anahtar paketlerini dÃ¶ndÃ¼rmelidir.
6.  **Ä°stemci TarafÄ± Gereksinimleri**: Flutter mobil uygulamasÄ± tarafÄ±nda, anahtar Ã§ifti oluÅŸturma, mesaj ÅŸifreleme/ÅŸifre Ã§Ã¶zme ve gÃ¼venli anahtar yÃ¶netimi iÃ§in gÃ¼Ã§lÃ¼ kriptografik kÃ¼tÃ¼phanelerin entegrasyonu gerekecektir.

## 4. Eksik ve Ä°leriye YÃ¶nelik Ä°yileÅŸtirmeler

1.  **EÅŸleÅŸme ve Swipe MekanizmasÄ± Ä°Ã§in Daha DetaylÄ± Durum YÃ¶netimi**:
    *   `LikeOrPassAsync` iÃ§inde, bir kullanÄ±cÄ± bir diÄŸerini beÄŸendiÄŸinde ve henÃ¼z karÅŸÄ±lÄ±klÄ± beÄŸeni yoksa, bu beÄŸeni durumunun veritabanÄ±nda "beklemede" (`pending`) bir eÅŸleÅŸme olarak iÅŸaretlenmesi ve karÅŸÄ±daki kullanÄ±cÄ± beÄŸendiÄŸinde bu eÅŸleÅŸmenin "onaylanmasÄ±" (`confirmed`) mekanizmasÄ± daha aÃ§Ä±kÃ§a belirtilebilir. Mevcut plan `Match` tablosunda `Confirmed` alanÄ± Ã¼zerinden bunu yÃ¶netiyor, ancak akÄ±ÅŸÄ±n netleÅŸtirilmesi faydalÄ± olabilir.
    *   Bir kullanÄ±cÄ± birini "geÃ§tiÄŸinde" (`pass`), bu bilginin sadece keÅŸif listesinde tekrar gÃ¶rÃ¼nmemesi iÃ§in deÄŸil, aynÄ± zamanda ileride kullanÄ±cÄ± fikrini deÄŸiÅŸtirirse bu eylemi geri alma gibi senaryolar iÃ§in de dÃ¼ÅŸÃ¼nÃ¼lmesi. (Bu belki daha sonraki bir aÅŸama ama altyapÄ±da esneklik saÄŸlar).

2.  **MesajlaÅŸma (UÃ§tan Uca Åifreleme) - Ä°leriye DÃ¶nÃ¼k GÃ¼venlik OdaklÄ± Eksikler**:
    *   **MÃ¼kemmel Ä°leri Gizlilik (Perfect Forward Secrecy - PFS)**: Mevcut plan simetrik oturum anahtarlarÄ± ve asimetrik anahtar deÄŸiÅŸimi iÃ§eriyor, bu da bir PFS formuna iÅŸaret ediyor. Ancak bu terimin aÃ§Ä±kÃ§a belirtilmesi, iletiÅŸimin uzun vadeli gÃ¼venliÄŸini vurgular. Bu, tek bir uzun Ã¶mÃ¼rlÃ¼ anahtarÄ±n tehlikeye atÄ±lmasÄ±nÄ±n geÃ§miÅŸ konuÅŸmalarÄ± tehlikeye atmamasÄ±nÄ± saÄŸlar. Genellikle, her yeni oturum veya mesaj iÃ§in efemeral anahtarlarÄ±n kullanÄ±lmasÄ±yla saÄŸlanÄ±r.
    *   **Kimlik DoÄŸrulama/Anahtar DoÄŸrulama (Key Verification)**: Herkese aÃ§Ä±k anahtarlarÄ±n deÄŸiÅŸimi planlanmÄ±ÅŸ olsa da, kullanÄ±cÄ±larÄ±n bu herkese aÃ§Ä±k anahtarlarÄ±n gerÃ§ekten bekledikleri kiÅŸiye ait olduÄŸunu nasÄ±l doÄŸrulayacaklarÄ± (yani "anahtar doÄŸrulama") konusu Ã¶nemlidir. Bu, genellikle istemci tarafÄ± bir zorluktur (Ã¶rn. QR kodlarÄ±, anahtar parmak izleri), ancak backend'in gÃ¼venilir anahtar daÄŸÄ±tÄ±mÄ±nda bir rolÃ¼ vardÄ±r. Bu planlama aÅŸamasÄ±nda doÄŸrudan backend implementasyonu olmasa da, mimari dÃ¼ÅŸÃ¼nceler iÃ§inde belirtilmesi gereken bir gÃ¼venlik Ã¶zelliÄŸidir.
    *   **Ä°letiÅŸim GÃ¼venliÄŸi Protokolleri**: Plan, anahtar yÃ¶netimi ve ÅŸifreleme sÃ¼recinin kavramsal bir tanÄ±mÄ±nÄ± veriyor. Ä°leride Signal Protocol gibi kurulmuÅŸ ve denetlenmiÅŸ bir uÃ§tan uca ÅŸifreleme protokolÃ¼nÃ¼n detaylarÄ±nÄ±n araÅŸtÄ±rÄ±lmasÄ± ve implementasyonunun dÃ¼ÅŸÃ¼nÃ¼lmesi gerekebilir.

3.  **Performans ve Ã–lÃ§eklenebilirlik Ä°Ã§in Ek DÃ¼ÅŸÃ¼nceler (Genel)**:
    *   **Ã–n Bellekleme (Caching)**: Ã–zellikle `DiscoverService` gibi sÄ±k Ã§aÄŸrÄ±lan ve yoÄŸun hesaplama gerektirebilecek servisler iÃ§in Ã¶n bellekleme stratejileri (Ã¶rneÄŸin Redis ile) dÃ¼ÅŸÃ¼nÃ¼lebilir. BeÄŸenme/geÃ§me geÃ§miÅŸi bÃ¼yÃ¼dÃ¼kÃ§e, bu sorgularÄ±n performansÄ± etkileyebilir.
    *   **GerÃ§ek ZamanlÄ± Ä°letiÅŸim (SignalR)**: AnlÄ±k mesajlaÅŸma ve bildirim deneyimi iÃ§in **SignalR** kullanÄ±lacaktÄ±r. Bu, mesajlarÄ±n veritabanÄ±na kaydedildikten sonra eÅŸleÅŸen kullanÄ±cÄ±nÄ±n baÄŸlÄ± istemcilerine anlÄ±k olarak iletilmesini saÄŸlayacaktÄ±r.

4.  **Hata YÃ¶netimi ve GÃ¶zlemlenebilirlik (Genel Ä°yileÅŸtirme)**:
    *   **DetaylÄ± Hata KodlarÄ±/MesajlarÄ±**: API yanÄ±tlarÄ±nda kullanÄ±lan `status: "error"` ve `error: "mesaj"` formatÄ± geneldir. Daha spesifik, istemci tarafÄ±nÄ±n anlayabileceÄŸi ve iÅŸleyebileceÄŸi hata kodlarÄ± ve daha aÃ§Ä±klayÄ±cÄ± hata mesajlarÄ± saÄŸlamak, hata ayÄ±klama ve entegrasyonu kolaylaÅŸtÄ±rÄ±r.
    *   **KapsamlÄ± Loglama**: Yeni Ã¶zellikler implemente edilirken, Ã¶zellikle eÅŸleÅŸme akÄ±ÅŸÄ± ve ÅŸifreleme iÅŸlemleri iÃ§in detaylÄ± loglama (hata, uyarÄ±, bilgi seviyeleri) eklenmesi, sorun giderme ve izleme iÃ§in kritik Ã¶neme sahiptir.

### 5.5.1. GerÃ§ek ZamanlÄ± Ä°letiÅŸim (SignalR)
- **AmaÃ§**: AnlÄ±k mesajlaÅŸma ve eÅŸleÅŸme bildirimleri iÃ§in gerÃ§ek zamanlÄ± iletiÅŸim saÄŸlamak.
- **Teknoloji**: ASP.NET Core SignalR, `IRealtimeNotificationService` aracÄ±lÄ±ÄŸÄ±yla soyutlanmÄ±ÅŸ.
- **Hub YapÄ±landÄ±rmasÄ±**: 
  - `Program.cs`'te SignalR servisleri eklenmeli (`builder.Services.AddSignalR()`).
  - Bir SignalR Hub (`ChatHub.cs` gibi) oluÅŸturulmalÄ±. Bu Hub, istemcilerin Ã§aÄŸÄ±rabileceÄŸi ve sunucunun istemcilere gÃ¶nderebileceÄŸi metotlarÄ± iÃ§erecek (Ã¶rn. `SendMessage`, `ReceiveMessage`, `NotifyMatchFound`).
  - Hub, belirli bir URL Ã¼zerinde yapÄ±landÄ±rÄ±lmalÄ± (Ã¶rn. `app.MapHub<ChatHub>("/chatHub");`).
- **Servis KatmanÄ± Entegrasyonu (`IRealtimeNotificationService`)**:
  - `PawMatch.Application.Interfaces` iÃ§inde `IRealtimeNotificationService` adÄ±nda bir arayÃ¼z tanÄ±mlanÄ±r. Bu arayÃ¼z, gerÃ§ek zamanlÄ± bildirim gÃ¶nderme ihtiyacÄ±nÄ± soyutlar.
  - `api/PawMatch.Api/Services/SignalRNotificationService.cs` adÄ±nda bir sÄ±nÄ±f oluÅŸturularak `IRealtimeNotificationService` arayÃ¼zÃ¼ implemente edilir. Bu sÄ±nÄ±f, `IHubContext<ChatHub>`'Ä± kullanarak gerÃ§ek SignalR Ã§aÄŸrÄ±larÄ±nÄ± yapar.
  - `MatchService.cs` ve `MessageService.cs` gibi uygulama katmanÄ±ndaki servisler, doÄŸrudan `IHubContext<ChatHub>` yerine `IRealtimeNotificationService` baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± enjekte eder ve kullanÄ±r. Bu, uygulama katmanÄ±nÄ±n SignalR'a olan doÄŸrudan baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± kaldÄ±rarak daha temiz bir mimari saÄŸlar.
- **MesajlaÅŸma AkÄ±ÅŸÄ±**: 
  - KullanÄ±cÄ± bir mesaj gÃ¶nderdiÄŸinde (`POST /api/v1/messages`), `MessageService` mesajÄ± veritabanÄ±na kaydeder.
  - KayÄ±t baÅŸarÄ±lÄ± olduktan sonra, `MessageService`, `IRealtimeNotificationService`'Ä± kullanarak mesajÄ± eÅŸleÅŸen kullanÄ±cÄ±nÄ±n baÄŸlÄ± SignalR istemcilerine anlÄ±k olarak iletir.
- **EÅŸleÅŸme Bildirimi AkÄ±ÅŸÄ±**: 
  - `MatchService` iÃ§inde yeni bir eÅŸleÅŸme onaylandÄ±ÄŸÄ±nda, `IRealtimeNotificationService`'Ä± kullanarak ilgili kullanÄ±cÄ±lara anlÄ±k bildirim (`NotifyMatchFound` gibi bir metod ile) gÃ¶nderilir.
- **Kimlik DoÄŸrulama**: SignalR baÄŸlantÄ±larÄ±, mevcut JWT kimlik doÄŸrulama mekanizmasÄ± ile gÃ¼vence altÄ±na alÄ±nacaktÄ±r. Ä°stemciler, SignalR baÄŸlantÄ±sÄ± kurulurken JWT token'larÄ±nÄ± saÄŸlayacaklardÄ±r.
- **Ã–lÃ§eklenebilirlik**: YÃ¼ksek trafik durumlarÄ±nda birden fazla sunucuya Ã¶lÃ§eklenmek iÃ§in SignalR backplane'leri (Ã¶rn. Redis, Azure SignalR Service) kullanÄ±labilir.

## 5.5.1. GerÃ§ek ZamanlÄ± Ä°letiÅŸim (SignalR) - Testler ve Entegrasyon Notu
- SignalR backend testlerinde, SignalR Hub baÄŸlantÄ±sÄ± kurarken JWT authentication zorunludur. Testlerde Ã¶nce bir kullanÄ±cÄ± register/login edilip JWT token alÄ±nmalÄ±, ardÄ±ndan SignalR HubConnection oluÅŸturulurken `options.AccessTokenProvider = () => Task.FromResult(token);` ile bu token kullanÄ±lmalÄ±dÄ±r.
- Bu yÃ¶ntem, hem .NET hem de context7 SignalR dokÃ¼mantasyonundaki best practice'lere uygundur.
- SignalR testleri bu ÅŸekilde gÃ¼ncellendi ve tÃ¼m testler baÅŸarÄ±yla geÃ§ti.

## 4. KullanÄ±cÄ± Response RefaktÃ¶rÃ¼ ve DTO AyrÄ±mÄ±

- TÃ¼m kullanÄ±cÄ± response'larÄ± UserPublicDto (public) ve UserPrivateDto (private) ile dÃ¶nmektedir.
- Hassas bilgiler (email, passwordHash) sadece UserPrivateDto'da bulunur ve sadece login/register/profile response'larÄ±nda yer alÄ±r.
- KeÅŸif, eÅŸleÅŸme ve genel kullanÄ±cÄ± listelerinde sadece UserPublicDto ile public alanlar yer alÄ±r.
- HiÃ§bir endpoint doÄŸrudan domain User veya eski UserDto ile veri dÃ¶ndÃ¼rmez.
- Mapping iÅŸlemleri merkezi UserPublicDtoMapper ve UserPrivateDtoMapper ile yapÄ±lÄ±r.

### Response Ã–rnekleri

#### 1. Public (KeÅŸif/EÅŸleÅŸme)
```json
{
  "user": {
    "id": 2,
    "name": "Ali",
    "bio": "KuÅŸsever",
    "hasPet": false,
    "hasProfile": true,
    "photoIds": ["fileid3"],
    "age": null,
    "gender": null
  }
}
```
#### 2. Private (Login/Register/Profile)
```json
{
  "userPrivate": {
    "id": 1,
    "name": "Berkan",
    "email": "berkan@example.com",
    "bio": "Kedisever",
    "hasPet": true,
    "hasProfile": true,
    "photoIds": ["fileid1", "fileid2"],
    "age": null,
    "gender": null,
    "passwordHash": "..."
  }
}
```

## Repository Pattern ve KatmanlÄ± Mimari GÃ¼ncellemesi
- EÅŸleÅŸme iÅŸlemleri iÃ§in IMatchRepository arayÃ¼zÃ¼ ve MatchRepository implementasyonu eklendi.
- MatchService, eÅŸleÅŸme iÅŸlemlerinde doÄŸrudan DbContext yerine MatchRepository kullanÄ±yor.
- Program.cs'de IMatchRepository iÃ§in DI kaydÄ± yapÄ±ldÄ±.
- MesajlaÅŸma ve eÅŸleÅŸme endpointleri iÃ§in repository altyapÄ±sÄ± tamamlandÄ±.
</file>

<file path="matchandmessagesfeaturetodo.md">
# PawMatch EÅŸleÅŸme ve MesajlaÅŸma Ã–zelliÄŸi - YapÄ±lacaklar Listesi

Bu belge, PawMatch uygulamasÄ±nda eÅŸleÅŸme ve mesajlaÅŸma Ã¶zelliklerinin implementasyon adÄ±mlarÄ±nÄ±, belirlenen iÅŸ akÄ±ÅŸÄ±na gÃ¶re sÄ±ralÄ± bir ÅŸekilde listeler. Her ana gÃ¶revin ardÄ±ndan, ilgili test yazma ve Ã§alÄ±ÅŸtÄ±rma adÄ±mlarÄ± belirtilmiÅŸtir.

## 1. Match Fonksiyonu Core Loop Ã‡alÄ±ÅŸacak (`LikeOrPassAsync` Implementasyonu)

### GÃ¶revler:

*   **Veri Modeli ve VeritabanÄ±:**
    *   [x] `PawMatch.Domain/UserSwipe.cs` modelini oluÅŸtur. (Id, SwiperId, SwipedUserId, IsLiked, SwipeDate)
    *   [x] `AppDbContext.cs` iÃ§ine `DbSet<UserSwipe> UserSwipes { get; set; }` ekle.
    *   [x] Yeni `UserSwipe` tablosu iÃ§in Entity Framework Core migrasyonu oluÅŸtur.
    *   [x] `IUserSwipeRepository.cs` arayÃ¼zÃ¼nÃ¼ oluÅŸtur. (AddAsync, GetBySwiperAndSwipedUserAsync gibi metodlar)
    *   [x] `UserSwipeRepository.cs` implementasyonunu oluÅŸtur.
    *   [x] `Program.cs`'te `IUserSwipeRepository`'yi Dependency Injection'a ekle.

*   **`MatchService.cs` GeliÅŸtirmesi:**
    *   [x] `MatchService` iÃ§ine `IUserSwipeRepository` baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± enjekte et.
    *   [x] `LikeOrPassAsync` metodunu gÃ¼ncelle:
        *   [x] Girdi doÄŸrulamasÄ±nÄ± yap (istek yapan kullanÄ±cÄ±nÄ±n ID'si ile `User1Id`'nin eÅŸleÅŸtiÄŸini kontrol et).
        *   [x] `UserSwipe` kaydÄ±nÄ± oluÅŸtur ve kaydet (`SwiperId`, `SwipedUserId`, `IsLiked`, `SwipeDate`).
        *   [x] `IsLiked = true` ise, karÅŸÄ±lÄ±klÄ± beÄŸeni olup olmadÄ±ÄŸÄ±nÄ± kontrol et (`UserSwipe` tablosunda).
        *   [x] EÄŸer karÅŸÄ±lÄ±klÄ± beÄŸeni varsa:
            *   [x] `Match` tablosunda yeni bir eÅŸleÅŸme oluÅŸtur veya mevcut `Confirmed = false` eÅŸleÅŸmeyi `Confirmed = true` olarak gÃ¼ncelle.
            *   [x] `MatchResultDto` iÃ§inde `Confirmed = true` ve `MatchId` dÃ¶ndÃ¼r.
        *   [x] EÄŸer karÅŸÄ±lÄ±klÄ± beÄŸeni yoksa, `MatchResultDto` iÃ§inde `Confirmed = false` dÃ¶ndÃ¼r.
        *   [x] `IsLiked = false` ise, sadece `UserSwipe` kaydÄ±nÄ± oluÅŸtur.
        *   [x] EÄŸer daha Ã¶nce onaylanmÄ±ÅŸ bir eÅŸleÅŸme varsa, bu eÅŸleÅŸmenin durumu `Confirmed = false` olarak gÃ¼ncellenmeli veya silinmelidir (genellikle durum gÃ¼ncellemek geÃ§miÅŸi korumak adÄ±na tercih edilir).
        *   [x] `MatchResultDto` iÃ§inde `Confirmed = false` dÃ¶ndÃ¼r.
    *   [x] VeritabanÄ± iÅŸlemlerini transaction iÃ§erisinde yap.

*   **`DiscoverService.cs` GeliÅŸtirmesi (Tekrar KarÅŸÄ±laÅŸma Engellemesi):**
    *   [x] `DiscoverService` iÃ§ine `IUserSwipeRepository` baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± enjekte et.
    *   [x] `DiscoverUsersAsync` metodunu gÃ¼ncelle:
        *   [x] `currentUserId`'nin belirli bir sÃ¼re iÃ§inde (Ã¶rn. 30 gÃ¼n) zaten beÄŸenmiÅŸ veya geÃ§miÅŸ olduÄŸu kullanÄ±cÄ±larÄ± `UserSwipe` tablosundan sorgulayarak hariÃ§ tut. Bu sÃ¼re `appsettings.json`'dan okunacak.
        *   [ ] Konum tabanlÄ± filtrelemeyi (`maxDistanceKm`) ve pet tÃ¼rÃ¼ filtrelemesini gerÃ§ek algoritma ile uygula.

*   **YapÄ±landÄ±rma:**
    *   [x] `appsettings.json` iÃ§ine `SwipeExclusionDurationDays` ayarÄ±nÄ± ekle (Ã¶rn. `30`).

*   **Repository KatmanÄ±:**
    *   [x] IMatchRepository arayÃ¼zÃ¼nÃ¼ oluÅŸtur.
    *   [x] MatchRepository implementasyonunu oluÅŸtur.
    *   [x] Program.cs'de IMatchRepository iÃ§in DI kaydÄ± yap.
    *   [x] MatchService, eÅŸleÅŸme iÅŸlemlerinde MatchRepository kullanacak ÅŸekilde gÃ¼ncellendi.

### Testler (Match Fonksiyonu):

*   [x] `PawMatch.Tests/MatchesControllerTests.cs` iÃ§inde `LikeOrPass` endpoint'i iÃ§in test senaryolarÄ± yaz:
    *   [x] BaÅŸarÄ±lÄ± beÄŸenme ve karÅŸÄ±lÄ±klÄ± eÅŸleÅŸme testi (hem beÄŸeni hem de onaylanmÄ±ÅŸ eÅŸleÅŸme).
    *   [x] BaÅŸarÄ±lÄ± beÄŸenme ancak eÅŸleÅŸme olmamasÄ± testi.
    *   [x] BaÅŸarÄ±lÄ± geÃ§me testi.
    *   [x] GeÃ§ersiz kullanÄ±cÄ± ID'leri ile deneme (yetkilendirme kontrolÃ¼).
*   [x] `PawMatch.Tests/DiscoverServiceTests.cs` (veya mevcut ilgili test dosyasÄ±na) keÅŸif algoritmasÄ±nÄ±n swiped kullanÄ±cÄ±larÄ± hariÃ§ tuttuÄŸunu doÄŸrulayan testler ekle.
*   [x] YazÄ±lan testleri Ã§alÄ±ÅŸtÄ±r ve doÄŸrula.

## 2. GerÃ§ek ZamanlÄ± MesajlaÅŸma

### GÃ¶revler:

*   [X] GerÃ§ek zamanlÄ± mesajlaÅŸma iÃ§in teknoloji seÃ§imi yap (SignalR seÃ§ildi).
*   [X] Backend tarafÄ±nda SignalR Hub kur (SignalR Hub ve endpoint'i oluÅŸturuldu, baÄŸÄ±mlÄ±lÄ±k enjeksiyonu iÃ§in `IRealtimeNotificationService` arayÃ¼zÃ¼ ve `SignalRNotificationService` implementasyonu kullanÄ±ldÄ±).
*   [X] `Message` modeli ve veritabanÄ± yapÄ±sÄ±nÄ± gerÃ§ek zamanlÄ± iletiÅŸim iÃ§in optimize et (Message modeli, DbSet, IMessageRepository ve MessageRepository oluÅŸturuldu).
*   [X] MesajlaÅŸma endpoint'lerini gerÃ§ek zamanlÄ± iletiÅŸimi kullanacak ÅŸekilde gÃ¼ncelle (Ã¶rn. `POST /api/v1/messages` iÃ§in mesajÄ± sadece veritabanÄ±na kaydetmek yerine, aynÄ± zamanda `IRealtimeNotificationService` aracÄ±lÄ±ÄŸÄ±yla eÅŸleÅŸen kullanÄ±cÄ±nÄ±n baÄŸlÄ± istemcisine anlÄ±k olarak gÃ¶nder).

### Testler (GerÃ§ek ZamanlÄ± MesajlaÅŸma) - GÃ¼ncelleme:
* [x] GerÃ§ek zamanlÄ± mesajlaÅŸma iÃ§in entegrasyon testleri yaz (Ã¶rneÄŸin, iki kullanÄ±cÄ±nÄ±n baÄŸlanÄ±p mesaj gÃ¶nderip alabilmesi).
* [x] YazÄ±lan testleri Ã§alÄ±ÅŸtÄ±r ve doÄŸrula.
* SignalR backend testlerinde, SignalR Hub baÄŸlantÄ±sÄ± kurarken JWT authentication zorunludur. Testlerde Ã¶nce bir kullanÄ±cÄ± register/login edilip JWT token alÄ±nmalÄ±, ardÄ±ndan SignalR HubConnection oluÅŸturulurken `options.AccessTokenProvider = () => Task.FromResult(token);` ile bu token kullanÄ±lmalÄ±dÄ±r.
* Bu yÃ¶ntem, hem .NET hem de context7 SignalR dokÃ¼mantasyonundaki best practice'lere uygundur.
* SignalR testleri bu ÅŸekilde gÃ¼ncellendi ve tÃ¼m testler baÅŸarÄ±yla geÃ§ti.

## 3. UÃ§tan Uca Åifreleme

### GÃ¶revler:

*   **Veri Modeli GÃ¼ncellemesi:**
    *   [ ] `PawMatch.Domain/User.cs` modeline `PublicKey` alanÄ± ekle (string veya byte[]).
    *   [ ] `PawMatch.Domain/Message.cs` modelindeki `Content` alanÄ±nÄ± ÅŸifrelenmiÅŸ veri iÃ§in ayarla (string/byte[]).
    *   [ ] `PawMatch.Domain/MessageKeyBundle.cs` gibi, mesajÄ±n ÅŸifrelenmiÅŸ simetrik oturum anahtarÄ±nÄ± ve diÄŸer ÅŸifreleme meta verilerini tutacak yeni bir model oluÅŸtur (Opsiyonel: eÄŸer her mesaj iÃ§in ayrÄ± bir oturum anahtarÄ± yÃ¶netilecekse).
    *   [ ] `AppDbContext.cs` iÃ§ine ilgili `DbSet`'leri ekle.
    *   [ ] VeritabanÄ± migrasyonlarÄ±nÄ± oluÅŸtur.

*   **Backend Servisleri ve Endpoint'ler (Kavramsal ve AltyapÄ±):**
    *   [ ] KullanÄ±cÄ±nÄ±n herkese aÃ§Ä±k anahtarÄ±nÄ± yÃ¼klemesi iÃ§in `UsersController`'a `POST /api/v1/users/publicKey` gibi bir endpoint ekle.
    *   [ ] Belirli bir kullanÄ±cÄ±nÄ±n herkese aÃ§Ä±k anahtarÄ±nÄ± almasÄ± iÃ§in `UsersController`'a `GET /api/v1/users/{userId}/publicKey` gibi bir endpoint ekle.
    *   [ ] `MessageService`'i, gelen ÅŸifrelenmiÅŸ mesaj iÃ§eriÄŸini ve ÅŸifrelenmiÅŸ oturum anahtarÄ±nÄ± iÅŸleyecek ÅŸekilde gÃ¼ncelle. Ä°Ã§eriÄŸi Ã§Ã¶zmeye Ã§alÄ±ÅŸmayacak, sadece kaydedecek.
    *   [ ] `MessageService`'i, ÅŸifrelenmiÅŸ mesajlarÄ± ve ilgili anahtar paketlerini istemciye dÃ¶ndÃ¼recek ÅŸekilde gÃ¼ncelle.
    *   [ ] Herkese aÃ§Ä±k anahtarlarÄ± gÃ¼venli bir ÅŸekilde yÃ¶netmek ve daÄŸÄ±tmak iÃ§in arka plan mekanizmalarÄ±nÄ± dÃ¼ÅŸÃ¼n.

### Testler (UÃ§tan Uca Åifreleme):

*   [ ] ÅifrelenmiÅŸ mesajlarÄ±n doÄŸru ÅŸekilde saklandÄ±ÄŸÄ±nÄ± ve alÄ±ndÄ±ÄŸÄ±nÄ± doÄŸrulayan entegrasyon testleri yaz (iÃ§eriÄŸi Ã§Ã¶zmeden, sadece verinin bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ kontrol ederek).
*   [ ] Herkese aÃ§Ä±k anahtar yÃ¼kleme ve indirme endpoint'leri iÃ§in testler yaz.
*   [ ] YazÄ±lan testleri Ã§alÄ±ÅŸtÄ±r ve doÄŸrula.

## 4. Pass Diyerek GeÃ§tiklerimizi Bir SÃ¼re Sonra Tekrardan KullanÄ±cÄ± KarÅŸÄ±sÄ±na Ã‡Ä±karma

### GÃ¶revler:

*   [x] `DiscoverService.cs` GeliÅŸtirmesi:
    *   [x] `DiscoverService` iÃ§indeki `DiscoverUsersAsync` (tekil keÅŸif metodu) gÃ¼ncellenecektir.
    *   [x] Bu metot, `UserSwipe` tablosundaki `SwipeDate` alanÄ±nÄ± kullanarak, belirli bir "geÃ§iÅŸ sÃ¼resinden" (`SwipeReappearDurationDays` gibi `appsettings.json`'dan okunacak) daha eski olan `IsLiked = false` (geÃ§me) kayÄ±tlarÄ±nÄ± hariÃ§ tutmamalÄ±dÄ±r. BÃ¶ylece, kullanÄ±cÄ±lar belirli bir sÃ¼re sonra tekrar keÅŸif listesinde gÃ¶rÃ¼nebilir.
    *   [x] **YapÄ±landÄ±rma**: `appsettings.json` iÃ§ine `SwipeReappearDurationDays` ayarÄ±nÄ± ekle (Ã¶rn. `90` gÃ¼n).

### Testler (GeÃ§ilenleri Tekrar GÃ¶sterme):

*   [x] `PawMatch.Tests/DiscoverServiceTests.cs` (veya ilgili test dosyasÄ±na) geÃ§ilen kullanÄ±cÄ±larÄ±n belirli bir sÃ¼re sonra tekrar keÅŸif listesinde gÃ¶rÃ¼ndÃ¼ÄŸÃ¼nÃ¼ doÄŸrulayan testler ekle.
*   [x] YazÄ±lan testleri Ã§alÄ±ÅŸtÄ±r ve doÄŸrula.

## 5. KullanÄ±cÄ± Response RefaktÃ¶rÃ¼ ve DTO AyrÄ±mÄ±

- TÃ¼m kullanÄ±cÄ± response'larÄ± UserPublicDto (public) ve UserPrivateDto (private) ile dÃ¶nmektedir.
- Hassas bilgiler (email, passwordHash) sadece UserPrivateDto'da bulunur ve sadece login/register/profile response'larÄ±nda yer alÄ±r.
- KeÅŸif, eÅŸleÅŸme ve genel kullanÄ±cÄ± listelerinde sadece UserPublicDto ile public alanlar yer alÄ±r.
- HiÃ§bir endpoint doÄŸrudan domain User veya eski UserDto ile veri dÃ¶ndÃ¼rmez.
- Mapping iÅŸlemleri merkezi UserPublicDtoMapper ve UserPrivateDtoMapper ile yapÄ±lÄ±r.

### Response Ã–rnekleri

#### 1. Public (KeÅŸif/EÅŸleÅŸme)
```json
{
  "user": {
    "id": 2,
    "name": "Ali",
    "bio": "KuÅŸsever",
    "hasPet": false,
    "hasProfile": true,
    "photoIds": ["fileid3"],
    "age": null,
    "gender": null
  }
}
```
#### 2. Private (Login/Register/Profile)
```json
{
  "userPrivate": {
    "id": 1,
    "name": "Berkan",
    "email": "berkan@example.com",
    "bio": "Kedisever",
    "hasPet": true,
    "hasProfile": true,
    "photoIds": ["fileid1", "fileid2"],
    "age": null,
    "gender": null,
    "passwordHash": "..."
  }
}
```
</file>

<file path="messagesystem.md">
# PawMatch Chat Sistemi: API ve SignalR AkÄ±ÅŸÄ±

AÅŸaÄŸÄ±da, PawMatch projesinde chat/messaging sisteminin hem REST API hem de SignalR ile nasÄ±l birlikte Ã§alÄ±ÅŸtÄ±ÄŸÄ± ÅŸematik olarak gÃ¶sterilmiÅŸtir.

---

```mermaid
sequenceDiagram
    participant FE as "Frontend (Flutter/Web)"
    participant API as "Backend API (REST)"
    participant HUB as "SignalR ChatHub"
    participant DB as "Database"

    Note over FE: KullanÄ±cÄ± uygulamada chat ekranÄ±nda

    FE->>API: GET /api/v1/messages/{matchId}\n(Mesaj geÃ§miÅŸini al)
    API->>DB: MesajlarÄ± getir (matchId)
    DB-->>API: Mesaj listesi (MessageDto[])
    API-->>FE: JSON mesaj listesi

    FE->>HUB: SignalR ile baÄŸlan (connect)
    FE->>HUB: SendMessage(matchId, content)
    HUB->>DB: Yeni mesajÄ± kaydet
    DB-->>HUB: KayÄ±t baÅŸarÄ±lÄ± (Message)
    HUB-->>FE: ReceiveMessage (yeni mesajÄ± anlÄ±k ilet)
    HUB-->>API: (Opsiyonel) Bildirim/Log/Ä°statistik
    Note over FE: FE, ReceiveMessage ile anlÄ±k mesajÄ± gÃ¶sterir

    Note over FE: Tipler ve DTO'lar\nHem API hem SignalR\nda MessageDto, MatchDto\ngibi ortak yapÄ±lar kullanÄ±lÄ±r
```

---

## AÃ§Ä±klama
- KullanÄ±cÄ± chat ekranÄ±nda ilk aÃ§Ä±lÄ±ÅŸta API'dan mesaj geÃ§miÅŸini Ã§eker.
- SignalR ile baÄŸlanÄ±r, yeni mesaj gÃ¶nderir.
- SignalR Ã¼zerinden gelen mesajlar anlÄ±k olarak ekranda gÃ¶sterilir.
- Hem API hem SignalR tarafÄ±nda aynÄ± DTO'lar (Ã¶r. MessageDto) kullanÄ±lÄ±r, tip tutarlÄ±lÄ±ÄŸÄ± saÄŸlanÄ±r.

---

**Not:**
- Bu yapÄ±, modern chat uygulamalarÄ±nda yaygÄ±n olarak kullanÄ±lÄ±r.
- API geÃ§miÅŸ ve offline mesajlar iÃ§in, SignalR ise anlÄ±k iletiÅŸim iÃ§in kullanÄ±lÄ±r.
- Tip karÄ±ÅŸÄ±klÄ±ÄŸÄ± olmamasÄ± iÃ§in backend'de tÃ¼m id alanlarÄ± int/int? olarak tanÄ±mlanmÄ±ÅŸtÄ±r.
</file>

<file path="PawMatch.Api/.gitignore">
# Build
bin/
obj/

# User Secrets or local settings (optional)
appsettings.Development.json
appsettings.Local.json
appsettings.*.local.json

# Swagger generated files (if any)
swagger.json
swagger-ui/

# Uploaded files (if handled locally)
wwwroot/uploads/
uploads/
</file>

<file path="PawMatch.Api/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5433;Database=pawmatch;Username=postgres;Password=mandaci12"
  },
  "AppSettings": {
    "SwipeExclusionDurationDays": 30,
    "SwipeReappearDurationDays": 90
  }
}
</file>

<file path="PawMatch.Api/Controllers/BaseController.cs">
using Microsoft.AspNetCore.Mvc;
using System.Linq;
using System.Security.Claims;
namespace PawMatch.Api.Controllers
{
    public abstract class BaseController : ControllerBase
    {
        /// <summary>
        /// JWT'den userId'yi Ã§eken yardÄ±mcÄ± fonksiyon (tÃ¼m controllerlarda kullanÄ±labilir)
        /// </summary>
        protected int? GetUserIdFromClaims()
        {
            var userIdClaim = User.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
            if (!string.IsNullOrEmpty(userIdClaim) && int.TryParse(userIdClaim, out var userId))
                return userId;
            return null;
        }
    }
}
</file>

<file path="PawMatch.Api/Controllers/MatchesController.cs">
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using System.Collections.Generic;
using System.Security.Claims;
using System.Threading.Tasks;
namespace PawMatch.Api.Controllers
{
    [ApiController]
    [Route("api/v1/matches")]
    [Authorize]
    public class MatchesController : BaseController
    {
        private readonly IMatchService _matchService;
        private readonly IDiscoverService _discoverService;
        public MatchesController(IMatchService matchService, IDiscoverService discoverService)
        {
            _matchService = matchService;
            _discoverService = discoverService;
        }
        /// <summary>
        /// KullanÄ±cÄ±/pet kartlarÄ±nÄ± listeler (discover).
        /// </summary>
        /// <param name="maxDistanceKm">Maksimum mesafe (opsiyonel)</param>
        /// <param name="offset">Sayfalama baÅŸlangÄ±cÄ± (opsiyonel)</param>
        /// <param name="limit">Sayfa boyutu (opsiyonel)</param>
        /// <param name="preferredPetType">Tercih edilen evcil hayvan tÃ¼rÃ¼ (opsiyonel)</param>
        /// <returns>KullanÄ±cÄ± ve pet kartlarÄ±</returns>
        [HttpGet("discover")]
        public async Task<IActionResult> Discover([FromQuery] int? maxDistanceKm, [FromQuery] int? offset, [FromQuery] int? limit, [FromQuery] string? preferredPetType)
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "KullanÄ±cÄ± kimliÄŸi doÄŸrulanamadÄ±." });
            var result = await _discoverService.DiscoverUsersAsync(userId.Value, maxDistanceKm, preferredPetType, offset, limit);
            return Ok(new { status = "success", data = result, error = (string)null });
        }
        /// <summary>
        /// BeÄŸenme/geÃ§me iÅŸlemi yapar.
        /// </summary>
        /// <param name="dto">BeÄŸenme/geÃ§me bilgisi</param>
        /// <returns>EÅŸleÅŸme sonucu</returns>
        [HttpPost]
        public async Task<IActionResult> LikeOrPass([FromBody] MatchActionDto dto)
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "KullanÄ±cÄ± kimliÄŸi doÄŸrulanamadÄ±." });
            try
            {
                var result = await _matchService.LikeOrPassAsync(userId.Value, dto);
                return Ok(new { status = "success", data = result, error = (string)null });
            }
            catch (UnauthorizedAccessException ex)
            {
                return Unauthorized(new { status = "error", error = ex.Message });
            }
        }
        [HttpGet]
        public async Task<IActionResult> GetMatches()
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "KullanÄ±cÄ± kimliÄŸi doÄŸrulanamadÄ±." });
            var matches = await _matchService.GetMatchesForUserAsync(userId.Value);
            return Ok(new { data = new { matches }, status = "success" });
        }
    }
}
</file>

<file path="PawMatch.Api/Controllers/MessagesController.cs">
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using PawMatch.Domain;
namespace PawMatch.Api.Controllers
{
    [ApiController]
    [Route("api/v1/messages")]
    [Authorize]
    public class MessagesController : BaseController
    {
        private readonly IMessageService _messageService;
        private readonly IUserService _userService;
        private readonly IMatchService _matchService;
        public MessagesController(IMessageService messageService, IUserService userService, IMatchService matchService)
        {
            _messageService = messageService;
            _userService = userService;
            _matchService = matchService;
        }
        /// <summary>
        /// Belirli bir eÅŸleÅŸmeye ait mesajlarÄ± listeler.
        /// </summary>
        /// <param name="matchId">EÅŸleÅŸme ID</param>
        /// <param name="offset">Sayfalama baÅŸlangÄ±cÄ± (opsiyonel)</param>
        /// <param name="limit">Sayfa boyutu (opsiyonel, default 20)</param>
        /// <returns>Mesaj listesi</returns>
        [HttpGet("{matchId}")]
        public async Task<IActionResult> GetMessages(int matchId, [FromQuery] int offset = 0, [FromQuery] int limit = 20)
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "KullanÄ±cÄ± kimliÄŸi doÄŸrulanamadÄ±." });
            // KullanÄ±cÄ± bu eÅŸleÅŸmenin parÃ§asÄ± mÄ± kontrol et
            var match = await _matchService.GetMatchByIdAsync(matchId);
            if (match == null || (match.User1Id != userId && match.User2Id != userId))
                return Forbid();
            // KarÅŸÄ± tarafÄ±n userId'sini bul
            int otherUserId = (match.User1Id == userId) ? match.User2Id : match.User1Id;
            // MesajlarÄ± getir
            var messages = await _messageService.GetChatHistoryAsync(userId.Value, otherUserId);
            var senderIds = messages.Select(m => m.SenderId).Distinct().ToList();
            var senders = await _userService.GetUsersByIdsAsync(senderIds);
            var senderMap = senders.ToDictionary(
                u => u.Id,
                u => UserPublicDtoMapper.ToPublicDto(
                    u,
                    u.GetPhotoIds(),
                    u.GetPetIds()
                )
            );
            var messageDtos = messages.Skip(offset).Take(limit).Select(m => MessageDtoMapper.ToDto(m, senderMap[m.SenderId])).ToList();
            return Ok(new { data = messageDtos, status = "success" });
        }
        /// <summary>
        /// Mesaj gÃ¶nderir.
        /// </summary>
        /// <param name="request">Mesaj gÃ¶nderme isteÄŸi</param>
        /// <returns>OluÅŸturulan mesaj</returns>
        public class SendMessageRequest
        {
            public int MatchId { get; set; }
            public string Content { get; set; }
        }
        [HttpPost]
        public async Task<IActionResult> SendMessage([FromBody] SendMessageRequest request)
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "KullanÄ±cÄ± kimliÄŸi doÄŸrulanamadÄ±." });
            // KullanÄ±cÄ± bu eÅŸleÅŸmenin parÃ§asÄ± mÄ± kontrol et
            var match = await _matchService.GetMatchByIdAsync(request.MatchId);
            if (match == null || (match.User1Id != userId && match.User2Id != userId))
                return Forbid();
            int recipientId = (match.User1Id == userId) ? match.User2Id : match.User1Id;
            var message = await _messageService.SendMessageAsync(userId.Value, recipientId, request.Content);
            var sender = await _userService.GetUserByIdAsync(userId.Value);
            var senderDto = UserPublicDtoMapper.ToPublicDto(sender, sender.GetPhotoIds(),sender.GetPetIds());
            var messageDto = MessageDtoMapper.ToDto(message, senderDto);
            return Ok(new { data = messageDto, status = "success" });
        }
    }
}
</file>

<file path="PawMatch.Api/Controllers/PhotosController.cs">
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using System;
using System.IO;
using System.Threading.Tasks;
using System.Linq;
namespace PawMatch.Api.Controllers
{
    [ApiController]
    [Route("api/v1/photos")]
    [Authorize]
    public class PhotosController : BaseController
    {
        private readonly IPhotoService _photoService;
        public PhotosController(IPhotoService photoService)
        {
            _photoService = photoService;
        }
        public class UserPhotoUploadRequest
        {
            public IFormFile File { get; set; }
        }
        public class PetPhotoUploadRequest
        {
            public IFormFile File { get; set; }
        }
        [HttpGet("{id}")]
        public async Task<IActionResult> GetPhoto(int id)
        {
            try
            {
                var userId = GetUserIdFromClaims();
                if (userId == null)
                    return Unauthorized(new { status = "error", error = "KullanÄ±cÄ± kimliÄŸi doÄŸrulanamadÄ±." });
                var photoStream = await _photoService.GetPhotoStreamAsync(id, userId.Value);
                // Content-Type ve Content-Disposition ayarla
                // (Tipi DB'den de Ã§ekebilirsin, burada Ã¶rnek olarak image/jpeg)
                return File(photoStream, "image/jpeg", enableRangeProcessing: false);
            }
            catch (Exception ex)
            {
                return NotFound(new { status = "error", error = ex.Message });
            }
        }
        [HttpDelete("{id}")]
        public async Task<IActionResult> DeletePhoto(int id)
        {
            try
            {
                await _photoService.DeletePhotoAsync(id);
                return Ok(new { status = "success" });
            }
            catch (Exception ex)
            {
                return NotFound(new { status = "error", error = ex.Message });
            }
        }
        // KullanÄ±cÄ±ya fotoÄŸraf yÃ¼kleme
        [HttpPost("user")]
        public async Task<IActionResult> UploadUserPhoto([FromForm] UserPhotoUploadRequest request)
        {
            var file = request.File;
            if (file == null || (file.ContentType != "image/jpeg" && file.ContentType != "image/png"))
                return BadRequest(new { status = "error", error = "Sadece JPEG veya PNG dosya yÃ¼klenebilir." });
            if (file.Length > 5 * 1024 * 1024)
                return BadRequest(new { status = "error", error = "Dosya boyutu 5 MB'dan bÃ¼yÃ¼k olamaz." });
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "KullanÄ±cÄ± kimliÄŸi doÄŸrulanamadÄ±." });
            using var stream = file.OpenReadStream();
            var result = await _photoService.UploadPhotoAsync(
                new PhotoUploadDto { UserId = userId.Value },
                stream,
                file.FileName,
                file.ContentType
            );
            return Ok(new ApiResponse<PhotoDto> { Data = result, Status = "success" });
        }
        // Pet'e fotoÄŸraf yÃ¼kleme
        [HttpPost("users/pets/{petId}/photos")]
        [Authorize]
        public async Task<IActionResult> UploadPetPhoto(int petId, [FromForm] PetPhotoUploadRequest request)
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "KullanÄ±cÄ± kimliÄŸi doÄŸrulanamadÄ±." });
            // Dummy sahiplik kontrolÃ¼ (gerÃ§ek uygulamada DB'den kontrol edilmeli)
            // if (!await _petService.UserOwnsPet(userId.Value, petId)) return Forbid();
            var file = request.File;
            if (file == null || (file.ContentType != "image/jpeg" && file.ContentType != "image/png"))
                return BadRequest(new { status = "error", error = "Sadece JPEG veya PNG dosya yÃ¼klenebilir." });
            if (file.Length > 5 * 1024 * 1024)
                return BadRequest(new { status = "error", error = "Dosya boyutu 5 MB'dan bÃ¼yÃ¼k olamaz." });
            using var stream = file.OpenReadStream();
            var result = await _photoService.UploadPhotoAsync(
                new PhotoUploadDto { PetId = petId },
                stream,
                file.FileName,
                file.ContentType
            );
            return Ok(new ApiResponse<PhotoDto> { Data = result, Status = "success" });
        }
    }
}
</file>

<file path="PawMatch.Api/Controllers/UsersController.cs">
using Microsoft.AspNetCore.Mvc;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using System;
using System.Threading.Tasks;
using System.Linq;
using Microsoft.AspNetCore.Authorization;
using System.Security.Claims;
using PawMatch.Domain;
namespace PawMatch.Api.Controllers
{
    [ApiController]
    [Route("api/v1/users")]
    public class UsersController : BaseController
    {
        private readonly IUserService _userService;
        public UsersController(IUserService userService)
        {
            _userService = userService;
        }
        /// <summary>
        /// KullanÄ±cÄ± giriÅŸi yapar.
        /// </summary>
        /// <remarks>
        /// BaÅŸarÄ±lÄ± yanÄ±t Ã¶rneÄŸi:
        /// 
        ///     POST /api/v1/users/login
        ///     {
        ///         "email": "kullanici@example.com",
        ///         "password": "ÅŸifre"
        ///     }
        /// 
        /// YanÄ±t:
        ///     {
        ///         "status": "success",
        ///         "data": {
        ///             "user": {
        ///                 "id": 1,
        ///                 "name": "Ali Veli",
        ///                 "email": "kullanici@example.com",
        ///                 "hasProfile": true
        ///             },
        ///             "token": "jwt-token-string"
        ///         },
        ///         "error": null
        ///     }
        /// </remarks>
        /// <param name="dto">KullanÄ±cÄ± giriÅŸ bilgileri</param>
        /// <returns>KullanÄ±cÄ± ve JWT token</returns>
        [HttpPost("login")]
        public async Task<IActionResult> Login([FromBody] UserLoginDto dto)
        {
            try
            {
                var result = await _userService.LoginAsync(dto);
                return Ok(new { data = result, status = "success", error = (string)null });
            }
            catch (UnauthorizedAccessException ex)
            {
                return Unauthorized(new { data = (object)null, status = "error", error = ex.Message });
            }
        }
        /// <summary>
        /// KullanÄ±cÄ± profilini gÃ¼nceller.
        /// </summary>
        /// <remarks>
        ///     PATCH /api/v1/users/profile
        ///     {
        ///         "name": "Ali Veli",
        ///         "bio": "KÄ±sa biyografi",
        ///         "hasPet": true
        ///     }
        /// 
        /// YanÄ±t:
        ///     {
        ///         "status": "success",
        ///         "data": {
        ///             "user": {
        ///                 "id": 1,
        ///                 "name": "Ali Veli",
        ///                 "email": "kullanici@example.com",
        ///                 "hasProfile": true
        ///             },
        ///             "token": "jwt-token-string"
        ///         },
        ///         "error": null
        ///     }
        /// </remarks>
        /// <param name="dto">Profil gÃ¼ncelleme bilgileri</param>
        /// <returns>GÃ¼ncellenmiÅŸ kullanÄ±cÄ± ve JWT token</returns>
        [HttpPatch("profile")]
        [Authorize]
        public async Task<IActionResult> UpdateProfile([FromBody] UpdateProfileDto dto)
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "KullanÄ±cÄ± kimliÄŸi doÄŸrulanamadÄ±." });
            var result = await _userService.UpdateProfileAsync(userId.Value, dto);
            return Ok(new { data = result, status = "success", error = (string)null });
        }
        /// <summary>
        /// Yeni kullanÄ±cÄ± kaydÄ± oluÅŸturur.
        /// </summary>
        /// <remarks>
        ///     POST /api/v1/users/register
        ///     {
        ///         "name": "Ali Veli",
        ///         "email": "kullanici@example.com",
        ///         "password": "sifre123"
        ///     }
        /// 
        /// YanÄ±t:
        ///     {
        ///         "status": "success",
        ///         "data": {
        ///             "user": {
        ///                 "id": 1,
        ///                 "name": "Ali Veli",
        ///                 "email": "kullanici@example.com",
        ///                 "hasProfile": false
        ///             },
        ///             "token": "jwt-token-string"
        ///         },
        ///         "error": null
        ///     }
        /// </remarks>
        /// <param name="dto">KullanÄ±cÄ± kayÄ±t bilgileri</param>
        /// <returns>KayÄ±tlÄ± kullanÄ±cÄ± ve JWT token</returns>
        [HttpPost("register")]
        public async Task<IActionResult> Register([FromBody] UserRegisterDto dto)
        {
            var result = await _userService.RegisterAsync(dto);
            return Ok(new { data = result, status = "success", error = (string)null });
        }
        /// <summary>
        /// KullanÄ±cÄ±nÄ±n kendi hesabÄ±nÄ± siler.
        /// </summary>
        /// <remarks>
        /// Sadece kimliÄŸi doÄŸrulanmÄ±ÅŸ kullanÄ±cÄ±lar kendi hesaplarÄ±nÄ± silebilir.
        /// YanÄ±t:
        ///     {
        ///         "status": "success",
        ///         "data": null,
        ///         "error": null
        ///     }
        /// </remarks>
        /// <returns>BaÅŸarÄ± veya hata mesajÄ±</returns>
        [HttpDelete("me")]
        [Authorize]
        public async Task<IActionResult> DeleteMyAccount()
        {
            var userId = GetUserIdFromClaims();
            if (userId == null)
                return Unauthorized(new { status = "error", error = "KullanÄ±cÄ± kimliÄŸi doÄŸrulanamadÄ±." });
            try
            {
                await _userService.DeleteUserAsync(userId.Value);
                return Ok(new { status = "success", data = (object)null, error = (string)null });
            }
            catch (KeyNotFoundException ex)
            {
                return NotFound(new { status = "error", error = ex.Message });
            }
            catch (Exception ex)
            {
                // Log the exception (e.g., using a logger)
                return StatusCode(500, new { status = "error", error = "Hesap silinirken bir hata oluÅŸtu." });
            }
        }
        [HttpGet("me")]
        [Authorize]
        public async Task<IActionResult> GetMyProfile()
        {
            var userIdClaim = User.Claims.FirstOrDefault(c => c.Type == ClaimTypes.NameIdentifier);
            if (userIdClaim == null || !int.TryParse(userIdClaim.Value, out var userId))
            {
                return Unauthorized(new ApiResponse<object> { Status = "Error", Error = "Invalid user ID in token." });
            }
            var user = await _userService.GetUserByIdAsync(userId);
            var userDto = UserPrivateDtoMapper.ToPrivateDto(user, user.GetPhotoIds(), user.GetPetIds());
            return Ok(new ApiResponse<UserPrivateDto> { Data = userDto, Status = "Success" });
        }
    }
}
</file>

<file path="PawMatch.Api/Controllers/WeatherForecastController.cs">
using Microsoft.AspNetCore.Mvc;
namespace PawMatch.Api.Controllers;
[ApiController]
[Route("[controller]")]
public class WeatherForecastController : BaseController
{
    private static readonly string[] Summaries = new[]
    {
        "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"
    };
    private readonly ILogger<WeatherForecastController> _logger;
    public WeatherForecastController(ILogger<WeatherForecastController> logger)
    {
        _logger = logger;
    }
    [HttpGet(Name = "GetWeatherForecast")]
    public IEnumerable<WeatherForecast> Get()
    {
        return Enumerable.Range(1, 5).Select(index => new WeatherForecast
        {
            Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = Summaries[Random.Shared.Next(Summaries.Length)]
        })
        .ToArray();
    }
}
</file>

<file path="PawMatch.Api/Hubs/ChatHub.cs">
using Microsoft.AspNetCore.SignalR;
using System.Collections.Concurrent;
using System.Security.Claims;
using Microsoft.AspNetCore.Authorization;
using PawMatch.Application.Interfaces;
using PawMatch.Application.DTOs;
using PawMatch.Domain;
namespace PawMatch.Api.Hubs
{
    [Authorize]
    public class ChatHub : Hub
    {
        // KullanÄ±cÄ± ID'lerini baÄŸlantÄ± ID'leriyle iliÅŸkilendirmek iÃ§in bir mekanizma
        private static readonly ConcurrentDictionary<string, string> _connectedUsers = new ConcurrentDictionary<string, string>();
        private readonly IMessageService _messageService;
        private readonly IUserService _userService;
        public ChatHub(IMessageService messageService, IUserService userService)
        {
            _messageService = messageService;
            _userService = userService;
        }
        public override async Task OnConnectedAsync()
        {
            var userId = Context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userId != null)
            {
                _connectedUsers.TryAdd(userId, Context.ConnectionId);
                await Groups.AddToGroupAsync(Context.ConnectionId, userId);
            }
            await base.OnConnectedAsync();
        }
        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            var userId = Context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (userId != null)
            {
                _connectedUsers.TryRemove(userId, out _);
                await Groups.RemoveFromGroupAsync(Context.ConnectionId, userId);
            }
            await base.OnDisconnectedAsync(exception);
        }
        // SignalR ile doÄŸrudan mesaj gÃ¶nderme fonksiyonu
        public async Task SendMessageToUser(int recipientUserId, string content)
        {
            var senderIdStr = Context.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (!int.TryParse(senderIdStr, out int senderId))
                throw new HubException("KullanÄ±cÄ± kimliÄŸi doÄŸrulanamadÄ±.");
            if (senderId == recipientUserId)
                throw new HubException("Kendinize mesaj gÃ¶nderemezsiniz.");
            // KullanÄ±cÄ±lar var mÄ± kontrolÃ¼
            var sender = await _userService.GetUserByIdAsync(senderId);
            var recipient = await _userService.GetUserByIdAsync(recipientUserId);
            if (sender == null || recipient == null)
                throw new HubException("KullanÄ±cÄ±(lar) bulunamadÄ±.");
            // MesajÄ± kaydet
            var message = await _messageService.SendMessageAsync(senderId, recipientUserId, content);
            // DTO mapping
            var senderDto = UserPublicDtoMapper.ToPublicDto(sender, sender.GetPhotoIds(), sender.GetPetIds());
            var messageDto = MessageDtoMapper.ToDto(message, senderDto);
            // Hem gÃ¶nderen hem alÄ±cÄ±ya ilet
            await Clients.User(senderId.ToString()).SendAsync("ReceiveMessage", messageDto);
            await Clients.User(recipientUserId.ToString()).SendAsync("ReceiveMessage", messageDto);
        }
        // Ä°leride mesaj gÃ¶nderme ve alma metodlarÄ± buraya eklenebilir.
        // Ã–rneÄŸin: public async Task SendMessageToUser(string recipientUserId, string message) { ... }
    }
}
</file>

<file path="PawMatch.Api/PawMatch.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.*" />
        <PackageReference Include="Microsoft.AspNetCore.SignalR" Version="1.2.0" />
        <PackageReference Include="Swashbuckle.AspNetCore" Version="6.*" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\PawMatch.Application\PawMatch.Application.csproj" />
      <ProjectReference Include="..\PawMatch.Domain\PawMatch.Domain.csproj" />
      <ProjectReference Include="..\PawMatch.Infrastructure\PawMatch.Infrastructure.csproj" />
    </ItemGroup>

</Project>
</file>

<file path="PawMatch.Api/PawMatch.Api.http">
@PawMatch.Api_HostAddress = http://localhost:5193

GET {{PawMatch.Api_HostAddress}}/weatherforecast/
Accept: application/json

###
</file>

<file path="PawMatch.Api/Properties/launchSettings.json">
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:44725",
      "sslPort": 44399
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "http://localhost:5193",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:7073;http://localhost:5193",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "Testing": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "launchUrl": "swagger",
      "applicationUrl": "https://localhost:6000;http://localhost:6001",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Testing"
      }
    }
  }
}
</file>

<file path="PawMatch.Api/Services/SignalRNotificationService.cs">
using System.Threading.Tasks;
using Microsoft.AspNetCore.SignalR;
using PawMatch.Application.Interfaces;
using PawMatch.Application.DTOs;
using PawMatch.Domain;
using PawMatch.Api.Hubs;
namespace PawMatch.Api.Services
{
    public class SignalRNotificationService : IRealtimeNotificationService
    {
        private readonly IHubContext<ChatHub> _hubContext;
        public SignalRNotificationService(IHubContext<ChatHub> hubContext)
        {
            _hubContext = hubContext;
        }
        public async Task SendMatchNotificationAsync(int user1Id, int user2Id, MatchResultDto matchResult)
        {
            await _hubContext.Clients.User(user1Id.ToString()).SendAsync("ReceiveMatchNotification", matchResult);
            await _hubContext.Clients.User(user2Id.ToString()).SendAsync("ReceiveMatchNotification", matchResult);
        }
        public async Task SendMessageAsync(int recipientId, Message message)
        {
            await _hubContext.Clients.User(recipientId.ToString()).SendAsync("ReceiveMessage", message);
        }
    }
}
</file>

<file path="PawMatch.Api/WeatherForecast.cs">
namespace PawMatch.Api;
public class WeatherForecast
{
    public DateOnly Date { get; set; }
    public int TemperatureC { get; set; }
    public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
    public string? Summary { get; set; }
}
</file>

<file path="PawMatch.Application/.gitignore">
# Build
bin/
obj/

# Any cached metadata or analysis results
*.cache
</file>

<file path="PawMatch.Application/Class1.cs">
namespace PawMatch.Application;
public class Class1
{
}
</file>

<file path="PawMatch.Application/DTOs/DiscoverUserPetDto.cs">
namespace PawMatch.Application.DTOs
{
    public class DiscoverUserPetDto
    {
        public UserPublicDto User { get; set; }
        public DiscoverPetDto Pet { get; set; } // null olabilir
    }
    public class DiscoverPetDto
    {
        public string Name { get; set; }
        public string Type { get; set; }
        public int Age { get; set; }
        public List<DiscoverPhotoDto> Photos { get; set; }
    }
    public class DiscoverPhotoDto
    {
        public string? GoogleDriveFileId { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/MatchActionDto.cs">
namespace PawMatch.Application.DTOs
{
    public class MatchActionDto
    {
        public int User1Id { get; set; }
        public int User2Id { get; set; }
        public bool Liked { get; set; }
    }
    public class MatchResultDto
    {
        public int MatchId { get; set; }
        public bool Confirmed { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/MatchDto.cs">
namespace PawMatch.Application.DTOs
{
    public class MatchDto
    {
        public int MatchId { get; set; }
        public bool Confirmed { get; set; }
        public UserPublicDto User { get; set; } // KarÅŸÄ± taraf
    }
}
</file>

<file path="PawMatch.Application/DTOs/MessageDto.cs">
using System;
using PawMatch.Domain;
namespace PawMatch.Application.DTOs
{
    public class MessageDto
    {
        public int Id { get; set; }
        public int SenderId { get; set; }
        public UserPublicDto Sender { get; set; }
        public string Content { get; set; }
        public DateTime Timestamp { get; set; }
        public bool IsRead { get; set; }
    }
    public static class MessageDtoMapper
    {
        public static MessageDto ToDto(Message message, UserPublicDto sender)
        {
            return new MessageDto
            {
                Id = message.Id,
                SenderId = message.SenderId,
                Sender = sender,
                Content = message.Content,
                Timestamp = message.Timestamp,
                IsRead = message.IsRead
            };
        }
    }
}
</file>

<file path="PawMatch.Application/DTOs/PetDto.cs">
namespace PawMatch.Application.DTOs
{
    public class PetDto
    {
        public int Id { get; set; }
        public int UserId { get; set; } // Owner's ID
        public string Name { get; set; }
        public string Breed { get; set; }
        public int Age { get; set; }
        public string Description { get; set; }
        public List<string> PhotoIds { get; set; } // Google Drive File IDs
    }
}
</file>

<file path="PawMatch.Application/DTOs/PhotoDto.cs">
using System;
namespace PawMatch.Application.DTOs
{
    public class PhotoDto
    {
        public int Id { get; set; }
        public string FileName { get; set; }
        public string ContentType { get; set; }
        public string GoogleDriveFileId { get; set; }
        public DateTime UploadDate { get; set; }
        public int? UserId { get; set; }
        public int? PetId { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/PhotoUploadDto.cs">
namespace PawMatch.Application.DTOs
{
    public class PhotoUploadDto
    {
        public int? UserId { get; set; }
        public int? PetId { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/UpdateProfileDto.cs">
using System.ComponentModel.DataAnnotations;
namespace PawMatch.Application.DTOs
{
    public class UpdateProfileDto
    {
        [Required]
        public string Name { get; set; }
        [StringLength(500)]
        public string Bio { get; set; }
        public bool HasPet { get; set; }
        // Ã–rnek: public int? Age { get; set; }
        // Ã–rnek: public string? Gender { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/UserAuthResponseDto.cs">
namespace PawMatch.Application.DTOs
{
    public class ApiResponse<T>
    {
        public T Data { get; set; }
        public string Status { get; set; }
        public object? Error { get; set; } // Can be null or an error object
    }
    public class UserAuthResponseDto
    {
        public UserPrivateDto UserPrivate { get; set; }
        public string Token { get; set; }
    }
    public class UserPrivateDto : UserBaseDto
    {
        public string Email { get; set; }
        public string PasswordHash { get; set; } // Sadece burada!
        public List<int> PetIds { get; set; }
    }
    public static class UserPrivateDtoMapper
    {
        public static UserPrivateDto ToPrivateDto(PawMatch.Domain.User user, List<int> photoIds, List<int> petIds)
        {
            return new UserPrivateDto
            {
                Id = user.Id,
                Name = user.Name,
                Email = user.Email,
                Bio = user.Bio,
                HasPet = user.HasPet,
                HasProfile = user.HasProfile,
                PhotoIds = photoIds,
                PetIds = petIds,
                // Age, Gender eklenirse buraya eklenir
                PasswordHash = user.PasswordHash
            };
        }
    }
}
</file>

<file path="PawMatch.Application/DTOs/UserBaseDto.cs">
using System.Collections.Generic;
namespace PawMatch.Application.DTOs
{
    public class UserBaseDto
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string? Bio { get; set; }
        public bool HasPet { get; set; }
        public bool HasProfile { get; set; }
        public List<int> PhotoIds { get; set; }
        public int? Age { get; set; }
        public string? Gender { get; set; }
        public List<int> PetIds { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/UserLoginDto.cs">
using System.ComponentModel.DataAnnotations;
namespace PawMatch.Application.DTOs
{
    public class UserLoginDto
    {
        [Required, EmailAddress]
        public string Email { get; set; }
        [Required]
        public string Password { get; set; }
    }
}
</file>

<file path="PawMatch.Application/DTOs/UserPublicDto.cs">
using System.Collections.Generic;
using PawMatch.Domain;
namespace PawMatch.Application.DTOs
{
    public class UserPublicDto : UserBaseDto
    {
        // Sadece public alanlar, ekstra yok
    }
    public static class UserPublicDtoMapper
    {
        public static UserPublicDto ToPublicDto(User user, List<int> photoIds, List<int> petIds)
        {
            return new UserPublicDto
            {
                Id = user.Id,
                Name = user.Name,
                Bio = user.Bio,
                HasPet = user.HasPet,
                HasProfile = user.HasProfile,
                PhotoIds = photoIds,
                PetIds = petIds,
                Age = null, // user.Age,
                Gender = null // user.Gender
            };
        }
    }
}
</file>

<file path="PawMatch.Application/DTOs/UserRegisterDto.cs">
using System.ComponentModel.DataAnnotations;
namespace PawMatch.Application.DTOs
{
    public class UserRegisterDto
    {
        [Required]
        public string Name { get; set; }
        [Required, EmailAddress]
        public string Email { get; set; }
        [Required, MinLength(6)]
        public string Password { get; set; }
        // Ã–rnek: public int? Age { get; set; }
        // Ã–rnek: public string? Gender { get; set; }
    }
}
</file>

<file path="PawMatch.Application/Interfaces/IDiscoverService.cs">
using System.Collections.Generic;
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
namespace PawMatch.Application.Interfaces
{
    public interface IDiscoverService
    {
        Task<List<DiscoverUserPetDto>> DiscoverUsersAsync(int currentUserId, double? maxDistanceKm = null, string? preferredPetType = null, int? offset = null, int? limit = null);
    }
}
</file>

<file path="PawMatch.Application/Interfaces/IMatchService.cs">
using System.Collections.Generic;
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using PawMatch.Domain;
namespace PawMatch.Application.Interfaces
{
    public interface IMatchService
    {
        Task<MatchResultDto> LikeOrPassAsync(int currentUserId, MatchActionDto dto);
        Task<List<MatchDto>> GetMatchesForUserAsync(int userId);
        Task<Match> GetMatchByIdAsync(int matchId);
    }
}
</file>

<file path="PawMatch.Application/Interfaces/IMessageService.cs">
using System.Collections.Generic;
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using PawMatch.Domain;
namespace PawMatch.Application.Interfaces
{
    public interface IMessageService
    {
        Task<Message> SendMessageAsync(int senderId, int recipientId, string content);
        Task<IEnumerable<Message>> GetChatHistoryAsync(int user1Id, int user2Id);
        Task<bool> MarkMessageAsReadAsync(int messageId);
    }
}
</file>

<file path="PawMatch.Application/Interfaces/IPhotoService.cs">
using System.IO;
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
namespace PawMatch.Application.Interfaces
{
    public interface IPhotoService
    {
        Task<PhotoDto> UploadPhotoAsync(PhotoUploadDto dto, Stream fileStream, string fileName = null, string contentType = null);
        Task<Stream> GetPhotoStreamAsync(int photoId, int userId);
        Task DeletePhotoAsync(int photoId);
        Task DeleteUserPhotosAsync(int userId);
        Task DeletePetPhotosAsync(int petId);
    }
}
</file>

<file path="PawMatch.Application/Interfaces/IRealtimeNotificationService.cs">
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using PawMatch.Domain;
namespace PawMatch.Application.Interfaces
{
    public interface IRealtimeNotificationService
    {
        Task SendMatchNotificationAsync(int user1Id, int user2Id, MatchResultDto matchResult);
        Task SendMessageAsync(int recipientId, Message message);
    }
}
</file>

<file path="PawMatch.Application/Interfaces/IUserService.cs">
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using System.Collections.Generic;
using PawMatch.Domain;
namespace PawMatch.Application.Interfaces
{
    public interface IUserService
    {
        Task<UserAuthResponseDto> RegisterAsync(UserRegisterDto dto);
        Task<UserAuthResponseDto> LoginAsync(UserLoginDto dto);
        Task<UserAuthResponseDto> UpdateProfileAsync(int id, UpdateProfileDto dto);
        Task DeleteUserAsync(int id);
        Task<User> GetUserByIdAsync(int id);
        Task<List<User>> GetUsersByIdsAsync(List<int> ids);
        Task<User> GetUserDomainByIdAsync(int id);
    }
}
</file>

<file path="PawMatch.Application/PawMatch.Application.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <ItemGroup>
        <ProjectReference Include="..\PawMatch.Domain\PawMatch.Domain.csproj" />
        <ProjectReference Include="..\PawMatch.Infrastructure\PawMatch.Infrastructure.csproj" />
    </ItemGroup>

    <ItemGroup>
        <PackageReference Include="BCrypt.Net-Next" Version="4.*" />
        <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="10.0.0-preview.5.25277.114" />
    </ItemGroup>

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

</Project>
</file>

<file path="PawMatch.Application/Services/DiscoverService.cs">
using PawMatch.Application.Interfaces;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Linq;
using PawMatch.Infrastructure;
using Microsoft.EntityFrameworkCore;
using PawMatch.Infrastructure.Interfaces;
using Microsoft.Extensions.Configuration;
using System;
using Microsoft.Extensions.Logging;
using PawMatch.Application.DTOs;
namespace PawMatch.Application.Services
{
    public class DiscoverService : IDiscoverService
    {
        private readonly AppDbContext _db;
        private readonly IUserSwipeRepository _userSwipeRepository;
        private readonly IConfiguration _configuration;
        private readonly ILogger<DiscoverService> _logger;
        public DiscoverService(AppDbContext db, IUserSwipeRepository userSwipeRepository, IConfiguration configuration, ILogger<DiscoverService> logger)
        {
            _db = db;
            _userSwipeRepository = userSwipeRepository;
            _configuration = configuration;
            _logger = logger;
        }
        public async Task<List<DiscoverUserPetDto>> DiscoverUsersAsync(int currentUserId, double? maxDistanceKm = null, string? preferredPetType = null, int? offset = null, int? limit = null)
        {
            // Configure exclusion and re-appearance durations from appsettings.json
            var swipeExclusionDurationDays = _configuration.GetValue<int?>("AppSettings:SwipeExclusionDurationDays") ?? 30; // Not directly used in the new logic but kept for consistency
            var swipeReappearDurationDays = _configuration.GetValue<int?>("AppSettings:SwipeReappearDurationDays") ?? 90;
            var reappearDate = DateTime.UtcNow.AddDays(-swipeReappearDurationDays);
            _logger.LogInformation($"DiscoverService: ReappearDate calculated as {reappearDate.ToShortDateString()}");
            // Get users that the current user has explicitly liked (IsLiked = true)
            // These users should generally be permanently excluded from discovery after the initial swipe,
            // unless a match is later unconfirmed. For simplicity, we exclude them.
            var likedUserIds = await _db.UserSwipes
                .Where(us => us.SwiperId == currentUserId && us.IsLiked)
                .Select(us => us.SwipedUserId)
                .ToListAsync();
            // Get users that the current user has passed (IsLiked = false) within the re-appearance duration.
            // Users passed before 'reappearDate' will be included in discovery again.
            var passedRecentlyUserIds = await _db.UserSwipes
                .Where(us => us.SwiperId == currentUserId && !us.IsLiked && us.SwipeDate >= reappearDate)
                .Select(us => us.SwipedUserId)
                                    .ToListAsync();
            // Combine both sets of excluded users: liked users (always excluded) and recently passed users.
            var excludedUserIds = likedUserIds.Union(passedRecentlyUserIds).ToList();
            _logger.LogInformation($"DiscoverService: Excluded User IDs: {string.Join(", ", excludedUserIds)}");
            // Start with all users except the current one and already excluded ones
            var query = _db.Users
                .Where(u => u.Id != currentUserId && !excludedUserIds.Contains(u.Id));
            // Apply location-based filtering (simplified for now, full PostGIS integration would be here)
            if (maxDistanceKm.HasValue)
            {
                // TODO: Implement actual geographical distance calculation with PostGIS
                // For now, this is a placeholder and doesn't actively filter by distance.
                // It ensures the parameter is used, but the logic would need PostGIS functions.
                // Example: query = query.Where(u => u.Latitude.HasValue && u.Longitude.HasValue &&
                //                                 _db.Database.ExecuteSqlRaw($"ST_DWithin(ST_SetSRID(ST_MakePoint({u.Longitude}, {u.Latitude}), 4326), ST_SetSRID(ST_MakePoint({currentUserLongitude}, {currentUserLatitude}), 4326), {maxDistanceKm * 1000})"));
            }
            // Apply pet type filtering
            if (!string.IsNullOrEmpty(preferredPetType))
            {
                // Filter users who have pets of the preferred type
                query = query.Where(u => u.Pets.Any(p => p.Type.ToLower() == preferredPetType.ToLower()));
            }
            var discoveredUserIds = await query.Select(u => u.Id).ToListAsync();
            // KullanÄ±cÄ±larÄ± ve petlerini Ã§ek
            var usersWithDetails = await _db.Users
                .Where(u => discoveredUserIds.Contains(u.Id))
                .Include(u => u.Photos)
                .Include(u => u.Pets)
                    .ThenInclude(p => p.Photos)
                .ToListAsync(); // Verileri belleÄŸe Ã§ek
            // Sayfalama uygula (bellekte)
            if (offset.HasValue)
            {
                usersWithDetails = usersWithDetails.Skip(offset.Value).ToList();
            }
            if (limit.HasValue)
            {
                usersWithDetails = usersWithDetails.Take(limit.Value).ToList();
            }
            var result = usersWithDetails.Select(u =>
            {
                var pet = u.Pets.FirstOrDefault();
                var photoIds = u.Photos.Select(p => p.Id).ToList();
                var petIds = u.Pets.Select(p => p.Id).ToList();
                return new DiscoverUserPetDto
                {
                    User = UserPublicDtoMapper.ToPublicDto(u, photoIds, petIds),
                    Pet = pet == null ? null : new DiscoverPetDto
                    {
                        Name = pet.Name,
                        Type = pet.Type,
                        Age = pet.Age,
                        Photos = pet.Photos.Select(pp => new DiscoverPhotoDto { GoogleDriveFileId = pp.GoogleDriveFileId }).ToList()
                    }
                };
            }).ToList();
            return result;
        }
    }
}
</file>

<file path="PawMatch.Application/Services/MatchService.cs">
using System.Collections.Generic;
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using PawMatch.Infrastructure;
using Microsoft.EntityFrameworkCore;
using PawMatch.Infrastructure.Interfaces;
using PawMatch.Domain;
using Microsoft.Extensions.Logging;
namespace PawMatch.Application.Services
{
    public class MatchService : IMatchService
    {
        private readonly AppDbContext _db;
        private readonly IUserSwipeRepository _userSwipeRepository;
        private readonly IRealtimeNotificationService _realtimeNotificationService;
        private readonly ILogger<MatchService> _logger;
        private readonly IMatchRepository _matchRepository;
        public MatchService(AppDbContext db, IUserSwipeRepository userSwipeRepository, IRealtimeNotificationService realtimeNotificationService, ILogger<MatchService> logger, IMatchRepository matchRepository)
        {
            _db = db;
            _userSwipeRepository = userSwipeRepository;
            _realtimeNotificationService = realtimeNotificationService;
            _logger = logger;
            _matchRepository = matchRepository;
        }
        public async Task<MatchResultDto> LikeOrPassAsync(int currentUserId, MatchActionDto dto)
        {
            if (currentUserId != dto.User1Id)
            {
                throw new UnauthorizedAccessException("Unauthorized: User ID mismatch.");
            }
            var userSwipe = new UserSwipe
            {
                SwiperId = dto.User1Id,
                SwipedUserId = dto.User2Id,
                IsLiked = dto.Liked,
                SwipeDate = DateTime.UtcNow
            };
            await _userSwipeRepository.AddAsync(userSwipe);
            var matchResult = new MatchResultDto { MatchId = 0, Confirmed = false };
            if (dto.Liked)
            {
                var reciprocalSwipe = await _userSwipeRepository.GetBySwiperAndSwipedUserAsync(dto.User2Id, dto.User1Id);
                if (reciprocalSwipe != null && reciprocalSwipe.IsLiked)
                {
                    var existingMatch = await _db.Matches
                        .FirstOrDefaultAsync(m => (m.User1Id == dto.User1Id && m.User2Id == dto.User2Id) ||
                                                    (m.User1Id == dto.User2Id && m.User2Id == dto.User1Id));
                    if (existingMatch == null)
                    {
                        var newMatch = new Match
                        {
                            User1Id = dto.User1Id,
                            User2Id = dto.User2Id,
                            Confirmed = true
                        };
                        await _db.Matches.AddAsync(newMatch);
                        await _db.SaveChangesAsync();
                        matchResult.MatchId = newMatch.Id;
                        _logger.LogInformation($"Yeni eÅŸleÅŸme oluÅŸturuldu: MatchId={newMatch.Id}, User1Id={dto.User1Id}, User2Id={dto.User2Id}");
                    }
                    else
                    {
                        existingMatch.Confirmed = true;
                        _db.Matches.Update(existingMatch);
                        await _db.SaveChangesAsync();
                        matchResult.MatchId = existingMatch.Id;
                        _logger.LogInformation($"Mevcut eÅŸleÅŸme gÃ¼ncellendi: MatchId={existingMatch.Id}, User1Id={dto.User1Id}, User2Id={dto.User2Id}");
                    }
                    matchResult.Confirmed = true;
                    try
                    {
                        _logger.LogInformation($"Notification gÃ¶nderiliyor: User1Id={dto.User1Id}, User2Id={dto.User2Id}, MatchId={matchResult.MatchId}");
                    await _realtimeNotificationService.SendMatchNotificationAsync(dto.User1Id, dto.User2Id, matchResult);
                        _logger.LogInformation($"Notification baÅŸarÄ±yla gÃ¶nderildi: User1Id={dto.User1Id}, User2Id={dto.User2Id}, MatchId={matchResult.MatchId}");
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, $"Notification gÃ¶nderilemedi! User1Id={dto.User1Id}, User2Id={dto.User2Id}, MatchId={matchResult.MatchId}");
                    }
                }
            }
            else
            {
                var existingMatch = await _db.Matches
                    .FirstOrDefaultAsync(m => (m.User1Id == dto.User1Id && m.User2Id == dto.User2Id && m.Confirmed) ||
                                                (m.User1Id == dto.User2Id && m.User2Id == dto.User1Id && m.Confirmed));
                if (existingMatch != null)
                {
                    existingMatch.Confirmed = false;
                    _db.Matches.Update(existingMatch);
                    await _db.SaveChangesAsync();
                }
            }
            return matchResult;
        }
        /// <summary>
        /// KullanÄ±cÄ±nÄ±n eÅŸleÅŸmelerini DTO olarak dÃ¶ndÃ¼rÃ¼r. Mapping sÄ±rasÄ±nda User entity'den UserPublicDto'ya ve PhotoIds'e dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r.
        /// </summary>
        public async Task<List<MatchDto>> GetMatchesForUserAsync(int userId)
        {
            var matches = await _db.Matches
                .Where(m => m.Confirmed && (m.User1Id == userId || m.User2Id == userId))
                .Include(m => m.User1)
                .Include(m => m.User2)
                .ToListAsync();
            var result = new List<MatchDto>();
            foreach (var match in matches)
            {
                // KarÅŸÄ± tarafÄ± bul
                var otherUser = match.User1Id == userId ? match.User2 : match.User1;
                var photoIds = await _db.Photos
                    .Where(p => p.UserId == otherUser.Id)
                    .Select(p => p.Id)
                    .ToListAsync();
                var petIds = await _db.Pets
                    .Where(p => p.UserId == otherUser.Id)
                    .Select(p => p.Id)
                    .ToListAsync();
                result.Add(new MatchDto
                {
                    MatchId = match.Id,
                    Confirmed = match.Confirmed,
                    User = UserPublicDtoMapper.ToPublicDto(otherUser, photoIds, petIds)
                });
            }
            return result;
        }
        public async Task<Match> GetMatchByIdAsync(int matchId)
        {
            return await _matchRepository.GetByIdAsync(matchId);
        }
    }
}
</file>

<file path="PawMatch.Application/Services/MessageService.cs">
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using PawMatch.Application.Interfaces;
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
namespace PawMatch.Application.Services
{
    public class MessageService : IMessageService
    {
        private readonly IMessageRepository _messageRepository;
        private readonly IRealtimeNotificationService _realtimeNotificationService;
        private readonly IUserRepository _userRepository;
        public MessageService(IMessageRepository messageRepository, IRealtimeNotificationService realtimeNotificationService, IUserRepository userRepository)
        {
            _messageRepository = messageRepository;
            _realtimeNotificationService = realtimeNotificationService;
            _userRepository = userRepository;
        }
        public async Task<Message> SendMessageAsync(int senderId, int recipientId, string content)
        {
            // KullanÄ±cÄ± kontrolÃ¼
            var sender = await _userRepository.GetByIdAsync(senderId);
            if (sender == null)
                throw new ArgumentException($"Sender user not found: {senderId}");
            var recipient = await _userRepository.GetByIdAsync(recipientId);
            if (recipient == null)
                throw new ArgumentException($"Recipient user not found: {recipientId}");
            // (Opsiyonel) Yetkilendirme kontrolÃ¼: senderId ile dÄ±ÅŸarÄ±dan gelen currentUserId eÅŸleÅŸmiyorsa
            // if (currentUserId != senderId) throw new UnauthorizedAccessException();
            var message = new Message
            {
                SenderId = senderId,
                RecipientId = recipientId,
                Content = content,
                Timestamp = DateTime.UtcNow,
                IsRead = false
            };
            await _messageRepository.AddMessageAsync(message);
            // MesajÄ± alÄ±cÄ±ya SignalR Ã¼zerinden gÃ¶nder
            await _realtimeNotificationService.SendMessageAsync(recipientId, message);
            return message;
        }
        public async Task<IEnumerable<Message>> GetChatHistoryAsync(int user1Id, int user2Id)
        {
            return await _messageRepository.GetMessagesBetweenUsersAsync(user1Id, user2Id);
        }
        public async Task<bool> MarkMessageAsReadAsync(int messageId)
        {
            var message = await _messageRepository.GetMessageByIdAsync(messageId);
            if (message == null) return false;
            message.IsRead = true;
            await _messageRepository.UpdateMessageAsync(message);
            return true;
        }
    }
}
</file>

<file path="PawMatch.Application/Services/PhotoService.cs">
using System;
using System.IO;
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
using PawMatch.Infrastructure;
using Microsoft.EntityFrameworkCore;
using System.Linq;
using System.Collections.Generic;
namespace PawMatch.Application.Services
{
    public class PhotoService : IPhotoService
    {
        private readonly AppDbContext _db;
        private readonly IStorageProvider _storageProvider;
        private readonly IDiscoverService _discoverService;
        public PhotoService(AppDbContext db, IStorageProvider storageProvider, IDiscoverService discoverService)
        {
            _db = db;
            _storageProvider = storageProvider;
            _discoverService = discoverService;
        }
        public async Task<PhotoDto> UploadPhotoAsync(PhotoUploadDto dto, Stream fileStream, string fileName = null, string contentType = null)
        {
            // SÄ±nÄ±r ve tip kontrolleri Ã¼st katmanda yapÄ±lmalÄ±
            var fileId = await _storageProvider.UploadAsync(fileStream, fileName, contentType);
            var photo = new Photo
            {
                FileName = fileName,
                GoogleDriveFileId = fileId,
                UploadDate = DateTime.UtcNow,
                UserId = dto.UserId,
                PetId = dto.PetId
            };
            _db.Photos.Add(photo);
            await _db.SaveChangesAsync();
            return new PhotoDto
            {
                Id = photo.Id,
                FileName = photo.FileName,
                ContentType = contentType,
                GoogleDriveFileId = fileId,
                UploadDate = photo.UploadDate,
                UserId = photo.UserId,
                PetId = photo.PetId
            };
        }
        public async Task<Stream> GetPhotoStreamAsync(int photoId, int userId)
        {
            var photo = await _db.Photos.FirstOrDefaultAsync(p => p.Id == photoId);
            if (photo == null) throw new Exception("Photo not found");
            // Sahiplik kontrolÃ¼
            if (photo.UserId == userId) return await _storageProvider.DownloadAsync(photo.GoogleDriveFileId);
            if (photo.PetId.HasValue)
            {
                var petOwnerId = await _db.Pets
                                            .Where(p => p.Id == photo.PetId.Value)
                                            .Select(p => p.UserId)
                                            .FirstOrDefaultAsync();
                if (petOwnerId == userId) return await _storageProvider.DownloadAsync(photo.GoogleDriveFileId);
            }
            if (photo.UserId.HasValue)
            {
                var discoveredUsers = await _discoverService.DiscoverUsersAsync(userId);
                var discoveredUserIds = discoveredUsers.Select(u => u.User.Id).ToList();
                if (discoveredUserIds.Contains(photo.UserId.Value))
                {
                    return await _storageProvider.DownloadAsync(photo.GoogleDriveFileId);
                }
            }
            throw new UnauthorizedAccessException("You are not authorized to view this photo.");
        }
        public async Task DeletePhotoAsync(int photoId)
        {
            var photo = await _db.Photos.FirstOrDefaultAsync(p => p.Id == photoId);
            if (photo == null) throw new Exception("Photo not found");
            await _storageProvider.DeleteAsync(photo.GoogleDriveFileId);
            _db.Photos.Remove(photo);
            await _db.SaveChangesAsync();
        }
        public async Task DeleteUserPhotosAsync(int userId)
        {
            var userPhotos = await _db.Photos.Where(p => p.UserId == userId).ToListAsync();
            foreach (var photo in userPhotos)
            {
                if (!string.IsNullOrEmpty(photo.GoogleDriveFileId))
                {
                    await _storageProvider.DeleteAsync(photo.GoogleDriveFileId);
                }
                _db.Photos.Remove(photo);
            }
            await _db.SaveChangesAsync();
        }
        public async Task DeletePetPhotosAsync(int petId)
        {
            var petPhotos = await _db.Photos.Where(p => p.PetId == petId).ToListAsync();
            foreach (var photo in petPhotos)
            {
                if (!string.IsNullOrEmpty(photo.GoogleDriveFileId))
                {
                    await _storageProvider.DeleteAsync(photo.GoogleDriveFileId);
                }
                _db.Photos.Remove(photo);
            }
            await _db.SaveChangesAsync();
        }
    }
}
</file>

<file path="PawMatch.Application/Services/UserService.cs">
using System.Threading.Tasks;
using PawMatch.Application.DTOs;
using PawMatch.Application.Interfaces;
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
using PawMatch.Infrastructure;
using BCrypt.Net;
using System.Linq;
using Microsoft.EntityFrameworkCore;
namespace PawMatch.Application.Services
{
    public class UserService : IUserService
    {
        private readonly IJwtProvider _jwtProvider;
        private readonly IUserRepository _userRepository;
        private readonly IPhotoService _photoService;
        private readonly AppDbContext _dbContext;
        public UserService(IUserRepository userRepository, IJwtProvider jwtProvider, IPhotoService photoService, AppDbContext dbContext)
        {
            _userRepository = userRepository;
            _jwtProvider = jwtProvider;
            _photoService = photoService;
            _dbContext = dbContext;
        }
        public async Task<UserAuthResponseDto> RegisterAsync(UserRegisterDto dto)
        {
            var user = new User
            {
                Name = dto.Name,
                Email = dto.Email,
                PasswordHash = BCrypt.Net.BCrypt.HashPassword(dto.Password)
            };
            await _userRepository.AddAsync(user);
            var token = _jwtProvider.GenerateToken(user);
            var userPhotos = await _dbContext.Photos
                                            .Where(p => p.UserId == user.Id)
                                            .Select(p => p.Id)
                                            .ToListAsync();
            return new UserAuthResponseDto
            {
                UserPrivate = new UserPrivateDto
                {
                    Id = user.Id,
                    Name = user.Name,
                    Email = user.Email,
                    Bio = user.Bio,
                    HasPet = user.HasPet,
                    HasProfile = !string.IsNullOrWhiteSpace(user.Name) && !string.IsNullOrWhiteSpace(user.Email) && !string.IsNullOrWhiteSpace(user.Bio) && user.HasPet,
                    PhotoIds = userPhotos
                },
                Token = token
            };
        }
        public async Task<UserAuthResponseDto> LoginAsync(UserLoginDto dto)
        {
            var user = await _userRepository.GetByEmailAsync(dto.Email);
            if (user == null || !BCrypt.Net.BCrypt.Verify(dto.Password, user.PasswordHash))
                throw new UnauthorizedAccessException("GeÃ§ersiz kimlik bilgileri");
            var token = _jwtProvider.GenerateToken(user);
            var userPhotos = await _dbContext.Photos
                                            .Where(p => p.UserId == user.Id)
                                            .Select(p => p.Id)
                                            .ToListAsync();
            return new UserAuthResponseDto
            {
                UserPrivate = new UserPrivateDto
                {
                    Id = user.Id,
                    Name = user.Name,
                    Email = user.Email,
                    Bio = user.Bio,
                    HasPet = user.HasPet,
                    HasProfile = !string.IsNullOrWhiteSpace(user.Name) && !string.IsNullOrWhiteSpace(user.Email) && !string.IsNullOrWhiteSpace(user.Bio) && user.HasPet,
                    PhotoIds = userPhotos
                },
                Token = token
            };
        }
        public async Task<UserAuthResponseDto> UpdateProfileAsync(int id, UpdateProfileDto dto)
        {
            var user = await _userRepository.GetByIdAsync(id);
            if (user == null)
                throw new KeyNotFoundException("KullanÄ±cÄ± bulunamadÄ±");
            user.Name = dto.Name;
            user.Bio = dto.Bio;
            user.HasPet = dto.HasPet;
            await _userRepository.UpdateAsync(user);
            var token = _jwtProvider.GenerateToken(user);
            var userPhotos = await _dbContext.Photos
                                            .Where(p => p.UserId == user.Id)
                                            .Select(p => p.Id)
                                            .ToListAsync();
            return new UserAuthResponseDto
            {
                UserPrivate = new UserPrivateDto
                {
                    Id = user.Id,
                    Name = user.Name,
                    Email = user.Email,
                    Bio = user.Bio,
                    HasPet = user.HasPet,
                    HasProfile = !string.IsNullOrWhiteSpace(user.Name) && !string.IsNullOrWhiteSpace(user.Email) && !string.IsNullOrWhiteSpace(user.Bio) && user.HasPet,
                    PhotoIds = userPhotos
                },
                Token = token
            };
        }
        public async Task DeleteUserAsync(int id)
        {
            var user = await _userRepository.GetByIdAsync(id);
            if (user == null)
            {
                throw new KeyNotFoundException("User not found.");
            }
            var pets = _dbContext.Pets.Where(p => p.UserId == id).ToList();
            foreach (var pet in pets)
            {
                await _photoService.DeletePetPhotosAsync(pet.Id);
                _dbContext.Pets.Remove(pet);
            }
            await _dbContext.SaveChangesAsync();
            await _photoService.DeleteUserPhotosAsync(id);
            await _userRepository.DeleteAsync(id);
        }
        /// <summary>
        /// API response iÃ§in: KullanÄ±cÄ±yÄ± DTO olarak dÃ¶ndÃ¼rÃ¼r (login, register, profil iÃ§in).
        /// </summary>
        public async Task<User> GetUserByIdAsync(int id)
        {
            var user = await _userRepository.GetByIdAsync(id);
            if (user == null)
            {
                throw new KeyNotFoundException("User not found.");
            }
            var userPhotos = await _dbContext.Photos
                                            .Where(p => p.UserId == user.Id)
                                            .Select(p => p)
                                            .ToListAsync();
            var petIds = await _dbContext.Pets
                                        .Where(p => p.UserId == user.Id)
                                        .Select(p => p)
                                        .ToListAsync();
            return new User
            {
                Id = user.Id,
                Name = user.Name,
                Email = user.Email,
                Bio = user.Bio,
                HasPet = user.HasPet,
                HasProfile = user.HasProfile,
                Photos = userPhotos,
                Pets = petIds
            };
        }
        /// <summary>
        /// Domain iÅŸlemleri iÃ§in: KullanÄ±cÄ±yÄ± entity olarak dÃ¶ndÃ¼rÃ¼r.
        /// </summary>
        public async Task<User> GetUserDomainByIdAsync(int id)
        {
            return await _userRepository.GetByIdAsync(id);
        }
        /// <summary>
        /// Domain iÅŸlemleri iÃ§in: Birden fazla kullanÄ±cÄ±yÄ± entity olarak dÃ¶ndÃ¼rÃ¼r.
        /// </summary>
        public async Task<List<User>> GetUsersByIdsAsync(List<int> ids)
        {
            return await _userRepository.GetByIdsAsync(ids);
        }
    }
}
</file>

<file path="PawMatch.Domain/.gitignore">
# Build
bin/
obj/

# Metadata / Cache (IDE)
*.user
*.suo
*.cache

# Temporary files
*.tmp
*.log
</file>

<file path="PawMatch.Domain/Class1.cs">
namespace PawMatch.Domain;
public class Class1
{
}
</file>

<file path="PawMatch.Domain/Match.cs">
namespace PawMatch.Domain
{
    public class Match
    {
        public int Id { get; set; }
        public int User1Id { get; set; }
        public User User1 { get; set; }
        public int User2Id { get; set; }
        public User User2 { get; set; }
        public bool Confirmed { get; set; }
    }
}
</file>

<file path="PawMatch.Domain/Message.cs">
using System;
using System.ComponentModel.DataAnnotations.Schema;
namespace PawMatch.Domain
{
    public class Message
    {
        public int Id { get; set; }
        public int SenderId { get; set; }
        public int RecipientId { get; set; }
        public string Content { get; set; }
        public DateTime Timestamp { get; set; }
        public bool IsRead { get; set; }
        [ForeignKey("SenderId")]
        public User Sender { get; set; }
        [ForeignKey("RecipientId")]
        public User Recipient { get; set; }
    }
}
</file>

<file path="PawMatch.Domain/PawMatch.Domain.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

</Project>
</file>

<file path="PawMatch.Domain/Pet.cs">
using System.Collections.Generic;
namespace PawMatch.Domain
{
    public class Pet
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Type { get; set; }
        public int Age { get; set; }
        public string? Gender { get; set; }
        public int UserId { get; set; }
        public User User { get; set; }
        public List<Photo> Photos { get; set; } = new();
    }
}
</file>

<file path="PawMatch.Domain/Photo.cs">
using System;
namespace PawMatch.Domain
{
    public class Photo
    {
        public int Id { get; set; }
        public string FileName { get; set; }
        public string? GoogleDriveFileId { get; set; }
        public DateTime UploadDate { get; set; }
        public int? UserId { get; set; }
        public User? User { get; set; }
        public int? PetId { get; set; }
        public Pet? Pet { get; set; }
    }
}
</file>

<file path="PawMatch.Domain/User.cs">
using System.Collections.Generic;
using System.Linq;
namespace PawMatch.Domain
{
    public class User
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Email { get; set; }
        public string PasswordHash { get; set; }
        public string? Bio { get; set; }
        public bool HasPet { get; set; } = false;
        public bool HasProfile { get; set; } = false;
        public double? Latitude { get; set; }
        public double? Longitude { get; set; }
        public List<Photo> Photos { get; set; } = new();
        public List<Pet> Pets { get; set; } = new();
    }
    public static class UserExtensions
    {
        public static List<int> GetPhotoIds(this User user)
            => user.Photos?.Select(p => p.Id).ToList() ?? new List<int>();
        public static List<int> GetPetIds(this User user)
            => user.Pets?.Select(p => p.Id).ToList() ?? new List<int>();
    }
}
</file>

<file path="PawMatch.Domain/UserSwipe.cs">
namespace PawMatch.Domain
{
    public class UserSwipe
    {
        public int Id { get; set; }
        public int SwiperId { get; set; }
        public User Swiper { get; set; } // Navigation property
        public int SwipedUserId { get; set; }
        public User SwipedUser { get; set; } // Navigation property
        public bool IsLiked { get; set; }
        public DateTime SwipeDate { get; set; }
    }
}
</file>

<file path="PawMatch.Infrastructure/.gitignore">
# Build
bin/
obj/

# EF Core migration snapshots (if not needed in version control)
Migrations/*Snapshot.cs
</file>

<file path="PawMatch.Infrastructure/AppDbContext.cs">
using Microsoft.EntityFrameworkCore;
using PawMatch.Domain;
using BCrypt.Net;
namespace PawMatch.Infrastructure
{
    public class AppDbContext : DbContext
    {
        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }
        public DbSet<User> Users { get; set; }
        public DbSet<Pet> Pets { get; set; }
        public DbSet<Photo> Photos { get; set; }
        public DbSet<Match> Matches { get; set; }
        public DbSet<UserSwipe> UserSwipes { get; set; }
        public DbSet<Message> Messages { get; set; }
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);
            modelBuilder.Entity<UserSwipe>()
                .HasOne(us => us.Swiper)
                .WithMany()
                .HasForeignKey(us => us.SwiperId)
                .OnDelete(DeleteBehavior.Restrict); // Prevent cascade delete
            modelBuilder.Entity<UserSwipe>()
                .HasOne(us => us.SwipedUser)
                .WithMany()
                .HasForeignKey(us => us.SwipedUserId)
                .OnDelete(DeleteBehavior.Restrict); // Prevent cascade delete
            // Other existing configurations...
        }
        public static class AppDbContextSeed
        {
            public static void Seed(AppDbContext db)
            {
                if (!db.Users.Any())
                {
                    var user1 = new User { Name = "Berkan MandacÄ±", Email = "berkan_mandaci@hotmail.com", PasswordHash = BCrypt.Net.BCrypt.HashPassword("mandaci12"), Bio = "Kedisever", HasPet = true };
                    var user2 = new User { Name = "Zeynep", Email = "test2@example.com", PasswordHash = BCrypt.Net.BCrypt.HashPassword("mandaci12"), Bio = "KÃ¶peksever", HasPet = false };
                    db.Users.AddRange(user1, user2);
                    db.SaveChanges();
                    var pet1 = new Pet { Name = "Boncuk", Type = "Kedi", Age = 2, UserId = user1.Id };
                    db.Pets.Add(pet1);
                    db.SaveChanges();
                    var photo1 = new Photo { FileName = "ali1.jpg", GoogleDriveFileId = "dummy-file-id-1", UploadDate = DateTime.UtcNow, UserId = user1.Id };
                    var photo2 = new Photo { FileName = "boncuk1.jpg", GoogleDriveFileId = "dummy-file-id-2", UploadDate = DateTime.UtcNow, PetId = pet1.Id };
                    var user1Photo = new Photo { FileName = "testphoto.jpg", GoogleDriveFileId = "user1-test-photo-id", UploadDate = DateTime.UtcNow, UserId = user1.Id };
                    var user2Photo = new Photo { FileName = "testphoto.jpg", GoogleDriveFileId = "user2-test-photo-id", UploadDate = DateTime.UtcNow, UserId = user2.Id };
                    db.Photos.AddRange(photo1, photo2, user1Photo, user2Photo);
                    db.SaveChanges();
                }
            }
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Class1.cs">
namespace PawMatch.Infrastructure;
public class Class1
{
}
</file>

<file path="PawMatch.Infrastructure/Interfaces/IJwtProvider.cs">
using PawMatch.Domain;
namespace PawMatch.Infrastructure.Interfaces
{
    public interface IJwtProvider
    {
        string GenerateToken(User user);
    }
}
</file>

<file path="PawMatch.Infrastructure/Interfaces/IMatchRepository.cs">
using System.Threading.Tasks;
using PawMatch.Domain;
namespace PawMatch.Infrastructure.Interfaces
{
    public interface IMatchRepository
    {
        Task<Match> GetByIdAsync(int matchId);
    }
}
</file>

<file path="PawMatch.Infrastructure/Interfaces/IMessageRepository.cs">
using PawMatch.Domain;
using System.Collections.Generic;
using System.Threading.Tasks;
namespace PawMatch.Infrastructure.Interfaces
{
    public interface IMessageRepository
    {
        Task AddMessageAsync(Message message);
        Task<IEnumerable<Message>> GetMessagesBetweenUsersAsync(int user1Id, int user2Id);
        Task<Message> GetMessageByIdAsync(int messageId);
        Task UpdateMessageAsync(Message message);
        Task DeleteMessageAsync(int messageId);
    }
}
</file>

<file path="PawMatch.Infrastructure/Interfaces/IStorageProvider.cs">
using System.IO;
using System.Threading.Tasks;
namespace PawMatch.Infrastructure.Interfaces
{
    public interface IStorageProvider
    {
        Task<string> UploadAsync(Stream fileStream, string fileName, string contentType);
        Task<Stream> DownloadAsync(string fileId);
        Task DeleteAsync(string fileId);
    }
}
</file>

<file path="PawMatch.Infrastructure/Interfaces/IUserRepository.cs">
using System.Threading.Tasks;
using PawMatch.Domain;
namespace PawMatch.Infrastructure.Interfaces
{
    public interface IUserRepository
    {
        Task AddAsync(User user);
        Task<User> GetByEmailAsync(string email);
        Task<User> GetByIdAsync(int id);
        Task UpdateAsync(User user);
        Task DeleteAsync(int id);
        Task<List<User>> GetByIdsAsync(List<int> ids);
    }
}
</file>

<file path="PawMatch.Infrastructure/Interfaces/IUserSwipeRepository.cs">
using PawMatch.Domain;
using System.Threading.Tasks;
namespace PawMatch.Infrastructure.Interfaces
{
    public interface IUserSwipeRepository
    {
        Task AddAsync(UserSwipe userSwipe);
        Task<UserSwipe> GetBySwiperAndSwipedUserAsync(int swiperId, int swipedUserId);
        // You can add more methods here as needed, e.g., to get recent swipes
    }
}
</file>

<file path="PawMatch.Infrastructure/Migrations/20250617224635_InitialCreate.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
#nullable disable
namespace PawMatch.Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Users",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    Name = table.Column<string>(type: "text", nullable: false),
                    Email = table.Column<string>(type: "text", nullable: false),
                    PasswordHash = table.Column<string>(type: "text", nullable: false),
                    Bio = table.Column<string>(type: "text", nullable: true),
                    HasPet = table.Column<bool>(type: "boolean", nullable: false),
                    HasProfile = table.Column<bool>(type: "boolean", nullable: false),
                    Latitude = table.Column<double>(type: "double precision", nullable: true),
                    Longitude = table.Column<double>(type: "double precision", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Users", x => x.Id);
                });
            migrationBuilder.CreateTable(
                name: "Matches",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    User1Id = table.Column<int>(type: "integer", nullable: false),
                    User2Id = table.Column<int>(type: "integer", nullable: false),
                    Confirmed = table.Column<bool>(type: "boolean", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Matches", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Matches_Users_User1Id",
                        column: x => x.User1Id,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_Matches_Users_User2Id",
                        column: x => x.User2Id,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });
            migrationBuilder.CreateTable(
                name: "Messages",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    SenderId = table.Column<int>(type: "integer", nullable: false),
                    RecipientId = table.Column<int>(type: "integer", nullable: false),
                    Content = table.Column<string>(type: "text", nullable: false),
                    Timestamp = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    IsRead = table.Column<bool>(type: "boolean", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Messages", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Messages_Users_RecipientId",
                        column: x => x.RecipientId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_Messages_Users_SenderId",
                        column: x => x.SenderId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });
            migrationBuilder.CreateTable(
                name: "Pets",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    Name = table.Column<string>(type: "text", nullable: false),
                    Type = table.Column<string>(type: "text", nullable: false),
                    Age = table.Column<int>(type: "integer", nullable: false),
                    Gender = table.Column<string>(type: "text", nullable: true),
                    UserId = table.Column<int>(type: "integer", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Pets", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Pets_Users_UserId",
                        column: x => x.UserId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });
            migrationBuilder.CreateTable(
                name: "UserSwipes",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    SwiperId = table.Column<int>(type: "integer", nullable: false),
                    SwipedUserId = table.Column<int>(type: "integer", nullable: false),
                    IsLiked = table.Column<bool>(type: "boolean", nullable: false),
                    SwipeDate = table.Column<DateTime>(type: "timestamp with time zone", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_UserSwipes", x => x.Id);
                    table.ForeignKey(
                        name: "FK_UserSwipes_Users_SwipedUserId",
                        column: x => x.SwipedUserId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                    table.ForeignKey(
                        name: "FK_UserSwipes_Users_SwiperId",
                        column: x => x.SwiperId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                });
            migrationBuilder.CreateTable(
                name: "Photos",
                columns: table => new
                {
                    Id = table.Column<int>(type: "integer", nullable: false)
                        .Annotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn),
                    FileName = table.Column<string>(type: "text", nullable: false),
                    GoogleDriveFileId = table.Column<string>(type: "text", nullable: true),
                    UploadDate = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    UserId = table.Column<int>(type: "integer", nullable: true),
                    PetId = table.Column<int>(type: "integer", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Photos", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Photos_Pets_PetId",
                        column: x => x.PetId,
                        principalTable: "Pets",
                        principalColumn: "Id");
                    table.ForeignKey(
                        name: "FK_Photos_Users_UserId",
                        column: x => x.UserId,
                        principalTable: "Users",
                        principalColumn: "Id");
                });
            migrationBuilder.CreateIndex(
                name: "IX_Matches_User1Id",
                table: "Matches",
                column: "User1Id");
            migrationBuilder.CreateIndex(
                name: "IX_Matches_User2Id",
                table: "Matches",
                column: "User2Id");
            migrationBuilder.CreateIndex(
                name: "IX_Messages_RecipientId",
                table: "Messages",
                column: "RecipientId");
            migrationBuilder.CreateIndex(
                name: "IX_Messages_SenderId",
                table: "Messages",
                column: "SenderId");
            migrationBuilder.CreateIndex(
                name: "IX_Pets_UserId",
                table: "Pets",
                column: "UserId");
            migrationBuilder.CreateIndex(
                name: "IX_Photos_PetId",
                table: "Photos",
                column: "PetId");
            migrationBuilder.CreateIndex(
                name: "IX_Photos_UserId",
                table: "Photos",
                column: "UserId");
            migrationBuilder.CreateIndex(
                name: "IX_UserSwipes_SwipedUserId",
                table: "UserSwipes",
                column: "SwipedUserId");
            migrationBuilder.CreateIndex(
                name: "IX_UserSwipes_SwiperId",
                table: "UserSwipes",
                column: "SwiperId");
        }
        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "Matches");
            migrationBuilder.DropTable(
                name: "Messages");
            migrationBuilder.DropTable(
                name: "Photos");
            migrationBuilder.DropTable(
                name: "UserSwipes");
            migrationBuilder.DropTable(
                name: "Pets");
            migrationBuilder.DropTable(
                name: "Users");
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Migrations/20250617224635_InitialCreate.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using PawMatch.Infrastructure;
#nullable disable
namespace PawMatch.Infrastructure.Migrations
{
    [DbContext(typeof(AppDbContext))]
    [Migration("20250617224635_InitialCreate")]
    partial class InitialCreate
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.17")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);
            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);
            modelBuilder.Entity("PawMatch.Domain.Match", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer");
                    NpgsqlPropertyBuilderExtensions.UseIdentityByDefaultColumn(b.Property<int>("Id"));
                    b.Property<bool>("Confirmed")
                        .HasColumnType("boolean");
                    b.Property<int>("User1Id")
                        .HasColumnType("integer");
                    b.Property<int>("User2Id")
                        .HasColumnType("integer");
                    b.HasKey("Id");
                    b.HasIndex("User1Id");
                    b.HasIndex("User2Id");
                    b.ToTable("Matches");
                });
            modelBuilder.Entity("PawMatch.Domain.Message", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer");
                    NpgsqlPropertyBuilderExtensions.UseIdentityByDefaultColumn(b.Property<int>("Id"));
                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("text");
                    b.Property<bool>("IsRead")
                        .HasColumnType("boolean");
                    b.Property<int>("RecipientId")
                        .HasColumnType("integer");
                    b.Property<int>("SenderId")
                        .HasColumnType("integer");
                    b.Property<DateTime>("Timestamp")
                        .HasColumnType("timestamp with time zone");
                    b.HasKey("Id");
                    b.HasIndex("RecipientId");
                    b.HasIndex("SenderId");
                    b.ToTable("Messages");
                });
            modelBuilder.Entity("PawMatch.Domain.Pet", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer");
                    NpgsqlPropertyBuilderExtensions.UseIdentityByDefaultColumn(b.Property<int>("Id"));
                    b.Property<int>("Age")
                        .HasColumnType("integer");
                    b.Property<string>("Gender")
                        .HasColumnType("text");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");
                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");
                    b.Property<int>("UserId")
                        .HasColumnType("integer");
                    b.HasKey("Id");
                    b.HasIndex("UserId");
                    b.ToTable("Pets");
                });
            modelBuilder.Entity("PawMatch.Domain.Photo", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer");
                    NpgsqlPropertyBuilderExtensions.UseIdentityByDefaultColumn(b.Property<int>("Id"));
                    b.Property<string>("FileName")
                        .IsRequired()
                        .HasColumnType("text");
                    b.Property<string>("GoogleDriveFileId")
                        .HasColumnType("text");
                    b.Property<int?>("PetId")
                        .HasColumnType("integer");
                    b.Property<DateTime>("UploadDate")
                        .HasColumnType("timestamp with time zone");
                    b.Property<int?>("UserId")
                        .HasColumnType("integer");
                    b.HasKey("Id");
                    b.HasIndex("PetId");
                    b.HasIndex("UserId");
                    b.ToTable("Photos");
                });
            modelBuilder.Entity("PawMatch.Domain.User", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer");
                    NpgsqlPropertyBuilderExtensions.UseIdentityByDefaultColumn(b.Property<int>("Id"));
                    b.Property<string>("Bio")
                        .HasColumnType("text");
                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");
                    b.Property<bool>("HasPet")
                        .HasColumnType("boolean");
                    b.Property<bool>("HasProfile")
                        .HasColumnType("boolean");
                    b.Property<double?>("Latitude")
                        .HasColumnType("double precision");
                    b.Property<double?>("Longitude")
                        .HasColumnType("double precision");
                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");
                    b.Property<string>("PasswordHash")
                        .IsRequired()
                        .HasColumnType("text");
                    b.HasKey("Id");
                    b.ToTable("Users");
                });
            modelBuilder.Entity("PawMatch.Domain.UserSwipe", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("integer");
                    NpgsqlPropertyBuilderExtensions.UseIdentityByDefaultColumn(b.Property<int>("Id"));
                    b.Property<bool>("IsLiked")
                        .HasColumnType("boolean");
                    b.Property<DateTime>("SwipeDate")
                        .HasColumnType("timestamp with time zone");
                    b.Property<int>("SwipedUserId")
                        .HasColumnType("integer");
                    b.Property<int>("SwiperId")
                        .HasColumnType("integer");
                    b.HasKey("Id");
                    b.HasIndex("SwipedUserId");
                    b.HasIndex("SwiperId");
                    b.ToTable("UserSwipes");
                });
            modelBuilder.Entity("PawMatch.Domain.Match", b =>
                {
                    b.HasOne("PawMatch.Domain.User", "User1")
                        .WithMany()
                        .HasForeignKey("User1Id")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("PawMatch.Domain.User", "User2")
                        .WithMany()
                        .HasForeignKey("User2Id")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User1");
                    b.Navigation("User2");
                });
            modelBuilder.Entity("PawMatch.Domain.Message", b =>
                {
                    b.HasOne("PawMatch.Domain.User", "Recipient")
                        .WithMany()
                        .HasForeignKey("RecipientId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.HasOne("PawMatch.Domain.User", "Sender")
                        .WithMany()
                        .HasForeignKey("SenderId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("Recipient");
                    b.Navigation("Sender");
                });
            modelBuilder.Entity("PawMatch.Domain.Pet", b =>
                {
                    b.HasOne("PawMatch.Domain.User", "User")
                        .WithMany("Pets")
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                    b.Navigation("User");
                });
            modelBuilder.Entity("PawMatch.Domain.Photo", b =>
                {
                    b.HasOne("PawMatch.Domain.Pet", "Pet")
                        .WithMany("Photos")
                        .HasForeignKey("PetId");
                    b.HasOne("PawMatch.Domain.User", "User")
                        .WithMany("Photos")
                        .HasForeignKey("UserId");
                    b.Navigation("Pet");
                    b.Navigation("User");
                });
            modelBuilder.Entity("PawMatch.Domain.UserSwipe", b =>
                {
                    b.HasOne("PawMatch.Domain.User", "SwipedUser")
                        .WithMany()
                        .HasForeignKey("SwipedUserId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.HasOne("PawMatch.Domain.User", "Swiper")
                        .WithMany()
                        .HasForeignKey("SwiperId")
                        .OnDelete(DeleteBehavior.Restrict)
                        .IsRequired();
                    b.Navigation("SwipedUser");
                    b.Navigation("Swiper");
                });
            modelBuilder.Entity("PawMatch.Domain.Pet", b =>
                {
                    b.Navigation("Photos");
                });
            modelBuilder.Entity("PawMatch.Domain.User", b =>
                {
                    b.Navigation("Pets");
                    b.Navigation("Photos");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/PawMatch.Infrastructure.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <ItemGroup>
      <ProjectReference Include="..\PawMatch.Domain\PawMatch.Domain.csproj" />
    </ItemGroup>

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
      <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.*" />
      <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.*" />
      <PackageReference Include="Microsoft.IdentityModel.Tokens" Version="8.12.0" />
      <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.*" />
      <PackageReference Include="BCrypt.Net-Next" Version="4.*" />
      <PackageReference Include="Google.Apis.Drive.v3" Version="1.*" />
      <PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="8.12.0" />
    </ItemGroup>

    <ItemGroup>
      <Folder Include="Migrations\" />
    </ItemGroup>

</Project>
</file>

<file path="PawMatch.Infrastructure/Providers/GoogleDriveStorageProvider.cs">
using Google.Apis.Auth.OAuth2;
using Google.Apis.Drive.v3;
using Google.Apis.Drive.v3.Data;
using Google.Apis.Services;
using PawMatch.Infrastructure.Interfaces;
using System;
using System.IO;
using System.Threading.Tasks;
namespace PawMatch.Infrastructure.Providers
{
    public class GoogleDriveStorageProvider : IStorageProvider
    {
        private readonly DriveService _driveService;
        public GoogleDriveStorageProvider()
        {
            var credentialsPath = Environment.GetEnvironmentVariable("GoogleDrive__CredentialsPath")
                ?? "api/credentials/credentials.json";
            var credential = GoogleCredential.FromFile(credentialsPath)
                .CreateScoped(DriveService.Scope.Drive);
            _driveService = new DriveService(new BaseClientService.Initializer
            {
                HttpClientInitializer = credential,
                ApplicationName = "PawMatch"
            });
        }
        public async Task<string> UploadAsync(Stream fileStream, string fileName, string contentType)
        {
            var fileMetadata = new Google.Apis.Drive.v3.Data.File
            {
                Name = fileName,
                Parents = new[] { "root" }
            };
            var request = _driveService.Files.Create(fileMetadata, fileStream, contentType);
            request.Fields = "id";
            var file = await request.UploadAsync();
            if (file.Status != Google.Apis.Upload.UploadStatus.Completed)
                throw new Exception("Google Drive upload failed: " + file.Exception?.Message);
            return request.ResponseBody.Id;
        }
        public async Task<Stream> DownloadAsync(string fileId)
        {
            var stream = new MemoryStream();
            var request = _driveService.Files.Get(fileId);
            await request.DownloadAsync(stream);
            stream.Position = 0;
            return stream;
        }
        public async Task DeleteAsync(string fileId)
        {
            await _driveService.Files.Delete(fileId).ExecuteAsync();
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Providers/JwtProvider.cs">
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
using System;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using Microsoft.IdentityModel.Tokens;
using System.Text;
namespace PawMatch.Infrastructure.Providers
{
    public class JwtProvider : IJwtProvider
    {
        public string GenerateToken(User user)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.ASCII.GetBytes("super-secret-key-which-is-at-least-32-chars!");
            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(new[]
                {
                    new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
                    new Claim(ClaimTypes.Name, user.Name ?? "")
                }),
                Expires = DateTime.UtcNow.AddDays(7),
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
            };
            var token = tokenHandler.CreateToken(tokenDescriptor);
            return tokenHandler.WriteToken(token);
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Repositories/MatchRepository.cs">
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
namespace PawMatch.Infrastructure.Repositories
{
    public class MatchRepository : IMatchRepository
    {
        private readonly AppDbContext _db;
        public MatchRepository(AppDbContext db)
        {
            _db = db;
        }
        public async Task<Match> GetByIdAsync(int matchId)
        {
            return await _db.Matches
                .Include(m => m.User1)
                .Include(m => m.User2)
                .FirstOrDefaultAsync(m => m.Id == matchId);
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Repositories/MessageRepository.cs">
using Microsoft.EntityFrameworkCore;
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
namespace PawMatch.Infrastructure.Repositories
{
    public class MessageRepository : IMessageRepository
    {
        private readonly AppDbContext _db;
        public MessageRepository(AppDbContext db)
        {
            _db = db;
        }
        public async Task AddMessageAsync(Message message)
        {
            await _db.Messages.AddAsync(message);
            await _db.SaveChangesAsync();
        }
        public async Task<IEnumerable<Message>> GetMessagesBetweenUsersAsync(int user1Id, int user2Id)
        {
            return await _db.Messages
                .Where(m => (m.SenderId == user1Id && m.RecipientId == user2Id) ||
                            (m.SenderId == user2Id && m.RecipientId == user1Id))
                .OrderBy(m => m.Timestamp)
                .ToListAsync();
        }
        public async Task<Message> GetMessageByIdAsync(int messageId)
        {
            return await _db.Messages.FindAsync(messageId);
        }
        public async Task UpdateMessageAsync(Message message)
        {
            _db.Messages.Update(message);
            await _db.SaveChangesAsync();
        }
        public async Task DeleteMessageAsync(int messageId)
        {
            var message = await _db.Messages.FindAsync(messageId);
            if (message != null)
            {
                _db.Messages.Remove(message);
                await _db.SaveChangesAsync();
            }
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Repositories/UserRepository.cs">
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
using System.Collections.Generic;
using System.Linq;
namespace PawMatch.Infrastructure.Repositories
{
    public class UserRepository : IUserRepository
    {
        private readonly AppDbContext _context;
        public UserRepository(AppDbContext context)
        {
            _context = context;
        }
        public async Task AddAsync(User user)
        {
            _context.Users.Add(user);
            await _context.SaveChangesAsync();
        }
        public async Task<User> GetByEmailAsync(string email)
        {
            return await _context.Users.FirstOrDefaultAsync(u => u.Email == email);
        }
        public async Task<User> GetByIdAsync(int id)
        {
            return await _context.Users.FirstOrDefaultAsync(u => u.Id == id);
        }
        public async Task UpdateAsync(User user)
        {
            _context.Users.Update(user);
            await _context.SaveChangesAsync();
        }
        public async Task DeleteAsync(int id)
        {
            var user = await _context.Users.FindAsync(id);
            if (user != null)
            {
                _context.Users.Remove(user);
                await _context.SaveChangesAsync();
            }
            // If user is not found, we can choose to throw an exception or handle it silently
            // For now, we will assume the UserService handles the KeyNotFoundException
        }
        public async Task<List<User>> GetByIdsAsync(List<int> ids)
        {
            return await _context.Users.Where(u => ids.Contains(u.Id)).ToListAsync();
        }
    }
}
</file>

<file path="PawMatch.Infrastructure/Repositories/UserSwipeRepository.cs">
using PawMatch.Domain;
using PawMatch.Infrastructure.Interfaces;
using Microsoft.EntityFrameworkCore;
using System.Threading.Tasks;
namespace PawMatch.Infrastructure.Repositories
{
    public class UserSwipeRepository : IUserSwipeRepository
    {
        private readonly AppDbContext _context;
        public UserSwipeRepository(AppDbContext context)
        {
            _context = context;
        }
        public async Task AddAsync(UserSwipe userSwipe)
        {
            await _context.UserSwipes.AddAsync(userSwipe);
            await _context.SaveChangesAsync();
        }
        public async Task<UserSwipe> GetBySwiperAndSwipedUserAsync(int swiperId, int swipedUserId)
        {
            return await _context.UserSwipes
                .FirstOrDefaultAsync(us => us.SwiperId == swiperId && us.SwipedUserId == swipedUserId);
        }
    }
}
</file>

<file path="PawMatch.sln">
Microsoft Visual Studio Solution File, Format Version 12.00
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PawMatch.Domain", "PawMatch.Domain/PawMatch.Domain.csproj", "{F6CA9996-D9C2-4FB4-A293-3F412AB97DD4}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PawMatch.Application", "PawMatch.Application/PawMatch.Application.csproj", "{7ABBB121-3284-42FD-ADA8-CD07A5612CB3}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PawMatch.Infrastructure", "PawMatch.Infrastructure/PawMatch.Infrastructure.csproj", "{43542647-5483-4625-A2F6-894D7951E00A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PawMatch.Api", "PawMatch.Api/PawMatch.Api.csproj", "{7F93D292-D228-4989-B0E5-7F9874577145}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "PawMatch.Tests", "PawMatch.Tests/PawMatch.Tests.csproj", "{82857D4F-42CE-4EC7-B067-1D2DEB8FA860}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F6CA9996-D9C2-4FB4-A293-3F412AB97DD4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F6CA9996-D9C2-4FB4-A293-3F412AB97DD4}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F6CA9996-D9C2-4FB4-A293-3F412AB97DD4}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F6CA9996-D9C2-4FB4-A293-3F412AB97DD4}.Release|Any CPU.Build.0 = Release|Any CPU
		{7ABBB121-3284-42FD-ADA8-CD07A5612CB3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7ABBB121-3284-42FD-ADA8-CD07A5612CB3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7ABBB121-3284-42FD-ADA8-CD07A5612CB3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7ABBB121-3284-42FD-ADA8-CD07A5612CB3}.Release|Any CPU.Build.0 = Release|Any CPU
		{43542647-5483-4625-A2F6-894D7951E00A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{43542647-5483-4625-A2F6-894D7951E00A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{43542647-5483-4625-A2F6-894D7951E00A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{43542647-5483-4625-A2F6-894D7951E00A}.Release|Any CPU.Build.0 = Release|Any CPU
		{7F93D292-D228-4989-B0E5-7F9874577145}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7F93D292-D228-4989-B0E5-7F9874577145}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7F93D292-D228-4989-B0E5-7F9874577145}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7F93D292-D228-4989-B0E5-7F9874577145}.Release|Any CPU.Build.0 = Release|Any CPU
		{82857D4F-42CE-4EC7-B067-1D2DEB8FA860}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{82857D4F-42CE-4EC7-B067-1D2DEB8FA860}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{82857D4F-42CE-4EC7-B067-1D2DEB8FA860}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{82857D4F-42CE-4EC7-B067-1D2DEB8FA860}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal
</file>

<file path="PawMatch.sln.DotSettings.user">
<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003A0200000A_002Eil_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FDecompilerCache_003FILViewer_003F649f9a5315084d038b64e29ea11b1fb56d20_003F0a_003F47eddea8_003F0200000A_002Eil/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003ABase64UrlEncoder_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FDecompilerCache_003Fdecompiler_003F29ff067b86f14e4bb4efbb61ca7e366c5c020_003Ff6_003F277c54ee_003FBase64UrlEncoder_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003ADbContext_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FSourcesCache_003F3bd4df5aff92cabbc4d630be64227073db1b8539b3a1e47786b4b189d7cdb7_003FDbContext_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003A02000016pdb250_002Eil_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FDecompilerCache_003FILViewer_003F0a57c2beca0544ffa75a747802553d2326ae48_003F57_003F47fe8aeb_003F02000016pdb250_002Eil/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AIClassFixture_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FSourcesCache_003Fae7664a35557e6da52239284f9951659c394efee9e9d3754a7747669271fb12_003FIClassFixture_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AJwtSecurityTokenHandler_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FSourcesCache_003F3d4c4ed34e5f94ebe465430b2133a366a26598c20abf8ccde35f7e7ea36e_003FJwtSecurityTokenHandler_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AMatch_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FSourcesCache_003F881b94df1ada40f2f8c71240a283a0fc70144caad05031eb18539ff2f812f67a_003FMatch_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/CodeInspection/ExcludedFiles/FilesAndFoldersToSkip2/=7020124F_002D9FFC_002D4AC3_002D8F3D_002DAAB8E0240759_002Ff_003AOpenApiWorkspace_002Ecs_002Fl_003A_002E_002E_003F_002E_002E_003F_002E_002E_003F_002E_002E_003FUsers_003Fberka_003FAppData_003FRoaming_003FJetBrains_003FRider2024_002E3_003Fresharper_002Dhost_003FSourcesCache_003F89ac77946ec583874df87ebad9601cd883ff54a65af730c0192aaa794f94ab_003FOpenApiWorkspace_002Ecs/@EntryIndexedValue">ForceIncluded</s:String>
	<s:String x:Key="/Default/Environment/AssemblyExplorer/XmlDocument/@EntryValue">&lt;AssemblyExplorer&gt;&#xD;
  &lt;Assembly Path="C:\Users\berka\.nuget\packages\system.identitymodel.tokens.jwt\8.12.0\lib\net8.0\System.IdentityModel.Tokens.Jwt.dll" /&gt;&#xD;
&lt;/AssemblyExplorer&gt;</s:String>
	<s:String x:Key="/Default/Environment/UnitTesting/UnitTestSessionStore/Sessions/=28db82e0_002D24d3_002D451e_002D9b1c_002Dd8e294443eee/@EntryIndexedValue">&lt;SessionState ContinuousTestingMode="0" IsActive="True" Name="All tests from &amp;lt;PawMatch.Tests&amp;gt; #2" xmlns="urn:schemas-jetbrains-com:jetbrains-ut-session"&gt;&#xD;
  &lt;Project Location="C:\Projects\Business\PawMatch\api\PawMatch.Tests" Presentation="&amp;lt;PawMatch.Tests&amp;gt;" /&gt;&#xD;
&lt;/SessionState&gt;</s:String>
	<s:String x:Key="/Default/Environment/UnitTesting/UnitTestSessionStore/Sessions/=7b7a92e2_002D6eb4_002D4d97_002D9873_002Dc07e1d6ae584/@EntryIndexedValue">&lt;SessionState ContinuousTestingMode="0" Name="All tests from &amp;lt;PawMatch.Tests&amp;gt;" xmlns="urn:schemas-jetbrains-com:jetbrains-ut-session"&gt;&#xD;
  &lt;Project Location="C:\Projects\Business\PawMatch\api\PawMatch.Tests" Presentation="&amp;lt;PawMatch.Tests&amp;gt;" /&gt;&#xD;
&lt;/SessionState&gt;</s:String></wpf:ResourceDictionary>
</file>

<file path="PawMatch.Tests/.gitignore">
# Build
bin/
obj/

# Test Results
TestResults/
*.trx
*.coverage
*.coveragexml
coverage/

# Logs
*.log
logs/
</file>

<file path="PawMatch.Tests/CustomWebApplicationFactory.cs">
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using PawMatch.Infrastructure;
using PawMatch.Api; // PawMatch.Api projesini import edin
using Moq; // Add this using statement
using PawMatch.Infrastructure.Interfaces; // Add this using statement
using System.Linq; // Already there, but ensure it is
using System.Collections.Concurrent; // Add for ConcurrentDictionary
using Microsoft.Extensions.Hosting; // Required for IHostEnvironment
using Microsoft.Extensions.Hosting.Internal; // Required for HostingEnvironment
using Microsoft.Extensions.Configuration;
namespace PawMatch.Tests;
public class CustomWebApplicationFactory<TProgram> : WebApplicationFactory<TProgram> where TProgram : class
{
    // In-memory storage for mocked files
    private readonly ConcurrentDictionary<string, (string FileName, Stream Content)> _mockedFiles = new ConcurrentDictionary<string, (string, Stream)>();
    private readonly string _databaseName;
    public CustomWebApplicationFactory()
    {
        _databaseName = Guid.NewGuid().ToString();
    }
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.UseEnvironment("Testing");
        builder.ConfigureServices(services =>
        {
            // Remove all existing DbContextOptions<AppDbContext> registrations
            var dbContextOptionsDescriptors = services.Where(
                d => d.ServiceType == typeof(DbContextOptions<AppDbContext>)).ToList();
            foreach (var descriptor in dbContextOptionsDescriptors)
            {
                services.Remove(descriptor);
            }
            // Remove all existing AppDbContext registrations
            var appDbContextDescriptors = services.Where(
                d => d.ServiceType == typeof(AppDbContext)).ToList();
            foreach (var descriptor in appDbContextDescriptors)
            {
                services.Remove(descriptor);
            }
            // Remove the real IStorageProvider registration if it exists
            var storageProviderDescriptor = services.SingleOrDefault(
                d => d.ServiceType == typeof(IStorageProvider));
            if (storageProviderDescriptor != null)
            {
                services.Remove(storageProviderDescriptor);
            }
            // Remove existing IHostEnvironment registration if any
            var hostEnvironmentDescriptor = services.SingleOrDefault(d =>
                d.ServiceType == typeof(IHostEnvironment));
            if (hostEnvironmentDescriptor != null)
            {
                services.Remove(hostEnvironmentDescriptor);
            }
            // Add a custom IHostEnvironment for testing to ensure it's Production
            services.AddSingleton<IHostEnvironment>(new HostingEnvironment
            {
                EnvironmentName = "Testing",
                ApplicationName = "PawMatch.Api"
            });
            // Add a DbContext using an in-memory database for testing
            services.AddDbContext<AppDbContext>(options =>
            {
                options.UseInMemoryDatabase(_databaseName);
            });
            // Register a mocked IStorageProvider
            var mockStorageProvider = new Mock<IStorageProvider>();
            // Configure mock behavior for UploadAsync
            mockStorageProvider.Setup(s => s.UploadAsync(It.IsAny<Stream>(), It.IsAny<string>(), It.IsAny<string>()))
                               .ReturnsAsync((Stream stream, string fileName, string contentType) =>
                               {
                                   var fileId = Guid.NewGuid().ToString();
                                   var memoryStream = new MemoryStream();
                                   stream.CopyTo(memoryStream);
                                   memoryStream.Position = 0; // Reset position for future reads
                                   _mockedFiles[fileId] = (fileName, memoryStream);
                                   return fileId;
                               });
            // Configure mock behavior for DeleteAsync
            mockStorageProvider.Setup(s => s.DeleteAsync(It.IsAny<string>()))
                               .Returns((string fileId) =>
                               {
                                   _mockedFiles.TryRemove(fileId, out _);
                                   return Task.CompletedTask;
                               });
            // Configure mock behavior for DownloadAsync
            mockStorageProvider.Setup(s => s.DownloadAsync(It.IsAny<string>()))
                               .ReturnsAsync((string fileId) =>
                               {
                                   if (_mockedFiles.TryGetValue(fileId, out var fileData))
                                   {
                                       var newMemoryStream = new MemoryStream();
                                       fileData.Content.CopyTo(newMemoryStream);
                                       newMemoryStream.Position = 0;
                                       return newMemoryStream;
                                   }
                                   // Return an empty stream for not found files (or throw specific exception)
                                   return new MemoryStream(); 
                               });
            services.AddSingleton(mockStorageProvider.Object);
            // Build the service provider.
            var sp = services.BuildServiceProvider();
            // Create a scope to obtain a reference to the database contexts
            using (var scope = sp.CreateScope())
            {
                var scopedServices = scope.ServiceProvider;
                var db = scopedServices.GetRequiredService<AppDbContext>();
                // Ensure the database is created and is clean for each test.
                db.Database.EnsureDeleted(); // Clear the database before creating
                db.Database.EnsureCreated();
                // Seed the database with some test data.
                // We can add simple data here for tests, or use the existing seed method if suitable.
                PawMatch.Infrastructure.AppDbContext.AppDbContextSeed.Seed(db);
            }
        });
    }
}
</file>

<file path="PawMatch.Tests/DiscoverServiceTests.cs">
using Xunit;
using Microsoft.AspNetCore.Mvc.Testing;
using System.Threading.Tasks;
using PawMatch.Api;
using System.Net.Http;
using System.Net.Http.Json;
using PawMatch.Application.DTOs;
using System.Text.Json;
using System.Net;
using PawMatch.Infrastructure;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.EntityFrameworkCore;
using System.Linq;
using PawMatch.Domain;
using System;
using PawMatch.Application.Interfaces;
namespace PawMatch.Tests
{
    public class DiscoverServiceTests : IClassFixture<CustomWebApplicationFactory<Program>>
    {
        private readonly HttpClient _client;
        private readonly CustomWebApplicationFactory<Program> _factory;
        public DiscoverServiceTests(CustomWebApplicationFactory<Program> factory)
        {
            _factory = factory;
            _client = _factory.CreateClient();
        }
        private async Task<(string token, int userId)> RegisterAndLoginNewUser(string name, string email, string password)
        {
            var registerDto = new UserRegisterDto { Name = name, Email = email, Password = password };
            var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerDto);
            registerResponse.EnsureSuccessStatusCode();
            var authResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
            return (authResponse.Data.Token, authResponse.Data.UserPrivate.Id);
        }
        [Fact]
        public async Task Discover_ExcludesSwipedUsersWithinExclusionPeriod()
        {
            // Arrange
            var (_, user1Id) = await RegisterAndLoginNewUser("DiscUser1", "disc1@example.com", "Password123!");
            var (_, user2Id) = await RegisterAndLoginNewUser("DiscUser2", "disc2@example.com", "Password123!");
            var (_, user3Id) = await RegisterAndLoginNewUser("DiscUser3", "disc3@example.com", "Password123!");
            // User1 swipes (likes) User2 directly in the database
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var userSwipe = new UserSwipe
                {
                    SwiperId = user1Id,
                    SwipedUserId = user2Id,
                    IsLiked = true,
                    SwipeDate = DateTime.UtcNow
                };
                await dbContext.UserSwipes.AddAsync(userSwipe);
                await dbContext.SaveChangesAsync();
            }
            // Act: User1 discovers users by directly calling the service
            using (var scope = _factory.Services.CreateScope())
            {
                var discoverService = scope.ServiceProvider.GetRequiredService<IDiscoverService>();
                var discoveredUsers = await discoverService.DiscoverUsersAsync(user1Id);
                var discoveredUserIds = discoveredUsers.Select(u => u.User.Id).ToList();
                // Assert
                Assert.NotNull(discoveredUserIds);
                Assert.DoesNotContain(user2Id, discoveredUserIds); // User2 should be excluded
                Assert.Contains(user3Id, discoveredUserIds); // User3 should be discoverable
            }
        }
        [Fact]
        public async Task Discover_IncludesUsersSwipedOnOutsideExclusionPeriod()
        {
            // Arrange
            var (_, user1Id) = await RegisterAndLoginNewUser("DiscUser4", "disc4@example.com", "Password123!");
            var (_, user2Id) = await RegisterAndLoginNewUser("DiscUser5", "disc5@example.com", "Password123!");
            var (_, user3Id) = await RegisterAndLoginNewUser("DiscUser6", "disc6@example.com", "Password123!");
            // Manually add a swipe record for User1 swiping User2, but set SwipeDate to be outside the exclusion period
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var userSwipe = new UserSwipe
                {
                    SwiperId = user1Id,
                    SwipedUserId = user2Id,
                    IsLiked = true,
                    SwipeDate = DateTime.UtcNow.AddDays(-60) // Assuming default exclusion is 30 days
                };
                await dbContext.UserSwipes.AddAsync(userSwipe);
                await dbContext.SaveChangesAsync();
            }
            // Act: User1 discovers users by directly calling the service
            using (var scope = _factory.Services.CreateScope())
            {
                var discoverService = scope.ServiceProvider.GetRequiredService<IDiscoverService>();
                var discoveredUsers = await discoverService.DiscoverUsersAsync(user1Id);
                var discoveredUserIds = discoveredUsers.Select(u => u.User.Id).ToList();
                // Assert
                Assert.NotNull(discoveredUserIds);
                // User2 should NOT be in the discovered list for User1 because the swipe was a like, which are permanently excluded.
                Assert.DoesNotContain(user2Id, discoveredUserIds); 
                Assert.Contains(user3Id, discoveredUserIds);
            }
        }
        [Fact]
        public async Task Discover_ReincludesPassedUsersAfterReappearDuration()
        {
            // Arrange
            var (_, user1Id) = await RegisterAndLoginNewUser("ReappearUser1", "reappear1@example.com", "Password123!");
            var (_, user2Id) = await RegisterAndLoginNewUser("ReappearUser2", "reappear2@example.com", "Password123!");
            var (_, user3Id) = await RegisterAndLoginNewUser("ReappearUser3", "reappear3@example.com", "Password123!");
            // User1 passes User2, but the swipe date is older than the reappear duration (e.g., 90 days default)
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var userSwipe = new UserSwipe
                {
                    SwiperId = user1Id,
                    SwipedUserId = user2Id,
                    IsLiked = false, // Passed
                    SwipeDate = DateTime.UtcNow.AddDays(-100) // Older than 90 days reappear duration
                };
                await dbContext.UserSwipes.AddAsync(userSwipe);
                await dbContext.SaveChangesAsync();
            }
            // Act: User1 discovers users by directly calling the service
            using (var scope = _factory.Services.CreateScope())
            {
                var discoverService = scope.ServiceProvider.GetRequiredService<IDiscoverService>();
                var discoveredUsers = await discoverService.DiscoverUsersAsync(user1Id);
                var discoveredUserIds = discoveredUsers.Select(u => u.User.Id).ToList();
                // Assert
                Assert.NotNull(discoveredUserIds);
                Assert.Contains(user2Id, discoveredUserIds); // User2 should reappear in discovery list
                Assert.Contains(user3Id, discoveredUserIds); // User3 should still be discoverable
            }
        }
        [Fact]
        public async Task Discover_ExcludesPassedUsersWithinReappearDuration()
        {
            // Arrange
            var (_, user1Id) = await RegisterAndLoginNewUser("ExcludeReappearUser1", "exreappear1@example.com", "Password123!");
            var (_, user2Id) = await RegisterAndLoginNewUser("ExcludeReappearUser2", "exreappear2@example.com", "Password123!");
            var (_, user3Id) = await RegisterAndLoginNewUser("ExcludeReappearUser3", "exreappear3@example.com", "Password123!");
            // User1 passes User2, and the swipe date is within the reappear duration (e.g., 90 days default)
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var userSwipe = new UserSwipe
                {
                    SwiperId = user1Id,
                    SwipedUserId = user2Id,
                    IsLiked = false, // Passed
                    SwipeDate = DateTime.UtcNow.AddDays(-10) // Within 90 days reappear duration
                };
                await dbContext.UserSwipes.AddAsync(userSwipe);
                await dbContext.SaveChangesAsync();
            }
            // Act: User1 discovers users by directly calling the service
            using (var scope = _factory.Services.CreateScope())
            {
                var discoverService = scope.ServiceProvider.GetRequiredService<IDiscoverService>();
                var discoveredUsers = await discoverService.DiscoverUsersAsync(user1Id);
                var discoveredUserIds = discoveredUsers.Select(u => u.User.Id).ToList();
                // Assert
                Assert.NotNull(discoveredUserIds);
                Assert.DoesNotContain(user2Id, discoveredUserIds); // User2 should NOT reappear in discovery list yet
                Assert.Contains(user3Id, discoveredUserIds); // User3 should still be discoverable
            }
        }
        [Fact]
        public async Task Discover_WithMaxDistanceKm_ReturnsSuccess()
        {
            // Arrange
            var (user1Token, user1Id) = await RegisterAndLoginNewUser("DiscUser7", "disc7@example.com", "Password123!");
            var (user2Token, user2Id) = await RegisterAndLoginNewUser("DiscUser8", "disc8@example.com", "Password123!");
            // Act
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user1Token);
            var discoverResponse = await _client.GetAsync($"/api/v1/matches/discover?maxDistanceKm=100");
            // Assert
            discoverResponse.EnsureSuccessStatusCode();
            var result = await discoverResponse.Content.ReadFromJsonAsync<ApiResponse<List<DiscoverUserPetDto>>>();
            Assert.NotNull(result);
            Assert.NotNull(result.Data);
            // Further assertions would depend on actual geographical data and filtering logic
        }
        [Fact]
        public async Task Discover_WithPreferredPetType_ReturnsSuccess()
        {
            // Arrange
            var (user1Token, user1Id) = await RegisterAndLoginNewUser("DiscUser9", "disc9@example.com", "Password123!");
            var (user2Token, user2Id) = await RegisterAndLoginNewUser("DiscUser10", "disc10@example.com", "Password123!");
            // Act
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user1Token);
            var discoverResponse = await _client.GetAsync($"/api/v1/matches/discover?preferredPetType=dog");
            // Assert
            discoverResponse.EnsureSuccessStatusCode();
            var result = await discoverResponse.Content.ReadFromJsonAsync<ApiResponse<List<DiscoverUserPetDto>>>();
            Assert.NotNull(result);
            Assert.NotNull(result.Data);
            // Further assertions would depend on actual pet data and filtering logic
        }
    }
}
</file>

<file path="PawMatch.Tests/MatchesControllerTests.cs">
using Xunit;
using Microsoft.AspNetCore.Mvc.Testing;
using System.Threading.Tasks;
using PawMatch.Api;
using System.Net.Http;
using System.Net.Http.Json;
using PawMatch.Application.DTOs;
using System.Text.Json;
using System.Net;
using PawMatch.Infrastructure;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.EntityFrameworkCore;
using System.Linq;
using PawMatch.Domain;
using Moq;
using PawMatch.Application.Interfaces;
using PawMatch.Application.Services;
using PawMatch.Infrastructure.Repositories;
using PawMatch.Infrastructure.Interfaces;
using Microsoft.Extensions.Logging;
namespace PawMatch.Tests
{
    public class MatchesControllerTests : IClassFixture<CustomWebApplicationFactory<Program>>
    {
        private readonly HttpClient _client;
        private readonly CustomWebApplicationFactory<Program> _factory;
        public MatchesControllerTests(CustomWebApplicationFactory<Program> factory)
        {
            _factory = factory;
            _client = _factory.CreateClient();
        }
        private async Task<(string token, int userId)> AuthenticateUser(string email, string password)
        {
            var loginDto = new UserLoginDto { Email = email, Password = password };
            var loginResponse = await _client.PostAsJsonAsync("/api/v1/users/login", loginDto);
            loginResponse.EnsureSuccessStatusCode();
            var authResponse = await loginResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
            return (authResponse.Data.Token, authResponse.Data.UserPrivate.Id);
        }
        private async Task<(string token, int userId)> RegisterAndLoginNewUser(string name, string email, string password)
        {
            var registerDto = new UserRegisterDto { Name = name, Email = email, Password = password };
            var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerDto);
            registerResponse.EnsureSuccessStatusCode();
            var authResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
            return (authResponse.Data.Token, authResponse.Data.UserPrivate.Id);
        }
        [Fact]
        public async Task LikeOrPass_SuccessfulLikeAndReciprocalMatch_ReturnsConfirmedTrue()
        {
            // Arrange
            var (user1Token, user1Id) = await RegisterAndLoginNewUser("TestUser1", "test1@example.com", "Password123!");
            var (user2Token, user2Id) = await RegisterAndLoginNewUser("TestUser2", "test2@example.com", "Password123!");
            // User2 likes User1 (reciprocal swipe)
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user2Token);
            var user2LikesUser1Dto = new MatchActionDto { User1Id = user2Id, User2Id = user1Id, Liked = true };
            await _client.PostAsJsonAsync("/api/v1/matches", user2LikesUser1Dto);
            // Act: User1 likes User2
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user1Token);
            var user1LikesUser2Dto = new MatchActionDto { User1Id = user1Id, User2Id = user2Id, Liked = true };
            var response = await _client.PostAsJsonAsync("/api/v1/matches", user1LikesUser2Dto);
            // Assert
            response.EnsureSuccessStatusCode();
            var result = await response.Content.ReadFromJsonAsync<ApiResponse<MatchResultDto>>();
            Assert.NotNull(result);
            Assert.True(result.Data.Confirmed);
            Assert.True(result.Data.MatchId > 0);
            // Verify match in DB
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var match = await dbContext.Matches.FirstOrDefaultAsync(m => (m.User1Id == user1Id && m.User2Id == user2Id) || (m.User1Id == user2Id && m.User2Id == user1Id));
                Assert.NotNull(match);
                Assert.True(match.Confirmed);
            }
        }
        [Fact]
        public async Task LikeOrPass_SuccessfulLikeNoReciprocalMatch_ReturnsConfirmedFalse()
        {
            // Arrange
            var (user1Token, user1Id) = await RegisterAndLoginNewUser("TestUser3", "test3@example.com", "Password123!");
            var (user2Token, user2Id) = await RegisterAndLoginNewUser("TestUser4", "test4@example.com", "Password123!");
            // Act: User1 likes User2 (no reciprocal like yet)
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user1Token);
            var user1LikesUser2Dto = new MatchActionDto { User1Id = user1Id, User2Id = user2Id, Liked = true };
            var response = await _client.PostAsJsonAsync("/api/v1/matches", user1LikesUser2Dto);
            // Assert
            response.EnsureSuccessStatusCode();
            var result = await response.Content.ReadFromJsonAsync<ApiResponse<MatchResultDto>>();
            Assert.NotNull(result);
            Assert.False(result.Data.Confirmed);
            Assert.Equal(0, result.Data.MatchId); // No match created yet
            // Verify no match in DB
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var match = await dbContext.Matches.FirstOrDefaultAsync(m => (m.User1Id == user1Id && m.User2Id == user2Id) || (m.User1Id == user2Id && m.User2Id == user1Id));
                Assert.Null(match);
            }
        }
        [Fact]
        public async Task LikeOrPass_SuccessfulPass_ReturnsConfirmedFalseAndUpdatesExistingMatch()
        {
            // Arrange
            var (user1Token, user1Id) = await RegisterAndLoginNewUser("TestUser5", "test5@example.com", "Password123!");
            var (user2Token, user2Id) = await RegisterAndLoginNewUser("TestUser6", "test6@example.com", "Password123!");
            // Ensure a confirmed match exists first
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                await dbContext.Matches.AddAsync(new Domain.Match { User1Id = user1Id, User2Id = user2Id, Confirmed = true });
                await dbContext.SaveChangesAsync();
            }
            // Act: User1 passes User2
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user1Token);
            var user1PassesUser2Dto = new MatchActionDto { User1Id = user1Id, User2Id = user2Id, Liked = false };
            var response = await _client.PostAsJsonAsync("/api/v1/matches", user1PassesUser2Dto);
            // Assert
            response.EnsureSuccessStatusCode();
            var result = await response.Content.ReadFromJsonAsync<ApiResponse<MatchResultDto>>();
            Assert.NotNull(result);
            Assert.False(result.Data.Confirmed);
            // Verify match is unconfirmed in DB
            using (var scope = _factory.Services.CreateScope())
            {
                var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
                var match = await dbContext.Matches.FirstOrDefaultAsync(m => (m.User1Id == user1Id && m.User2Id == user2Id) || (m.User1Id == user2Id && m.User2Id == user1Id));
                Assert.NotNull(match);
                Assert.False(match.Confirmed);
            }
        }
        [Fact]
        public async Task LikeOrPass_InvalidUser1Id_ReturnsUnauthorized()
        {
            // Arrange
            var (user1Token, user1Id) = await RegisterAndLoginNewUser("TestUser7", "test7@example.com", "Password123!");
            var (_, user2Id) = await RegisterAndLoginNewUser("TestUser8", "test8@example.com", "Password123!");
            // Act: User1 tries to act on behalf of a different user (user2Id)
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", user1Token);
            var invalidActionDto = new MatchActionDto { User1Id = user2Id, User2Id = user1Id, Liked = true }; // Invalid User1Id
            var response = await _client.PostAsJsonAsync("/api/v1/matches", invalidActionDto);
            // Assert
            Assert.Equal(HttpStatusCode.Unauthorized, response.StatusCode);
        }
        [Fact]
        public async Task LikeOrPassAsync_ConfirmedMatch_CallsSendMatchNotificationAsyncForBothUsers()
        {
            // Arrange
            var dbContextOptions = new DbContextOptionsBuilder<AppDbContext>()
                .UseInMemoryDatabase(databaseName: $"TestDb_{Guid.NewGuid()}")
                .Options;
            using var db = new AppDbContext(dbContextOptions);
            var userSwipeRepo = new UserSwipeRepository(db);
            var mockNotification = new Mock<IRealtimeNotificationService>();
            var mockLogger = new Mock<ILogger<MatchService>>();
            var mockMatchRepo = new Mock<IMatchRepository>();
            var matchService = new MatchService(db, userSwipeRepo, mockNotification.Object, mockLogger.Object, mockMatchRepo.Object);
            // KullanÄ±cÄ±lar ve reciprocal swipe oluÅŸtur
            var user1Id = 1;
            var user2Id = 2;
            db.Users.Add(new User { Id = user1Id, Name = "User1", Email = "user1@example.com", PasswordHash = "hashed" });
            db.Users.Add(new User { Id = user2Id, Name = "User2", Email = "user2@example.com", PasswordHash = "hashed" });
            db.SaveChanges();
            await userSwipeRepo.AddAsync(new UserSwipe { SwiperId = user2Id, SwipedUserId = user1Id, IsLiked = true, SwipeDate = DateTime.UtcNow });
            var dto = new MatchActionDto { User1Id = user1Id, User2Id = user2Id, Liked = true };
            // Act
            var result = await matchService.LikeOrPassAsync(user1Id, dto);
            // Assert
            Assert.True(result.Confirmed);
            mockNotification.Verify(m => m.SendMatchNotificationAsync(user1Id, user2Id, It.Is<MatchResultDto>(r => r.Confirmed)), Times.Once);
        }
        [Fact]
        public async Task LikeOrPassAsync_NoReciprocalMatch_DoesNotCallSendMatchNotificationAsync()
        {
            // Arrange
            var dbContextOptions = new DbContextOptionsBuilder<AppDbContext>()
                .UseInMemoryDatabase(databaseName: $"TestDb_{Guid.NewGuid()}")
                .Options;
            using var db = new AppDbContext(dbContextOptions);
            var userSwipeRepo = new UserSwipeRepository(db);
            var mockNotification = new Mock<IRealtimeNotificationService>();
            var mockLogger = new Mock<ILogger<MatchService>>();
            var mockMatchRepo = new Mock<IMatchRepository>();
            var matchService = new MatchService(db, userSwipeRepo, mockNotification.Object, mockLogger.Object, mockMatchRepo.Object);
            var user1Id = 1;
            var user2Id = 2;
            db.Users.Add(new User { Id = user1Id, Name = "User1", Email = "user1@example.com", PasswordHash = "hashed" });
            db.Users.Add(new User { Id = user2Id, Name = "User2", Email = "user2@example.com", PasswordHash = "hashed" });
            db.SaveChanges();
            // reciprocal swipe yok
            var dto = new MatchActionDto { User1Id = user1Id, User2Id = user2Id, Liked = true };
            // Act
            var result = await matchService.LikeOrPassAsync(user1Id, dto);
            // Assert
            Assert.False(result.Confirmed);
            mockNotification.Verify(m => m.SendMatchNotificationAsync(It.IsAny<int>(), It.IsAny<int>(), It.IsAny<MatchResultDto>()), Times.Never);
        }
    }
    public class MessageServiceNotificationTests
    {
        [Fact]
        public async Task SendMessageAsync_ValidMessage_CallsSendMessageNotificationAndSavesToDb()
        {
            // Arrange
            var dbContextOptions = new DbContextOptionsBuilder<AppDbContext>()
                .UseInMemoryDatabase(databaseName: $"TestDb_{Guid.NewGuid()}")
                .Options;
            using var db = new AppDbContext(dbContextOptions);
            var messageRepo = new MessageRepository(db);
            var mockNotification = new Mock<IRealtimeNotificationService>();
            var mockUserRepo = new Mock<IUserRepository>();
            var messageService = new MessageService(messageRepo, mockNotification.Object, mockUserRepo.Object);
            // Test users
            var senderId = 1;
            var recipientId = 2;
            var sender = new User { Id = senderId, Name = "Sender", Email = "sender@example.com", PasswordHash = "hashed" };
            var recipient = new User { Id = recipientId, Name = "Recipient", Email = "recipient@example.com", PasswordHash = "hashed" };
            db.Users.Add(sender);
            db.Users.Add(recipient);
            db.SaveChanges();
            mockUserRepo.Setup(r => r.GetByIdAsync(senderId)).ReturnsAsync(sender);
            mockUserRepo.Setup(r => r.GetByIdAsync(recipientId)).ReturnsAsync(recipient);
            var content = "Merhaba!";
            // Act
            var message = await messageService.SendMessageAsync(senderId, recipientId, content);
            // Assert
            Assert.NotNull(message);
            Assert.Equal(senderId, message.SenderId);
            Assert.Equal(recipientId, message.RecipientId);
            Assert.Equal(content, message.Content);
            mockNotification.Verify(m => m.SendMessageAsync(recipientId, It.Is<Message>(msg => msg.Content == content && msg.SenderId == senderId)), Times.Once);
            // Mesaj veritabanÄ±na kaydedildi mi?
            var dbMessage = db.Messages.FirstOrDefault(m => m.SenderId == senderId && m.RecipientId == recipientId && m.Content == content);
            Assert.NotNull(dbMessage);
        }
        [Fact]
        public async Task SendMessageAsync_InvalidRecipient_ThrowsArgumentException()
        {
            // Arrange
            var dbContextOptions = new DbContextOptionsBuilder<AppDbContext>()
                .UseInMemoryDatabase(databaseName: $"TestDb_{Guid.NewGuid()}")
                .Options;
            using var db = new AppDbContext(dbContextOptions);
            var messageRepo = new MessageRepository(db);
            var mockNotification = new Mock<IRealtimeNotificationService>();
            var mockUserRepo = new Mock<IUserRepository>();
            var messageService = new MessageService(messageRepo, mockNotification.Object, mockUserRepo.Object);
            var senderId = 1;
            var recipientId = 999; // GeÃ§ersiz
            var sender = new User { Id = senderId, Name = "Sender", Email = "sender@example.com", PasswordHash = "hashed" };
            db.Users.Add(sender);
            db.SaveChanges();
            mockUserRepo.Setup(r => r.GetByIdAsync(senderId)).ReturnsAsync(sender);
            mockUserRepo.Setup(r => r.GetByIdAsync(recipientId)).ReturnsAsync((User)null);
            var content = "GeÃ§ersiz alÄ±cÄ±ya mesaj";
            // Act & Assert
            await Assert.ThrowsAsync<ArgumentException>(() => messageService.SendMessageAsync(senderId, recipientId, content));
        }
        [Fact]
        public async Task SendMessageAsync_InvalidSender_ThrowsArgumentException()
        {
            // Arrange
            var dbContextOptions = new DbContextOptionsBuilder<AppDbContext>()
                .UseInMemoryDatabase(databaseName: $"TestDb_{Guid.NewGuid()}")
                .Options;
            using var db = new AppDbContext(dbContextOptions);
            var messageRepo = new MessageRepository(db);
            var mockNotification = new Mock<IRealtimeNotificationService>();
            var mockUserRepo = new Mock<IUserRepository>();
            var messageService = new MessageService(messageRepo, mockNotification.Object, mockUserRepo.Object);
            var senderId = 1; // GeÃ§ersiz
            var recipientId = 2;
            var recipient = new User { Id = recipientId, Name = "Recipient", Email = "recipient@example.com", PasswordHash = "hashed" };
            db.Users.Add(recipient);
            db.SaveChanges();
            mockUserRepo.Setup(r => r.GetByIdAsync(senderId)).ReturnsAsync((User)null);
            mockUserRepo.Setup(r => r.GetByIdAsync(recipientId)).ReturnsAsync(recipient);
            var content = "Yetkisiz gÃ¶nderici";
            // Act & Assert
            await Assert.ThrowsAsync<ArgumentException>(() => messageService.SendMessageAsync(senderId, recipientId, content));
        }
    }
}
</file>

<file path="PawMatch.Tests/PawMatch.Tests.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>

        <IsPackable>false</IsPackable>
        <IsTestProject>true</IsTestProject>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="coverlet.collector" Version="6.0.0"/>
        <PackageReference Include="Microsoft.AspNetCore.SignalR.Client" Version="10.0.0-preview.5.25277.114" />
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.8.0"/>
        <PackageReference Include="xunit" Version="2.*"/>
        <PackageReference Include="xunit.runner.visualstudio" Version="2.5.3"/>
        <PackageReference Include="Moq" Version="4.*"/>
        <PackageReference Include="Microsoft.EntityFrameworkCore.InMemory" Version="8.*"/>
        <PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="8.*" />
        <ProjectReference Include="..\PawMatch.Api\PawMatch.Api.csproj" />
        <ProjectReference Include="..\PawMatch.Application\PawMatch.Application.csproj" />
        <ProjectReference Include="..\PawMatch.Domain\PawMatch.Domain.csproj" />
        <ProjectReference Include="..\PawMatch.Infrastructure\PawMatch.Infrastructure.csproj" />
    </ItemGroup>

    <ItemGroup>
        <Using Include="Xunit"/>
    </ItemGroup>

</Project>
</file>

<file path="PawMatch.Tests/PhotosControllerTests.cs">
using System.Net.Http.Json;
using Xunit;
using System.Threading.Tasks;
using PawMatch.Api;
using PawMatch.Application.DTOs;
using System.Net.Http.Headers;
using System.IO;
namespace PawMatch.Tests;
public class PhotosControllerTests : IClassFixture<CustomWebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public PhotosControllerTests(CustomWebApplicationFactory<Program> factory)
    {
        _client = factory.CreateClient();
    }
    [Fact]
    public async Task UploadUserPhoto_ValidFileAndAuth_ReturnsSuccess()
    {
        // Arrange: Register and log in a user
        var registerRequest = new UserRegisterDto
        {
            Name = "Photo Uploader",
            Email = "photoupload@example.com",
            Password = "Password123!"
        };
        var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerRequest);
        registerResponse.EnsureSuccessStatusCode();
        var registerApiResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        var authToken = registerApiResponse.Data.Token;
        _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", authToken);
        // Create a mock file (testphoto.jpg)
        var filePath = "testphoto.jpg";
        var fileContent = "This is a dummy image content for testing.";
        var memoryStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(fileContent));
        var content = new MultipartFormDataContent();
        var streamContent = new StreamContent(memoryStream);
        streamContent.Headers.ContentType = new MediaTypeHeaderValue("image/jpeg");
        content.Add(streamContent, "file", filePath);
        // Act
        var response = await _client.PostAsync("/api/v1/photos/user", content);
        // Assert
        response.EnsureSuccessStatusCode(); // Expect 200 OK
        var apiResponse = await response.Content.ReadFromJsonAsync<ApiResponse<PhotoDto>>();
        Assert.NotNull(apiResponse);
        Assert.Equal("success", apiResponse.Status);
        Assert.NotNull(apiResponse.Data);
        Assert.Equal(filePath, apiResponse.Data.FileName);
        Assert.NotNull(apiResponse.Data.GoogleDriveFileId);
        // Clean up
        _client.DefaultRequestHeaders.Authorization = null;
    }
    [Fact]
    public async Task GetPhoto_ValidIdAndAuth_ReturnsPhotoStream()
    {
        // Arrange: Register, log in, and upload a photo
        var registerRequest = new UserRegisterDto
        {
            Name = "Photo Getter",
            Email = "photoget@example.com",
            Password = "Password123!"
        };
        var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerRequest);
        registerResponse.EnsureSuccessStatusCode();
        var registerApiResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        var authToken = registerApiResponse.Data.Token;
        _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", authToken);
        var filePath = "testphoto_get.jpg";
        var fileContent = "This is content for getting a photo.";
        var memoryStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(fileContent));
        var content = new MultipartFormDataContent();
        var streamContent = new StreamContent(memoryStream);
        streamContent.Headers.ContentType = new MediaTypeHeaderValue("image/jpeg");
        content.Add(streamContent, "file", filePath);
        var uploadResponse = await _client.PostAsync("/api/v1/photos/user", content);
        uploadResponse.EnsureSuccessStatusCode();
        var uploadApiResponse = await uploadResponse.Content.ReadFromJsonAsync<ApiResponse<PhotoDto>>();
        var googleDriveFileId = uploadApiResponse.Data.GoogleDriveFileId;
        // Act: Get the photo stream
        var getResponse = await _client.GetAsync($"/api/v1/photos/{googleDriveFileId}");
        // Assert: Check if the response is successful and content matches
        getResponse.EnsureSuccessStatusCode();
        var returnedContent = await getResponse.Content.ReadAsStringAsync();
        Assert.Equal(fileContent, returnedContent);
        // Clean up
        _client.DefaultRequestHeaders.Authorization = null;
    }
    [Fact]
    public async Task DeletePhoto_ValidIdAndAuth_ReturnsSuccess()
    {
        // Arrange: Register, log in, and upload a photo
        var registerRequest = new UserRegisterDto
        {
            Name = "Photo Deleter",
            Email = "photodelete@example.com",
            Password = "Password123!"
        };
        var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerRequest);
        registerResponse.EnsureSuccessStatusCode();
        var registerApiResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        var authToken = registerApiResponse.Data.Token;
        _client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", authToken);
        var filePath = "testphoto_delete.jpg";
        var fileContent = "This is content for deleting a photo.";
        var memoryStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(fileContent));
        var content = new MultipartFormDataContent();
        var streamContent = new StreamContent(memoryStream);
        streamContent.Headers.ContentType = new MediaTypeHeaderValue("image/jpeg");
        content.Add(streamContent, "file", filePath);
        var uploadResponse = await _client.PostAsync("/api/v1/photos/user", content);
        uploadResponse.EnsureSuccessStatusCode();
        var uploadApiResponse = await uploadResponse.Content.ReadFromJsonAsync<ApiResponse<PhotoDto>>();
        var googleDriveFileId = uploadApiResponse.Data.GoogleDriveFileId; // Use GoogleDriveFileId for deletion
        // Act: Delete the photo
        var deleteResponse = await _client.DeleteAsync($"/api/v1/photos/{googleDriveFileId}");
        // Assert: Check if the deletion was successful
        deleteResponse.EnsureSuccessStatusCode(); // Expect 200 OK
        var deleteApiResponse = await deleteResponse.Content.ReadFromJsonAsync<ApiResponse<object>>();
        Assert.NotNull(deleteApiResponse);
        Assert.Equal("success", deleteApiResponse.Status);
        // Optional: Try to get the photo again to confirm deletion (expect 404 Not Found)
        var getResponseAfterDelete = await _client.GetAsync($"/api/v1/photos/{googleDriveFileId}");
        Assert.Equal(System.Net.HttpStatusCode.NotFound, getResponseAfterDelete.StatusCode); // Changed from Unauthorized to NotFound
        // Clean up
        _client.DefaultRequestHeaders.Authorization = null;
    }
}
</file>

<file path="PawMatch.Tests/SignalRHubTests.cs">
using Microsoft.AspNetCore.SignalR.Client;
using PawMatch.Api;
using System.Net.Http;
using System.Net.Http.Json;
using PawMatch.Application.DTOs;
using System.Threading.Tasks;
using System;
namespace PawMatch.Tests;
public class SignalRHubTests : IClassFixture<CustomWebApplicationFactory<Program>>
{
    private readonly CustomWebApplicationFactory<Program> _factory;
    public SignalRHubTests(CustomWebApplicationFactory<Program> factory)
    {
        _factory = factory;
    }
    private async Task<string> RegisterAndLoginNewUser(string name, string email, string password)
    {
        var client = _factory.CreateClient();
        var registerDto = new UserRegisterDto { Name = name, Email = email, Password = password };
        var registerResponse = await client.PostAsJsonAsync("/api/v1/users/register", registerDto);
        registerResponse.EnsureSuccessStatusCode();
        var authResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        return authResponse.Data.Token;
    }
    private HubConnection CreateAuthenticatedHubConnection(string token)
    {
        var client = _factory.CreateClient();
        return new HubConnectionBuilder()
            .WithUrl(client.BaseAddress + "chatHub", options =>
            {
                options.HttpMessageHandlerFactory = _ => _factory.Server.CreateHandler();
                options.AccessTokenProvider = () => Task.FromResult(token);
            })
            .Build();
    }
    [Fact]
    public async Task SignalR_Service_Is_Registered()
    {
        // Arrange
        var token = await RegisterAndLoginNewUser("SignalRUser1", $"signalruser1_{Guid.NewGuid()}@example.com", "Password123!");
        var hubConnection = CreateAuthenticatedHubConnection(token);
        // Act & Assert
        await hubConnection.StartAsync();
        Assert.Equal(HubConnectionState.Connected, hubConnection.State);
        await hubConnection.StopAsync();
    }
    [Fact]
    public async Task ChatHub_Endpoint_Is_Accessible()
    {
        var token = await RegisterAndLoginNewUser("SignalRUser2", $"signalruser2_{Guid.NewGuid()}@example.com", "Password123!");
        var hubConnection = CreateAuthenticatedHubConnection(token);
        await hubConnection.StartAsync();
        Assert.Equal(HubConnectionState.Connected, hubConnection.State);
        await hubConnection.StopAsync();
    }
    [Fact]
    public async Task OnConnectedAsync_AddsUserToGroup()
    {
        var token = await RegisterAndLoginNewUser("SignalRUser3", $"signalruser3_{Guid.NewGuid()}@example.com", "Password123!");
        var hubConnection = CreateAuthenticatedHubConnection(token);
        bool connected = false;
        hubConnection.Closed += error =>
        {
            connected = false;
            return Task.CompletedTask;
        };
        await hubConnection.StartAsync();
        connected = hubConnection.State == HubConnectionState.Connected;
        Assert.True(connected);
        await hubConnection.StopAsync();
    }
    [Fact]
    public async Task OnDisconnectedAsync_RemovesUserFromGroup()
    {
        var token = await RegisterAndLoginNewUser("SignalRUser4", $"signalruser4_{Guid.NewGuid()}@example.com", "Password123!");
        var hubConnection = CreateAuthenticatedHubConnection(token);
        await hubConnection.StartAsync();
        await hubConnection.StopAsync();
        Assert.Equal(HubConnectionState.Disconnected, hubConnection.State);
    }
    [Fact]
    public async Task Multiple_Clients_Can_Connect_And_Disconnect()
    {
        var token1 = await RegisterAndLoginNewUser("SignalRUser5", $"signalruser5_{Guid.NewGuid()}@example.com", "Password123!");
        var token2 = await RegisterAndLoginNewUser("SignalRUser6", $"signalruser6_{Guid.NewGuid()}@example.com", "Password123!");
        var hubConnection1 = CreateAuthenticatedHubConnection(token1);
        var hubConnection2 = CreateAuthenticatedHubConnection(token2);
        await hubConnection1.StartAsync();
        await hubConnection2.StartAsync();
        Assert.Equal(HubConnectionState.Connected, hubConnection1.State);
        Assert.Equal(HubConnectionState.Connected, hubConnection2.State);
        await hubConnection1.StopAsync();
        await hubConnection2.StopAsync();
        Assert.Equal(HubConnectionState.Disconnected, hubConnection1.State);
        Assert.Equal(HubConnectionState.Disconnected, hubConnection2.State);
    }
}
</file>

<file path="PawMatch.Tests/UsersControllerTests.cs">
using System.Net.Http.Json;
using Xunit;
using System.Threading.Tasks;
using PawMatch.Api;
using PawMatch.Application.DTOs;
using System.Net.Http.Headers;
namespace PawMatch.Tests;
// Removed duplicated DTO definitions from here, they are now referenced from PawMatch.Application.DTOs
public class UsersControllerTests : IClassFixture<CustomWebApplicationFactory<Program>>
{
    private readonly HttpClient _client;
    public UsersControllerTests(CustomWebApplicationFactory<Program> factory)
    {
        _client = factory.CreateClient();
    }
    [Fact]
    public async Task Register_ValidUser_ReturnsSuccessAndToken()
    {
        // Arrange
        var request = new UserRegisterDto
        {
            Name = "Test User",
            Email = "test@example.com",
            Password = "Password123!"
        };
        // Act
        var response = await _client.PostAsJsonAsync("/api/v1/users/register", request);
        // Assert
        response.EnsureSuccessStatusCode(); // Status Code 200-299
        var apiResponse = await response.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        Assert.NotNull(apiResponse);
        Assert.Equal("success", apiResponse.Status);
        Assert.NotNull(apiResponse.Data);
        Assert.NotNull(apiResponse.Data.UserPrivate);
        Assert.NotNull(apiResponse.Data.Token);
        Assert.Equal(request.Email, apiResponse.Data.UserPrivate.Email);
        Assert.NotNull(apiResponse.Data.UserPrivate.PhotoIds);
        Assert.Empty(apiResponse.Data.UserPrivate.PhotoIds);
    }
    [Fact]
    public async Task Login_ValidCredentials_ReturnsSuccessAndToken()
    {
        // Arrange: First, register a user to ensure we have credentials to log in with
        var registerRequest = new UserRegisterDto
        {
            Name = "Login Test User",
            Email = "logintest@example.com",
            Password = "Password123!"
        };
        await _client.PostAsJsonAsync("/api/v1/users/register", registerRequest);
        var loginRequest = new UserLoginDto
        {
            Email = registerRequest.Email,
            Password = registerRequest.Password
        };
        // Act
        var response = await _client.PostAsJsonAsync("/api/v1/users/login", loginRequest);
        // Assert
        response.EnsureSuccessStatusCode();
        var apiResponse = await response.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        Assert.NotNull(apiResponse);
        Assert.Equal("success", apiResponse.Status);
        Assert.NotNull(apiResponse.Data);
        Assert.NotNull(apiResponse.Data.UserPrivate);
        Assert.NotNull(apiResponse.Data.Token);
        Assert.Equal(loginRequest.Email, apiResponse.Data.UserPrivate.Email);
        Assert.NotNull(apiResponse.Data.UserPrivate.PhotoIds);
        Assert.Empty(apiResponse.Data.UserPrivate.PhotoIds);
    }
    [Fact]
    public async Task UpdateProfile_ValidData_ReturnsSuccessAndUpdatedUser()
    {
        // Arrange: Register and log in a user to get a valid token
        var registerRequest = new UserRegisterDto
        {
            Name = "Profile Update User",
            Email = "profileupdate@example.com",
            Password = "Password123!"
        };
        var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerRequest);
        registerResponse.EnsureSuccessStatusCode();
        var registerApiResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        var authToken = registerApiResponse.Data.Token;
        _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", authToken);
        var updateRequest = new UpdateProfileDto
        {
            Name = "Updated Name",
            Bio = "Updated Bio",
            HasPet = true
        };
        // Act
        var response = await _client.PatchAsJsonAsync("/api/v1/users/profile", updateRequest);
        // Assert
        response.EnsureSuccessStatusCode();
        var apiResponse = await response.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        Assert.NotNull(apiResponse);
        Assert.Equal("success", apiResponse.Status);
        Assert.NotNull(apiResponse.Data);
        Assert.NotNull(apiResponse.Data.UserPrivate);
        Assert.Equal(updateRequest.Name, apiResponse.Data.UserPrivate.Name);
        Assert.Equal(updateRequest.Bio, apiResponse.Data.UserPrivate.Bio);
        Assert.Equal(updateRequest.HasPet, apiResponse.Data.UserPrivate.HasPet);
        Assert.NotNull(apiResponse.Data.UserPrivate.PhotoIds);
        Assert.Empty(apiResponse.Data.UserPrivate.PhotoIds);
        // Clean up the Authorization header for subsequent tests
        _client.DefaultRequestHeaders.Authorization = null;
    }
    [Fact]
    public async Task DeleteMyAccount_ValidUser_ReturnsSuccessAndDeletesAccount()
    {
        // Arrange: Register and log in a user to get a valid token
        var registerRequest = new UserRegisterDto
        {
            Name = "Delete User Test",
            Email = "deleteuser@example.com",
            Password = "Password123!"
        };
        var registerResponse = await _client.PostAsJsonAsync("/api/v1/users/register", registerRequest);
        registerResponse.EnsureSuccessStatusCode();
        var registerApiResponse = await registerResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        var authToken = registerApiResponse.Data.Token;
        _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", authToken);
        // Act: Delete the user's account
        var deleteResponse = await _client.DeleteAsync("/api/v1/users/me");
        // Assert: Check if the deletion was successful
        deleteResponse.EnsureSuccessStatusCode(); // Expect 200 OK
        var deleteApiResponse = await deleteResponse.Content.ReadFromJsonAsync<ApiResponse<object>>();
        Assert.NotNull(deleteApiResponse);
        Assert.Equal("success", deleteApiResponse.Status);
        // Optional: Try to log in with the deleted user's credentials to confirm deletion
        _client.DefaultRequestHeaders.Authorization = null; // Clear header for next request
        var loginRequest = new UserLoginDto
        {
            Email = registerRequest.Email,
            Password = registerRequest.Password
        };
        var loginResponseAfterDelete = await _client.PostAsJsonAsync("/api/v1/users/login", loginRequest);
        // Assert: Expect Unauthorized (401) as the account should be deleted
        Assert.Equal(System.Net.HttpStatusCode.Unauthorized, loginResponseAfterDelete.StatusCode);
    }
    [Fact]
    public async Task GetUserProfile_ValidUser_ReturnsSuccessAndProfile()
    {
        // Arrange
        var client = _client;
        var registerDto = new UserRegisterDto { Name = "Test User", Email = "test.profile@example.com", Password = "Password123!" };
        var registerResponse = await client.PostAsJsonAsync("/api/v1/users/register", registerDto);
        registerResponse.EnsureSuccessStatusCode();
        var loginDto = new UserLoginDto { Email = "test.profile@example.com", Password = "Password123!" };
        var loginResponse = await client.PostAsJsonAsync("/api/v1/users/login", loginDto);
        loginResponse.EnsureSuccessStatusCode();
        var authResponse = await loginResponse.Content.ReadFromJsonAsync<ApiResponse<UserAuthResponseDto>>();
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", authResponse?.Data?.Token);
        // Act
        var profileResponse = await client.GetAsync("/api/v1/users/me");
        // Assert
        profileResponse.EnsureSuccessStatusCode();
        var apiResponse = await profileResponse.Content.ReadFromJsonAsync<ApiResponse<UserPrivateDto>>();
        Assert.NotNull(apiResponse);
        Assert.Equal("Success", apiResponse.Status);
        Assert.NotNull(apiResponse.Data);
        Assert.Equal(registerDto.Email, apiResponse.Data.Email);
        Assert.Equal(registerDto.Name, apiResponse.Data.Name);
        Assert.False(apiResponse.Data.HasPet);
        Assert.False(apiResponse.Data.HasProfile);
        Assert.NotNull(apiResponse.Data.PhotoIds);
        Assert.Empty(apiResponse.Data.PhotoIds);
    }
}
</file>

<file path="PawMatch.Tests/UserSwipes.csv">
"Id","SwiperId","SwipedUserId","IsLiked","SwipeDate"
1,1,2,False,"2025-06-17 15:04:15.883298+00"
2,1,2,False,"2025-06-17 15:04:42.517078+00"
3,2,1,False,"2025-06-17 15:05:00.737813+00"
</file>

<file path="wait-for-it.sh">
#!/usr/bin/env bash
# Use this script to test if a given TCP host/port are available
WAITFORIT_cmdname=${0##*/}
echoerr() { if [[ $WAITFORIT_QUIET -ne 1 ]]; then echo "$@" 1>&2; fi }
usage()
{
    cat << USAGE >&2
Usage:
    $WAITFORIT_cmdname host:port [-s] [-t timeout] [-- command args]
    -h HOST | --host=HOST       Host or IP under test
    -p PORT | --port=PORT       TCP port under test
                                Alternatively, you specify the host and port as host:port
    -s | --strict               Only execute subcommand if the test succeeds
    -q | --quiet                Don't output any status messages
    -t TIMEOUT | --timeout=TIMEOUT
                                Timeout in seconds, zero for no timeout
    -- COMMAND ARGS             Execute command with args after the test finishes
USAGE
    exit 1
}
wait_for()
{
    if [[ $WAITFORIT_TIMEOUT -gt 0 ]]; then
        echoerr "$WAITFORIT_cmdname: waiting $WAITFORIT_TIMEOUT seconds for $WAITFORIT_HOST:$WAITFORIT_PORT"
    else
        echoerr "$WAITFORIT_cmdname: waiting for $WAITFORIT_HOST:$WAITFORIT_PORT without a timeout"
    fi
    WAITFORIT_start_ts=$(date +%s)
    while :
    do
        if [[ $WAITFORIT_ISBUSY -eq 1 ]]; then
            nc -z $WAITFORIT_HOST $WAITFORIT_PORT
            WAITFORIT_result=$?
        else
            (echo -n > /dev/tcp/$WAITFORIT_HOST/$WAITFORIT_PORT) >/dev/null 2>&1
            WAITFORIT_result=$?
        fi
        if [[ $WAITFORIT_result -eq 0 ]]; then
            WAITFORIT_end_ts=$(date +%s)
            echoerr "$WAITFORIT_cmdname: $WAITFORIT_HOST:$WAITFORIT_PORT is available after $((WAITFORIT_end_ts - WAITFORIT_start_ts)) seconds"
            break
        fi
        sleep 1
    done
    return $WAITFORIT_result
}
wait_for_wrapper()
{
    # In order to support SIGINT during timeout: http://unix.stackexchange.com/a/57692
    if [[ $WAITFORIT_QUIET -eq 1 ]]; then
        timeout $WAITFORIT_BUSYTIMEFLAG $WAITFORIT_TIMEOUT $0 --quiet --child --host=$WAITFORIT_HOST --port=$WAITFORIT_PORT --timeout=$WAITFORIT_TIMEOUT &
    else
        timeout $WAITFORIT_BUSYTIMEFLAG $WAITFORIT_TIMEOUT $0 --child --host=$WAITFORIT_HOST --port=$WAITFORIT_PORT --timeout=$WAITFORIT_TIMEOUT &
    fi
    WAITFORIT_PID=$!
    trap "kill -INT -$WAITFORIT_PID" INT
    wait $WAITFORIT_PID
    WAITFORIT_RESULT=$?
    if [[ $WAITFORIT_RESULT -ne 0 ]]; then
        echoerr "$WAITFORIT_cmdname: timeout occurred after waiting $WAITFORIT_TIMEOUT seconds for $WAITFORIT_HOST:$WAITFORIT_PORT"
    fi
    return $WAITFORIT_RESULT
}
# process arguments
while [[ $# -gt 0 ]]
do
    case "$1" in
        *:* )
        WAITFORIT_hostport=(${1//:/ })
        WAITFORIT_HOST=${WAITFORIT_hostport[0]}
        WAITFORIT_PORT=${WAITFORIT_hostport[1]}
        shift 1
        ;;
        --child)
        WAITFORIT_CHILD=1
        shift 1
        ;;
        -q | --quiet)
        WAITFORIT_QUIET=1
        shift 1
        ;;
        -s | --strict)
        WAITFORIT_STRICT=1
        shift 1
        ;;
        -h)
        WAITFORIT_HOST="$2"
        if [[ $WAITFORIT_HOST == "" ]]; then break; fi
        shift 2
        ;;
        --host=*)
        WAITFORIT_HOST="${1#*=}"
        shift 1
        ;;
        -p)
        WAITFORIT_PORT="$2"
        if [[ $WAITFORIT_PORT == "" ]]; then break; fi
        shift 2
        ;;
        --port=*)
        WAITFORIT_PORT="${1#*=}"
        shift 1
        ;;
        -t)
        WAITFORIT_TIMEOUT="$2"
        if [[ $WAITFORIT_TIMEOUT == "" ]]; then break; fi
        shift 2
        ;;
        --timeout=*)
        WAITFORIT_TIMEOUT="${1#*=}"
        shift 1
        ;;
        --)
        shift
        WAITFORIT_CLI=("$@")
        break
        ;;
        --help)
        usage
        ;;
        *)
        echoerr "Unknown argument: $1"
        usage
        ;;
    esac
done
if [[ "$WAITFORIT_HOST" == "" || "$WAITFORIT_PORT" == "" ]]; then
    echoerr "Error: you need to provide a host and port to test."
    usage
fi
WAITFORIT_TIMEOUT=${WAITFORIT_TIMEOUT:-15}
WAITFORIT_STRICT=${WAITFORIT_STRICT:-0}
WAITFORIT_CHILD=${WAITFORIT_CHILD:-0}
WAITFORIT_QUIET=${WAITFORIT_QUIET:-0}
# Check to see if timeout is from busybox?
WAITFORIT_TIMEOUT_PATH=$(type -p timeout)
WAITFORIT_TIMEOUT_PATH=$(realpath $WAITFORIT_TIMEOUT_PATH 2>/dev/null || readlink -f $WAITFORIT_TIMEOUT_PATH)
WAITFORIT_BUSYTIMEFLAG=""
if [[ $WAITFORIT_TIMEOUT_PATH =~ "busybox" ]]; then
    WAITFORIT_ISBUSY=1
    # Check if busybox timeout uses -t flag
    # (recent Alpine versions don't support -t anymore)
    if timeout &>/dev/stdout | grep -q -e '-t '; then
        WAITFORIT_BUSYTIMEFLAG="-t"
    fi
else
    WAITFORIT_ISBUSY=0
fi
if [[ $WAITFORIT_CHILD -gt 0 ]]; then
    wait_for
    WAITFORIT_RESULT=$?
    exit $WAITFORIT_RESULT
else
    if [[ $WAITFORIT_TIMEOUT -gt 0 ]]; then
        wait_for_wrapper
        WAITFORIT_RESULT=$?
    else
        wait_for
        WAITFORIT_RESULT=$?
    fi
fi
if [[ $WAITFORIT_CLI != "" ]]; then
    if [[ $WAITFORIT_RESULT -ne 0 && $WAITFORIT_STRICT -eq 1 ]]; then
        echoerr "$WAITFORIT_cmdname: strict mode, refusing to execute subprocess"
        exit $WAITFORIT_RESULT
    fi
    exec "${WAITFORIT_CLI[@]}"
else
    exit $WAITFORIT_RESULT
fi
</file>

<file path="docker-compose.yml">
version: '3.8'
services:
  caddy:
    image: caddy:latest
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./caddy/Caddyfile:/etc/caddy/Caddyfile
      - caddy_data:/data
      - caddy_config:/config
    depends_on:
      - api
  api:
    build:
      context: .
      dockerfile: Dockerfile
    restart: unless-stopped
    expose:
      - "8080"
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - ConnectionStrings__DefaultConnection=Host=db;Database=pawmatch;Username=postgres;Password=mandaci12
      - GoogleDrive__CredentialsPath=/app/credentials/credentials.json
    volumes:
      - ./credentials:/app/credentials
    depends_on:
      - db
    command: ["/wait-for-it.sh", "db:5432", "--", "dotnet", "PawMatch.Api.dll"]
  db:
    image: postgres:15
    restart: unless-stopped
    environment:
      - POSTGRES_DB=pawmatch
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=mandaci12
    volumes:
      - db-data:/var/lib/postgresql/data
    ports:
      - "5433:5432"
volumes:
  db-data:
  caddy_data:
  caddy_config:
</file>

<file path="PawMatch.Api/Program.cs">
using Microsoft.EntityFrameworkCore;
using PawMatch.Infrastructure;
using PawMatch.Infrastructure.Interfaces;
using PawMatch.Infrastructure.Repositories;
using PawMatch.Infrastructure.Providers;
using PawMatch.Application.Interfaces;
using PawMatch.Application.Services;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using Microsoft.OpenApi.Models;
namespace PawMatch.Api;
public class Program
{
    public static void Main(string[] args)
    {
var builder = WebApplication.CreateBuilder(args);
builder.WebHost.UseUrls("http://0.0.0.0:8080");
// Add services to the container.
builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo { Title = "PawMatch API", Version = "v1" });
    // JWT Bearer Auth iÃ§in:
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Description = "JWT Authorization header using the Bearer scheme. Example: \"Bearer {token}\"",
        Name = "Authorization",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.Http,
        Scheme = "bearer",
        BearerFormat = "JWT"
    });
    c.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            new string[] {}
        }
    });
});
// DbContext
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));
// DI
builder.Services.AddScoped<IUserRepository, UserRepository>();
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddSingleton<IJwtProvider, JwtProvider>();
builder.Services.AddScoped<IMatchService, MatchService>();
builder.Services.AddScoped<IDiscoverService, DiscoverService>();
builder.Services.AddScoped<IUserSwipeRepository, UserSwipeRepository>();
builder.Services.AddSingleton<IStorageProvider, GoogleDriveStorageProvider>();
builder.Services.AddScoped<IPhotoService, PhotoService>();
builder.Services.AddScoped<IMessageRepository, MessageRepository>();
builder.Services.AddScoped<IMessageService, MessageService>();
builder.Services.AddScoped<IRealtimeNotificationService, PawMatch.Api.Services.SignalRNotificationService>();
builder.Services.AddScoped<IMatchRepository, MatchRepository>();
builder.Services.AddSignalR();
// CORS Policy ekle
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowWebApp",
        policy => policy
            .AllowAnyOrigin()
            .AllowAnyHeader()
            .AllowAnyMethod()
    );
});
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = false,
            ValidateAudience = false,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(System.Text.Encoding.ASCII.GetBytes("super-secret-key-which-is-at-least-32-chars!"))
        };
        options.Events = new JwtBearerEvents
        {
            OnMessageReceived = context =>
            {
                var accessToken = context.Request.Query["access_token"];
                // EÄŸer istek SignalR hub'a ise, token'Ä± query string'den al
                var path = context.HttpContext.Request.Path;
                if (!string.IsNullOrEmpty(accessToken) && path.StartsWithSegments("/chatHub"))
                {
                    context.Token = accessToken;
                }
                return Task.CompletedTask;
            }
        };
    });
var app = builder.Build();
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
// CORS middleware'i authentication'dan Ã¶nce ekle
app.UseCors("AllowWebApp");
//app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
app.MapHub<PawMatch.Api.Hubs.ChatHub>("/chatHub");
// Sadece development ortamÄ±nda otomatik migration uygula
if (app.Environment.IsDevelopment() && !app.Environment.IsEnvironment("Testing"))
{
    using (var scope = app.Services.CreateScope())
    {
        var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();
        db.Database.Migrate();
        PawMatch.Infrastructure.AppDbContext.AppDbContextSeed.Seed(db);
    }
}
app.Run();
    }
}
</file>

</files>
